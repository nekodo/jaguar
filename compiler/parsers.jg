import * from '//compiler/prelude.jg'

// parsers have type: a -> ParseResult b c or App (App -> a) (App (App ParseResult b) c)
// or type Parser i o x = i -> ParseResult x o

data ParseResult a s =
  Success a s
  | Error String

data Parser i a = Parser (i -> ParseResult a i)
applyParser p i = case p of
  Parser f -> f i

instance Functor (Parser i) where
  fmap f pa = case pa of
    Parser pa -> Parser (\i -> case (pa i) of
      Error e -> Error e
      Success a i -> Success (f a) i)

instance Applicative (Parser i) where
  pure x = Parser (Success x)
  (<*>) pf pa = case pf of
    Parser pf -> case pa of
      Parser pa -> Parser (\i -> case (pf i) of
        Error e -> Error e
        Success f i -> case (pa i) of
          Error e -> Error e
          Success a i -> Success (f a) i)

instance Alternative (Parser i) where
  zero = Parser (\_ -> Error 'parser failure')
  (<|>) pa pb = case pa of
    Parser pa -> case pb of
      Parser pb -> Parser (\i -> case (pa i) of
        Error _ -> pb i
        Success a i -> Success a i)

(|>) a b = pure (\_ b -> b) <*> a <*> b
(<|) a b = pure (\a _ -> a) <*> a <*> b

fmany p = case p of
  Parser p -> Parser (\i -> many p i)

fsome p = case p of
  Parser p -> Parser (\i -> many1 p i)

and pa pb s = case (pa s) of
  Success a s2 -> case (pb s2) of
    Success b s3 -> Success (Pair a b) s3
    Error e -> Error e
  Error e -> Error e

apply = \f p s -> case (p s) of
  Success r s -> Success (f r) s
  Error e -> Error e

precedes = \a b -> apply snd (and a b)

succeeds = \a b -> apply fst (and a b)

between = \a b c -> precedes a (succeeds b c)

or = \a b s -> case (a s) of
  Error e -> b s
  s -> s

manyIterate = \p s -> iterate
  (Left (Success emptyArray s))
  (\r -> case r of
    Left s -> False
    Right s -> True)
  (\rs -> case rs of Left (Success rs s) -> case (p s) of
    Success r s -> Left (Success (push r rs) s)
    Error e -> Right (Success rs s))

many = \p s -> case (manyIterate p s) of
  Right a -> a
  Left b -> error 'manyIterate should never return a Left'

many1 = \a s -> case (a s) of
  Success r s -> apply (enqueue r) (many a) s
  Error e -> Error e

sepBy1 p sp = pure enqueue <*>
  p <*> fmany (sp |> p)

opt a = case a of Parser a -> let 
  parse s = case (a s) of
    Success r s -> Success (Just r) s
    e -> Success Nothing s
  in Parser parse

digits = '0123456789'
upperCaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
letters = 'abcdefghijklmnopqrstuvwxyz' ++ upperCaseLetters
