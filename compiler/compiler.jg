import * from '//compiler/prelude.jg'
import * from '//compiler/parsers.jg'
import * from '//compiler/ast.jg'
import {parseExpr, parseModule, parseType, ParserState} from '//compiler/jaguarParser.jg'
import {compileExpr, compileModule, combineModules} from '//compiler/js/backend.jg'
import {printType, reallyPrintExpr} from '//compiler/printer.jg'
import {inferType, newCtx, inferTypeModule, getTypedExports, generalize, emptyEnv} from '//compiler/typer.jg'
import {dfs} from '//compiler/graph.jg'
import {ArgBool, ArgString, parseArgs, getPositional, getString, getBool} from '//compiler/args.jg'

compile s = case (parseModule s) of
  Success m (ParserState ts p li ri) -> case (p == length ts) of
    True -> m
    False -> error ('failed to parse all tokens, stopped at ' ++ jsonStringify (getIx p ts)) 
  e -> error e

findImports m =
  let
    importFileName i = case i of
      ImportAll _ f -> f
      ImportOpen _ f ns -> f
      ImportClosed _ f n -> f
  in case m of
    Module _ is ds cs ins vs -> map importFileName is

parseT s = case (parseType s) of
  Success t ps -> t
  e -> error e

parseExports e = let
  bs = mapRecord (\s -> snd (generalize emptyEnv newCtx (parseT s))) e
  in ModuleInterface bs emptyArray emptyArray

instrument m = let
  instrumentDef d = case d of
    Pair n (Lam a p e) -> Pair n (instrumentExpr n (Lam a p e))
    _ -> d
  instrumentExpr n e = case e of
    Lam a p e -> Lam a p (instrumentExpr n e)
    _ -> let
      we = Lam emptyAnn '$unused$' e
      in App emptyAnn (App emptyAnn (Var emptyAnn 'perfTime') (Const emptyAnn (CStr n))) we
  in case m of
    Module ann is ds cs ins vs -> Module ann is ds cs ins (map instrumentDef vs)

builtinsPathArg = ArgString 'builtins' Nothing
outPathArg = ArgString 'out' Nothing
mainArg = ArgString 'main' Nothing
profileArg = ArgBool 'profile' (Just False)

argDefs = push builtinsPathArg (push outPathArg (push mainArg (push profileArg emptyArray)))

main argv = let
  // Read args.
  args = parseArgs argDefs (slice 2 argv)
  builtinsPath = getString args builtinsPathArg
  outPath = getString args outPathArg
  mainName = '//' ++ getString args mainArg
  srcFiles = getPositional args
  profile = getBool args profileArg
  
  // Load builtin exports from file.
  builtinsExports = loadJSExports builtinsPath
  
  // Compile all the srcs and construct a map of file -> imports.
  srcs = foldl (\ss s -> set ('//' ++ s) (readFile s) ss) empty srcFiles
  compiled = mapRecord compile srcs
  imports = mapRecord findImports compiled
  
  // Run a depth-first search from the main file to determine the order of
  // compilation. Also means we'll ignore any extra files that are not needed.
  ordered = dfs imports emptyArray mainName
  
  // Type each module, get its exports and transpile it to JS.
  exports = set './builtins.js' (parseExports builtinsExports) empty
  toJs er n = case er of
    Pair exports result -> let
      m = get n compiled
      typed = inferTypeModule exports m
      e = getTypedExports typed
      transpiled = case profile of
        True -> compileModule exports (instrument typed)
        False -> compileModule exports typed
      in Pair (set n e exports) (push (Pair n transpiled) result)
  jsms = snd (foldr toJs (Pair exports emptyArray) ordered)
  
  // Combine the JS modules into a single file and write it out.
  js = combineModules mainName builtinsPath jsms
  in writeFile js outPath
