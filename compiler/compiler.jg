import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {Success} from '//compiler/parsers.jg'
import {parseExpr, parseModule, parseType, ParserState} from '//compiler/jaguarParser.jg'
import {compileModule, combineModules} from '//compiler/js/backend.jg'
import {printType, reallyPrintExpr} from '//compiler/printer.jg'
import {newCtx, inferTypeModule, getTypedExports, generalize, emptyEnv} from '//compiler/typer.jg'
import {dfs} from '//compiler/graph.jg'
import {ArgBool, ArgString, parseArgs, getPositional, getString, getBool} from '//compiler/args.jg'
import {declassModule} from '//compiler/declasser.jg'
import {normalizeImports} from '//compiler/importNormalizer.jg'
import {uniquify} from '//compiler/uniquifier.jg'
import {mergeModules} from '//compiler/moduleMerger.jg'
import {inline} from '//compiler/inliner.jg'
import {translateAdts} from '//compiler/adt.jg'
import * from '//compiler/pass.jg'

moduleFile m = case m of
  Module _ n _ _ _ _ _ -> n

parse fn = case (parseModule (readFile fn) ('//' ++ fn)) of
  Success m (ParserState ts p li ri _) -> case (p == length ts) of
    True -> m
    False -> error ('failed to parse all tokens, stopped at ' ++ jsonStringify (getIx p ts)) 
  e -> error e

// Run a depth-first search from the main file to determine the order of
// compilation. Also means we'll ignore any extra files that are not needed.
depSort mainName ms = let
  modules = foldl (\r m -> set (moduleFile m) m r) empty ms
  imports = mapRecord findImports modules
  ordered = dfs imports [] mainName
  in reverse $ map (\n -> get n modules) ordered

findImports m = let
  importFileName i = case i of
    ImportAll _ f -> f
    ImportOpen _ f ns -> f
    ImportClosed _ f n -> f
  in case m of
    Module _ _ is ds cs ins vs -> map importFileName is

parseT s = case (parseType s '') of
  Success t ps -> t
  e -> error e

parseExports e = let
  bs = mapRecord (\s -> evalState newCtx (generalize emptyEnv (parseT s))) e
  in ModuleInterface bs [] []

instrument m = let
  instrumentDef d = case d of
    Pair n (Lam a p e) -> Pair n (instrumentExpr n (Lam a p e))
    _ -> d
  instrumentExpr n e = case e of
    Lam a p e -> Lam a p (instrumentExpr n e)
    _ -> let
      we = Lam emptyAnn '$unused$' e
      in App emptyAnn (App emptyAnn (Var emptyAnn 'perfTime') (Const emptyAnn (CStr n))) we
  addImport i = case i of
    ImportOpen ann './builtins.js' syms -> ImportOpen ann './builtins.js' (push (Pair 'perfTime' 'perfTime') syms)
    _ -> i
  in case m of
    Module ann fn is ds cs ins vs -> Module ann fn (map addImport is) ds cs ins (map instrumentDef vs)

builtinsPathArg = ArgString 'builtins' Nothing
outPathArg = ArgString 'out' Nothing
mainArg = ArgString 'main' Nothing
profileArg = ArgBool 'profile' (Just False)

argDefs = push builtinsPathArg (push outPathArg (push mainArg (push profileArg [])))

liftPass p a = ret (p a)

normalizeImportsPass ixm = getExports >>= \es ->
  ret (mapSnd (normalizeImports es) ixm)

uniquifyPass ixm = getExports >>= \es -> case ixm of
  Pair ix m -> ret (uniquify ('_' ++ intToString ix ++ '_') es m)

typerPass m = getExports >>= \es -> let
  typed = inferTypeModule es m
  e = getTypedExports typed
  in setExports (set (moduleFile m) e es) >> ret typed

declasserPass m = getExports >>= \es ->
  ret (declassModule es m)

main argv = let
  // Read args.
  args = parseArgs argDefs (slice 2 argv)
  builtinsPath = getString args builtinsPathArg
  outPath = getString args outPathArg
  mainName = '//' ++ getString args mainArg
  srcFiles = getPositional args
  profile = getBool args profileArg
  
  // Load builtin exports from file.
  baseExports = set './builtins.js' (parseExports (loadJSExports builtinsPath)) empty
  
  passes = perModule (
             liftPass parse) >=>
           liftPass (depSort mainName) >=>
           perModule (
             liftPass translateAdts) >=>
           liftPass zipWithIndex >=>
           perModule (
             normalizeImportsPass >=>
               uniquifyPass >=>
               typerPass >=>
               declasserPass)
  
  // Compile all the srcs and construct a map of file -> imports.
  result = runState (CompilerState baseExports 0) (passes srcFiles)
  modules = snd result
  exports = case (fst result) of CompilerState es _ -> es

  external = case (last modules) of Module _ _ _ _ _ _ bs -> map fst bs
  merged = mergeModules modules
  optimized = inline external merged
  rawjs = case profile of
    True -> compileModule exports (instrument optimized)
    False -> compileModule exports optimized
  // Combine the JS modules into a single file and write it out.
  js = combineModules mainName builtinsPath [Pair mainName rawjs]
  in writeFile js outPath
