import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType, printTypeBound, reallyPrintExpr, printDef} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'
import {replaceSkolems} from '//compiler/typeutil.jg'

data ICtx =
  ModuleCtx String
  | BindingCtx String
  | ExprCtx Expr
  | UnifyCtx Type Type
  | UpdateCtx String Type
  | PatCtx Pat
  | MRGCtx (Array String)
  | FinTypeCtx Type

data InferenceResult a = IOk a | IErr (Array ICtx) String

printIErr (IErr ctx m) = let
  printCtx ctx = case ctx of
    BindingCtx n -> ['in binding of <' ++ n ++ '>']
    UnifyCtx a b -> ['in unify <' ++ printType a ++ '> and <' ++ printType b ++ '>']
    ExprCtx (Var _ v) -> ['in var <' ++ v ++ '>']
    _ -> []
  in join (push m (concatMap printCtx ctx)) '\n'

instance Functor InferenceResult where
  fmap f a = case a of
    IErr ctx m -> IErr ctx m
    IOk a -> IOk (f a)

instance Monad InferenceResult where
  ret = IOk
  (>>=) a f = case a of
    IErr ctx m -> IErr ctx m
    IOk a -> f a

invert m = m >>= \a -> fmap ret a

(>>=>>) m f = m >>= \r -> case r of
  IErr ctx m -> ret (IErr ctx m)
  IOk x -> f x

(>>>>) m n = m >>=>> \_ -> n

foldOk f r xs = foldl (\r x -> r >>=>> \r -> f r x) (ret $ IOk r) xs
mapOk f xs = foldOk (\rs x -> f x >>=>> \r -> ret (IOk $ push r rs)) [] xs

tnum = TConst emptyAnn 'Number'
tstr = TConst emptyAnn 'String'
tapp = TApp emptyAnn
tfun a b = tapp (tapp (TConst emptyAnn '->') a) b

varsInType t =
  case t of
    TConst _ _ -> Empty
    TVar _ v -> setAdd v Empty
    TSkolem _ _ -> Empty
    TApp _ f a -> setUnion (varsInType f) (varsInType a)
    TForall _ _ _ t -> varsInType t
    _ -> error ('unsupported type in varsInType ' ++ jsonStringify t)

replaceVar v vt t =
  case t of
    TConst _ _ -> t
    TSkolem _ _ -> t
    TVar _ w -> case (v == w) of
      True -> vt
      False -> t
    TApp ann f a -> TApp ann (replaceVar v vt f) (replaceVar v vt a)
    TForall ann vs bs t -> TForall ann vs bs (replaceVar v vt t)
    _ -> error ('unsupported type in replaceVar ' ++ jsonStringify t)

forceType t = let
  changed a b =
    case a of
      TVar _ v -> case b of
        TVar _ w -> v /= w
        _ -> True
      _ -> False
  in case t of
    TVar _ v -> gets >>= \(US vars _ _) ->
      case (lookup v vars) of
        Nothing -> ret t
        Just t -> forceType t >>= \t2 ->
          case (changed t t2) of
            True -> setVar v t2 >> ret t2
            False -> ret t2
    _ -> ret t

setVar v t = gets >>= \(US vars n rins) -> sets $ US (insert v t vars) n rins

unifyType ctx a b = let
  ctx2 = push (UnifyCtx a b) ctx
  ok a = ret $ IOk a
  err m = ret $ IErr ctx2 m
  in forceType a >>= \a -> forceType b >>= \b -> case (a, b) of
    (TUnknown, _) -> err 'unify with TUnknown'
    (_, TUnknown) -> err 'unify with TUnknown'
    (TVar _ v, TVar _ w) -> case (v == w) of
      True -> ok a
      False -> case (preferredVar v w) of
        True -> setVar w a >> ok a
        False -> setVar v b >> ok b
    (TVar _ v, _) -> setVar v b >> ok b
    (_, TVar _ w) -> setVar w a >> ok a
    (TConst _ n, TConst _ m) -> case (n == m) of
      True -> ok a
      False -> err 'type name mismatch'
    (TSkolem _ v, TSkolem _ w) -> case (v == w) of
      True -> ok a
      False -> err 'skolem mismatch'
    (TApp _ fa xa, TApp _ fb xb) -> unifyType ctx2 fa fb >>=>> \fu -> 
      unifyType ctx2 xa xb >>=>> \xu -> ok (tapp fu xu)
    _ -> err ('cannot unify ' ++ printType a ++ ' and ' ++ printType b)

// State for type unification.
// First map is type var to type.
data UnifierState = US (Map String Type) Number (Array TypeBound)

freshName = gets >>= \(US vars n rins) -> let
  v = '$' ++ intToString n
  n2 = n + 1
  in sets (US vars n2 rins) >> ret v

freshVar = fmap (TVar emptyAnn) freshName

preferredVar v w = case (length v == length w) of
  True -> v < w
  False -> length v < length w

instantiate t = let
  addRep reps v = freshVar >>= \t ->
    ret $ insert v t reps
  replaceSkolemsTB reps (TCBound ann clz t) = TCBound ann clz (replaceSkolems t reps)
  in case t of
    TForall _ vs bs t ->
      foldM addRep Empty vs >>= \reps ->
        addRequiredBounds (map (replaceSkolemsTB reps) bs) >>
          ret (replaceSkolems t reps)
    _ -> ret t

resolveName ctx n scope =
  case (lookup n scope) of
    Nothing -> ret $ IErr ctx 'name not in scope'
    Just t -> fmap IOk $ instantiate t

addRequiredBounds bs = debug2 ('**adding bounds: ' ++ join (map printTypeBound bs) ', ') $ gets >>= \(US vars n rins) ->
  sets (US vars n (concat rins bs))

inferExpr ctx scope e = let
  ctx2 = push (ExprCtx e) ctx
  ok e = ret $ IOk e
  err m = ret $ IErr ctx2 m
  finalize e t = case (getType e) of
    TUnknown -> ok (setType t e)
    t2 -> unifyType ctx2 t t2 >>>> ok e
  in case e of
    Const _ (CNum _) -> finalize e tnum
    Const _ (CStr _) -> finalize e tstr
    Var _ v -> resolveName ctx2 v scope >>=>> finalize e
    App ann f a -> inferExpr ctx2 scope f >>=>> \fi ->
      inferExpr ctx2 scope a >>=>> \ai ->
        freshVar >>= \v ->
          unifyType ctx2 (getType fi) (tfun (getType ai) v) >>>>
            finalize (App ann fi ai) v
    Lam ann p e ->
      freshVar >>= \v ->
        inferExpr ctx2 (insert p v scope) e >>=>> \ei ->
          finalize (Lam ann p ei) (tfun v (getType ei))
    Gen ann e -> case (getAnnType ann) of
      TForall _ _ _ t ->
        inferExpr ctx2 scope e >>=>> \ei ->
          unifyType ctx2 t (getType ei) >>>>
            ok (Gen ann ei) 
      _ -> err 'Gen expr without a TForall type'
    New ann 'Array' es ->
      mapOk (inferExpr ctx2 scope) es >>=>> \esi ->
        freshVar >>= \elemType ->
          mapOk (unifyType ctx2 elemType) (map getType esi) >>>>
            finalize (New ann 'Array' esi) (TApp emptyAnn (TConst emptyAnn 'Array') elemType)
    New ann c es ->
      mapOk (inferExpr ctx2 scope) es >>=>> \esi ->
        freshVar >>= \dt ->
          resolveName ctx2 c scope >>=>> \ct ->
            unifyType ctx2 ct (consType dt (map getType esi)) >>>>
              finalize (New ann c esi) dt
    Case ann e ps -> let
      collectBindings scope p =
        case p of
          PConst _ _ -> scope
          PVar _ v -> insert v (getPatType p) scope
          PData _ _ ps -> foldl collectBindings scope ps
      inferCase pt rt (p, e) =
        inferPat ctx2 scope p >>=>> \pi ->
          unifyType ctx2 pt (getPatType pi) >>=>> \_ ->
            inferExpr ctx2 (collectBindings scope pi) e >>=>> \ei ->
              unifyType ctx2 rt (getType ei) >>>>
                ok (pi, ei)
      in inferExpr ctx2 scope e >>=>> \ei ->
        freshVar >>= \rt ->
          mapOk (inferCase (getType ei) rt) ps >>=>> \psi ->
            finalize (Case ann ei psi) rt
    Let ann bs e ->
      inferBindings ctx2 scope bs >>=>> \(scope2, bsi) ->
        inferExpr ctx2 scope2 e >>=>> \ei ->
          finalize (Let ann bsi ei) (getType ei)

consType dataType argTypes = foldr (\d t -> tfun t d) dataType argTypes

inferPat ctx scope p = let
  ctx2 = push (PatCtx p) ctx
  ok p = ret $ IOk p
  err m = ret $ IErr ctx2 m
  finalize p t = case (getPatType p) of
    TUnknown -> ok (setPatType t p)
    t2 -> unifyType ctx2 t t2 >>>> ok p
  in case p of
    PVar _ _ -> freshVar >>= finalize p
    PConst _ (CNum _) -> finalize p tnum
    PConst _ (CStr _) -> finalize p tstr
    PData ann n ps ->
      mapOk (inferPat ctx2 scope) ps >>=>> \psi ->
        freshVar >>= \dt ->
          resolveName ctx2 n scope >>=>> \ct ->
            unifyType ctx2 ct (consType dt (map getPatType psi)) >>>>
              finalize (PData ann n psi) dt

freeVars scope e =
  case e of
    Const _ _ -> Empty
    Var _ v -> case (setContains v scope) of
      False -> setAdd v Empty
      True -> Empty
    App _ f a -> setUnion (freeVars scope f) (freeVars scope a)
    Lam _ p e -> freeVars (setAdd p scope) e
    Gen _ e -> freeVars scope e
    New _ _ es -> foldl (\fvs e -> setUnion fvs (freeVars scope e)) Empty es
    Let _ bs e -> let
      scope2 = setAddAll (map fst bs) scope
      in foldl (\fvs (_, e) -> setUnion fvs (freeVars scope2 e)) (freeVars scope2 e) bs
    Case _ e ps -> let
      scopeFromPat scope p =
        case p of
          PConst _ _ -> scope
          PVar _ v -> setAdd v scope
          PData _ _ ps -> foldl scopeFromPat scope ps
      in foldl (\fvs (p, e) -> setUnion fvs (freeVars (scopeFromPat scope p) e)) (freeVars scope e) ps


bindingsToScope = foldl (\s (n, e) -> insert n (getType e) s)

// Compute SCCs and split into mutually recursive groups.
sortBindings bs = let
  bsm = insertAll bs Empty
  g = foldl (\g (n, e) -> insert n (filter (\v -> (isJust $ lookup v bsm) && (v /= n)) (setToArray $ freeVars Empty e)) g) Empty bs
  ccs = sccSorted g
  in map (map (\v -> (v, fromJust $ lookup v bsm))) ccs


splitBindings bs = let
  split (ubs, tbs) (n, e) =
    case (getType e) of
      TUnknown -> (push (n, e) ubs, tbs)
      _ -> (ubs, push (n, e) tbs)
  in foldl split ([], []) bs

prepareBindings scope bs = let
  (ubs, tbs) = splitBindings bs
  scope2 = bindingsToScope scope tbs
  sortedBs = concat (sortBindings ubs) (map (\b -> [b]) tbs)
  in (scope2, sortedBs)

// Compute SCCs and split into mutually recursive groups.
// Then run inferMGR in the correct order.
// inferBindings
inferBindings ctx scope bs = let
  (scope2, bs2) = prepareBindings scope bs
  infer (scope, rs) bs =
    inferMRG ctx scope bs >>=>> \bsi ->
      ret (IOk (bindingsToScope scope bsi, concat rs bsi))
  in foldOk infer (scope2, []) bs2

// inferMGR
// run inference all the bindings together, then generalize each
inferMRG ctx scope bs = let
  ctx2 = push (MRGCtx (map fst bs)) ctx 
  add (scope, bs) (n, e) =
    case (getType e) of
      TUnknown -> freshVar >>= \t ->
        ret (insert n t scope, push (n, setType t e) bs)
      t -> ret (insert n t scope, push (n, e) bs)
  inferB scope (n, e) =
    inferExpr (push (BindingCtx n) ctx2) scope e >>=>> \ei ->
      ret (IOk (n, ei))
  genB (rvs, rbs) (n, e) = generalize (getType e) >>= \(vs, t) ->
    case (length vs) of
      0 -> ret (rvs, push (n, setType t e) rbs)
      _ -> ret (concat rvs vs, push (n, Gen (setAnnType t emptyAnn) e) rbs)
  setGenVar v = setVar v (TSkolem emptyAnn v)
  in foldM add (scope, []) bs >>= \(scope2, bst) ->
    mapOk (inferB scope2) bst >>=>> \bsi ->
      resolveRins >>= \_ ->
        foldM genB ([], []) bsi >>= \(vs, bsg) ->
          mapM setGenVar vs >>
            ret (IOk bsg)

inferTopMRG ctx scope bs = let
  (US vars _ _, bsi) = runState (US Empty 1 []) (inferMRG ctx scope bs)
  in bsi >>= finalizeBindings ctx vars

inferTopBindings ctx scope bs = let
  (scope2, bs2) = prepareBindings scope bs
  infer (scope, rs) bs =
    inferTopMRG ctx scope bs >>= \bsi ->
      IOk (bindingsToScope scope bsi, concat rs bsi)
  in fmap snd $ foldM infer (scope2, []) bs2

resolveType t = let
  resolve vars t =
    case t of
      TVar _ v -> case (lookup v vars) of
        Nothing -> t
        Just t -> resolve vars t
      TApp ann f a -> TApp ann (resolve vars f) (resolve vars a)
      _ -> t
  in gets >>= \(US vars _ _) -> ret (resolve vars t)

resolveBound (TCBound ann clz t) = resolveType t >>= \t -> ret (TCBound ann clz t)
resolveBounds = mapM resolveBound

resolveRins = gets >>= \(US vars n rins) ->
  resolveBounds rins >>= \rins2 ->
    sets (US vars n rins2)

boundsWithVars vs = let
  match (TCBound _ _ t) = inType t
  inType t =
    case t of
      TVar _ v -> setContains v vs
      TApp _ f a -> inType f || inType a
      _ -> False
  in gets >>= \(US _ _ rins) ->
    ret (filter match rins)

// generalize
// Forall can include any type vars which are entirely free (absent from vars map).
generalize t = let
  gen t =
    case t of
      TConst _ _ -> ret (t, [])
      TSkolem _ _ -> ret (t, [])
      TApp ann f a ->
        gen f >>= \(fg, fvs) ->
          gen a >>= \(ag, avs) ->
            ret (TApp ann fg ag, concat fvs avs)
      TVar _ v -> gets >>= \(US vars _ _) ->
        case (lookup v vars) of
          Just t -> gen t
          Nothing -> let
            sk = TSkolem emptyAnn v
            in ret (sk, [v])
  in case t of
    TForall _ _ _ _ -> ret ([], t)
    _ -> gen t >>= \(tg, vs) ->
      case (length vs) of
        0 -> ret ([], tg)
        _ -> let
          vsSet = setAddAll vs Empty
          in boundsWithVars vsSet >>= \bs ->
            ret (vs, TForall emptyAnn vs bs tg)

finalizeType ctx vars t = let
  ctx2 = push (FinTypeCtx t) ctx
  ok e = IOk e
  err m = IErr ctx2 m
  fin = finalizeType ctx2 vars
  in case t of
    TConst _ _ -> ok t
    TSkolem _ _ -> ok t
    TApp ann f a -> fin f >>= \ff ->
      fin a >>= \af ->
        ok (TApp ann ff af)
    TForall ann vs bs t -> fin t >>= \tf ->
      mapM (finalizeTypeBound ctx2 vars) bs >>= \bsf ->
        ok (TForall ann vs bsf tf)
    TVar _ v ->
      case (lookup v vars) of
        Just t -> fin t
        Nothing -> err 'unknown type var found during finalization'

finalizeTypeBound ctx vars (TCBound ann clz t) =
  finalizeType ctx vars t >>= \t -> IOk (TCBound ann clz t)

finalizeExpr ctx vars e = let
  ctx2 = push (ExprCtx e) ctx
  ok e = IOk e
  err m = IErr ctx2 m
  fin = finalizeExpr ctx2 vars
  in finalizeType ctx2 vars (getType e) >>= \tf ->
    case e of
      App ann f a ->
        fin f >>= \ff ->
          fin a >>= \fa ->
            ok (App (setAnnType tf ann) ff fa)
      Lam ann p e ->
        fin e >>= \ef ->
          ok (Lam (setAnnType tf ann) p ef)
      Gen ann e ->
        fin e >>= \ef ->
          ok (Gen (setAnnType tf ann) ef)
      Let ann bs e ->
        finalizeBindings ctx2 vars bs >>= \bsf ->
          fin e >>= \ef ->
            ok (Let (setAnnType tf ann) bsf ef)
      New ann c es ->
        mapM fin es >>= \esf ->
          ok (New (setAnnType tf ann) c esf) 
      Case ann e ps -> let
        finCase (p, e) =
          finalizePat ctx2 vars p >>= \pf ->
            fin e >>= \ef ->
              ok (pf, ef)
        in fin e >>= \ef ->
          mapM finCase ps >>= \psf ->
            ok (Case (setAnnType tf ann) ef psf)
      _ -> ok (setType tf e)

finalizePat ctx vars p = let
  ctx2 = push (PatCtx p) ctx
  in finalizeType ctx2 vars (getPatType p) >>= \tf ->
    case p of
      PData ann n ps ->
        mapM (finalizePat ctx2 vars) ps >>= \psf ->
          IOk (PData (setAnnType tf ann) n psf)
      _ -> IOk (setPatType tf p)

finalizeBindings ctx vars bs = let
  fin (n, e) = 
    finalizeExpr (push (BindingCtx n) ctx) vars e >>= \ef ->
      IOk (n, ef)
  in mapM fin bs

// Top-level bindings
