import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import * from '//compiler/parsers.jg'
import {tokenize, Token, WsTok, SymTok, NumTok, StrTok, OpTok, IdTok, ComTok} from '//compiler/jaguarLexer.jg'

data ParserState = ParserState
  (Array Token) // input (ts)
  Number // position (p)
  Number // current line indent (li)
  Number // required line indent (ri)

mkParserState ts = ParserState ts 0 (case (getIx 0 ts) of Token t v l c -> c) 0

filterWhitespaceAndComments = filter (\t -> case t of
  Token (WsTok) v l c -> False
  Token (ComTok) v l c -> False
  t -> True)

runParser p s = case (tokenize s) of
  Success ts s -> applyParser p (mkParserState (filterWhitespaceAndComments ts))
  Error e -> Error e

parseToken f = let
  parse s = case s of
    // Check that we have not ran out of tokens.
    ParserState ts p li ri -> case (p < length ts) of
      False -> Error 'run out of tokens'
      // Check that the indentation is sufficient.
      True -> case (getIx p ts) of
        Token t v l c -> case (c < ri) of
          True -> Error 'token not indented sufficiently'
          // Run the actual token parsing function.
          False -> case (f (getIx p ts)) of
            Nothing -> Error 'parser fun failed'
            // Success, now need to update the position and current line indent.
            Just r -> case ((p + 1) < length ts) of
              False -> Success r (ParserState ts (p + 1) li ri)
              True -> case (getIx (p + 1) ts) of
                Token t v l2 c -> case (l2 > l) of
                  False -> Success r (ParserState ts (p + 1) li ri)
                  True -> Success r (ParserState ts (p + 1) c ri)
  in Parser parse

(<*->) pf pa = case pf of
  Parser pf -> case pa of
    Parser pa -> let
      parse s = case s of
        ParserState ts p li ri -> case (pf s) of
          Success f (ParserState ts p2 li2 ri2) -> case (pa (ParserState ts p2 li2 (li + 1))) of
            Success a (ParserState ts p3 li3 ri3) -> Success (f a) (ParserState ts p3 li3 ri)
            Error e -> Error e
          Error e -> Error e
      in Parser parse

(|->) pa pb = pure (\_ b -> b) <*> pa <*-> pb

reserved = push 'as' (push 'class' (push 'where' (push 'instance' (push 'let' (push 'in' (push 'from' (push 'import' (push 'case' (push 'of' (push 'data' emptyArray))))))))))

symP s = parseToken (\t -> case t of
  Token (SymTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

operatorP s = parseToken (\t -> case t of
  Token (OpTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

anyOpP = parseToken (\t -> case t of
  Token (OpTok) v i c -> Just v
  x -> Nothing)

reservedP s = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

nonReservedP = parseToken (\t -> case t of
  Token (IdTok) v l c -> case (contains v reserved) of
    True -> Nothing
    False -> Just v
  x -> Nothing)

upperCaseId = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (containsChar (getChar 0 v) upperCaseLetters) of
    True -> Just v
    False -> Nothing
  t -> Nothing)

notUpperCaseId = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (containsChar (getChar 0 v) upperCaseLetters) of
    False -> case (contains v reserved) of
      False -> Just v
      True -> Nothing
    True -> Nothing
  t -> Nothing)

parenP p = symP '(' |> p <| symP ')'

varP = parseToken (\t -> case t of
  Token (IdTok) v l c -> case (contains v reserved) of
    True -> Nothing
    False -> Just (Var emptyAnn v)
  x -> Nothing)

cnumP = parseToken (\t -> case t of
  Token (NumTok) v l c -> Just (Const emptyAnn (CNum (unsafeStringToInt v)))
  x -> Nothing)

cstrP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just (Const emptyAnn (CStr v))
  x -> Nothing)
  
constP = cstrP <|> cnumP

exprP = Parser (\s -> applyParser opP s)

simpleExprP = varP <|> constP <|> parenP exprP

appP = pure (foldl (App emptyAnn)) <*>
  (varP <|> parenP exprP) <*-> fmany simpleExprP

lamP = pure (\ps a -> foldr (\a p -> Lam emptyAnn p a) a ps) <*>
  (symP '\\' |-> fsome notUpperCaseId) <*-> (operatorP '->' |> exprP)

patP = Parser (\s -> applyParser allPatP s)

pvarP = pure (PVar emptyAnn) <*> notUpperCaseId

pcnumP = parseToken (\t -> case t of
  Token (NumTok) v l c -> Just (PConst emptyAnn (CNum (unsafeStringToInt v)))
  x -> Nothing)

pcstrP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just (PConst emptyAnn (CStr v))
  x -> Nothing)

strP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just v
  x -> Nothing)

pconstP = pcnumP <|> pcstrP

pdataP = pure (PData emptyAnn) <*>
  upperCaseId <*-> fmany (pvarP <|> pconstP <|> parenP patP)
  
allPatP = pvarP <|> pconstP <|> pdataP

ofP = pure Pair <*>
  patP <*-> (operatorP '->' |> exprP)

caseP = pure (Case emptyAnn) <*>
  (reservedP 'case' |-> simpleExprP) <*-> (reservedP 'of' |> fsome ofP)

defP = pure (\n ps e -> Pair n (foldr (\e p -> Lam emptyAnn p e) e ps)) <*>
  notUpperCaseId <*-> fmany notUpperCaseId <*-> (operatorP '=' |> exprP)

letP = pure (Let emptyAnn) <*>
  (reservedP 'let' |-> fsome defP) <*> (reservedP 'in' |-> exprP)

primaryExprP = appP <|> constP <|> lamP <|> caseP <|> letP

opP = pure (\e oes -> foldl (\a ob -> case ob of Pair op b -> App emptyAnn (App emptyAnn (Var emptyAnn op) a) b) e oes) <*>
  primaryExprP <*-> fmany (pure Pair <*> anyOpP <*> primaryExprP)

// --------------- types -------------------

typeP = Parser (\s -> applyParser tfunP s)

tconstP = pure (TConst emptyAnn) <*> upperCaseId

tvarP = pure (TVar emptyAnn) <*> notUpperCaseId

simpleTypeP = tconstP <|> tvarP <|> parenP typeP

tappP = pure (foldl (TApp emptyAnn)) <*>
  simpleTypeP <*-> fmany simpleTypeP

tfunP = pure (\t ts -> foldr1 (\b a -> TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b) (enqueue t ts)) <*>
  tappP <*-> fmany (operatorP '->' |> tappP)

// ------------ type classes ---------------

classP = pure (\name tv maybeDefs -> Class emptyAnn name tv (justOr emptyArray maybeDefs)) <*>
  (reservedP 'class' |-> upperCaseId) <*-> notUpperCaseId <*-> opt (reservedP 'where' |> fsome classMemberP)

classMemberP = pure Pair <*>
  notUpperCaseId <*-> (operatorP '::' |> typeP)

instanceP = pure (\name t maybeDefs -> Instance emptyAnn name t (justOr emptyArray maybeDefs)) <*>
  (reservedP 'instance' |-> upperCaseId) <*-> simpleTypeP <*-> opt (reservedP 'where' |> fsome defP)

// --------------- module ------------------

dataConP = pure (DataCon emptyAnn) <*>
  upperCaseId <*-> fmany simpleTypeP

dataP = pure (Data emptyAnn) <*>
  (reservedP 'data' |-> upperCaseId) <*-> fmany notUpperCaseId <*-> (operatorP '=' |> sepBy1 dataConP (operatorP '|'))

importNoAliasP = pure (\n -> Pair n n) <*> nonReservedP

importAliasP = pure Pair <*> nonReservedP <*> (reservedP 'as' |> nonReservedP)

importOpenP = pure (\ns f -> ImportOpen emptyAnn f ns) <*>
  (symP '{' |> sepBy1 (importAliasP <|> importNoAliasP) (symP ',') <| symP '}') <*> (reservedP 'from' |> strP)

importAllP = pure (ImportAll emptyAnn) <*>
  (operatorP '*' |> reservedP 'from' |> strP)

importP = reservedP 'import' |> (importOpenP <|> importAllP)

moduleP = pure (\is es -> case (splitFourWay es) of Pair (Pair dts dfs) (Pair cs ins) -> Module emptyAnn is dts cs ins dfs) <*>
  fmany importP <*> fsome topLevelP

splitFourWay e = case (splitEither e) of
  Pair a b -> Pair (splitEither a) (splitEither b)

eitherP a b = Parser $ \s -> applyParser ((pure Left <*> a) <|> (pure Right <*> b)) s
topLevelP = eitherP (eitherP dataP defP) (eitherP classP instanceP)
  
parseModule = runParser moduleP
parseImports = runParser (fmany importP)
parseExpr = runParser exprP
parseType = runParser typeP
