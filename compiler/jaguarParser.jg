import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import * from '//compiler/parsers.jg'
import * from '//compiler/jaguarLexer.jg'

data ParserState = ParserState
  (Array Token) // input (ts)
  Number // position (p)
  Number // current line indent (li)
  (Array Number) // required line indent (ri)

mkParserState = \ts -> ParserState ts 0 (case (get 0 ts) of Token t v l c -> c) (push 0 emptyArray)

filterWhitespaceAndComments = filter (\t -> case t of
  Token (WsTok) v l c -> False
  Token (ComTok) v l c -> False
  t -> True)

runParser = \p s -> case (tokenize s) of
  Success ts s -> p (mkParserState (filterWhitespaceAndComments ts))
  e -> e

parseToken = \f s -> case s of
  // Check that we have not ran out of tokens.
  ParserState ts p li ri -> case (p < length ts) of
    False -> Error 'run out of tokens'
    // Check that the indentation is sufficient.
    True -> case (get p ts) of
      Token t v l c -> case (c < ri) of
        True -> Error 'token not indented sufficiently'
        // Run the actual token parsing function.
        False -> case (f (get p ts)) of
          Nothing -> Error 'parser fun failed'
          // Success, now need to update the position and current line indent.
          Just r -> case ((p + 1) < length ts) of
            False -> Success r (ParserState ts (p + 1) li ri)
            True -> case (get (p + 1) ts) of
              Token t v l2 c -> case (l2 > l) of
                False -> Success r (ParserState ts (p + 1) li ri)
                True -> Success r (ParserState ts (p + 1) c ri)

andIndent = \a b s -> case s of
  ParserState ts p li ri -> case (a s) of
    Success a (ParserState ts p2 li2 ri2) -> case (b (ParserState ts p2 li2 (li + 1))) of
      Success b (ParserState ts p3 li3 ri3) -> Success (Pair a b) (ParserState ts p3 li3 ri)
      e -> e
    e -> e

reserved = push 'let' (push 'in' (push 'from' (push 'import' (push 'case' (push 'of' (push 'data' emptyArray))))))

symP = \s -> parseToken (\t -> case t of
  Token (SymTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

operatorP = \s -> parseToken (\t -> case t of
  Token (OpTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

anyOpP = parseToken (\t -> case t of
  Token (OpTok) v i c -> Just v
  x -> Nothing)

reservedP = \s -> parseToken (\t -> case t of
  Token (IdTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

nonReservedP = parseToken (\t -> case t of
  Token (IdTok) v l c -> case (contains v reserved) of
    True -> Nothing
    False -> Just v
  x -> Nothing)

upperCaseId = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (contains (get 0 v) upperCaseLetters) of
    True -> Just v
    False -> Nothing
  t -> Nothing)

notUpperCaseId = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (contains (get 0 v) upperCaseLetters) of
    False -> case (contains v reserved) of
      False -> Just v
      True -> Nothing
    True -> Nothing
  t -> Nothing)

parenP = \p -> between (symP '(') p (symP ')')

varP = parseToken (\t -> case t of
  Token (IdTok) v l c -> case (contains v reserved) of
    True -> Nothing
    False -> Just (Var emptyAnn v)
  x -> Nothing)

cnumP = parseToken (\t -> case t of
  Token (NumTok) v l c -> Just (Const emptyAnn (CNum (unsafeStringToInt v)))
  x -> Nothing)

cstrP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just (Const emptyAnn (CStr v))
  x -> Nothing)
  
constP = or cstrP cnumP

simpleExprP = \s -> or varP (or constP (parenP exprP)) s

appP = \s -> apply
  (\p -> case p of Pair f as -> foldl (\f a -> App emptyAnn f a) f as)
  (andIndent (or varP (parenP exprP)) (many simpleExprP))
  s

lamP = \s -> apply
  (\p -> case p of Pair _ (Pair ps a) -> foldr (\a p -> Lam emptyAnn p a) a ps)
  (andIndent (symP '\\') (and (many1 notUpperCaseId) (precedes (operatorP '->') exprP)))
  s

pvarP = apply (PVar emptyAnn) notUpperCaseId

pcnumP = parseToken (\t -> case t of
  Token (NumTok) v l c -> Just (PConst emptyAnn (CNum (unsafeStringToInt v)))
  x -> Nothing)

pcstrP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just (PConst emptyAnn (CStr v))
  x -> Nothing)

strP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just v
  x -> Nothing)

pconstP = or pcnumP pcstrP

pdataP = \s -> apply
  (\p -> case p of Pair n ps -> PData emptyAnn n ps)
  (andIndent upperCaseId (many (or pvarP (or pconstP (parenP patP)))))
  s

patP = or pvarP (or pconstP pdataP)

ofP = \s -> andIndent patP (precedes (operatorP '->') exprP) s

caseP = apply
  (\p -> case p of Pair _ (Pair e ps) -> Case emptyAnn e ps)
  (andIndent (reservedP 'case') (and simpleExprP (precedes (reservedP 'of') (many1 ofP))))

defP = apply
  (\p -> case p of Pair (Pair n ps) e -> Pair n (foldr (\e p -> Lam emptyAnn p e) e ps))
  (andIndent (andIndent notUpperCaseId (many notUpperCaseId)) (precedes (operatorP '=') (\s -> exprP s)))

letDefsP = apply
  snd
  (andIndent (reservedP 'let') (many1 defP))

letInP = \s -> (precedes (reservedP 'in') exprP) s

letP = apply
  (\p -> case p of Pair ds e -> Let emptyAnn ds e)
  (and letDefsP letInP)

primaryExprP = \s -> or appP (or constP (or lamP (or caseP letP))) s

exprP = apply
  (\p -> case p of Pair e oes -> foldl (\a ob -> case ob of Pair op b -> App emptyAnn (App emptyAnn (Var emptyAnn op) a) b) e oes)
  (andIndent primaryExprP (many (and anyOpP primaryExprP)))

// --------------- types -------------------

tconstP = apply (TConst emptyAnn) upperCaseId

tvarP = apply (TVar emptyAnn) notUpperCaseId

simpleTypeP = \s -> or tconstP (or tvarP (parenP typeP)) s

tappP = apply
  (\p -> case p of Pair t ts -> foldl (\a b -> TApp emptyAnn a b) t ts)
  (andIndent simpleTypeP (many simpleTypeP))

tfunP = apply
  (\p -> case p of Pair t ts -> foldr1 (\b a -> TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b) (enqueue t ts))
  (andIndent tappP (many (precedes (operatorP '->') tappP)))

typeP = tfunP

// --------------- module ------------------

dataConP = apply
  (\p -> case p of Pair n ts -> DataCon emptyAnn n ts)
  (andIndent upperCaseId (many simpleTypeP))

dataP = apply
  (\r -> case r of Pair _ (Pair n (Pair ps cs)) -> Data emptyAnn n ps cs)
  (andIndent (reservedP 'data') (and upperCaseId (and (many notUpperCaseId) (precedes (operatorP '=') (sepBy1 dataConP (operatorP '|'))))))

importClosedP = apply
  (\p -> case p of Pair n f -> ImportClosed emptyAnn f n)
  (and nonReservedP (precedes (reservedP 'from') strP))

importOpenP = apply
  (\p -> case p of Pair ns f -> ImportOpen emptyAnn f ns)
  (and (between (symP '{') (sepBy1 nonReservedP (symP ',')) (symP '}')) (precedes (reservedP 'from') strP))

importAllP = apply
  (\p -> case p of Pair n f -> ImportAll emptyAnn f)
  (and (operatorP '*') (precedes (reservedP 'from') strP))

importP = apply snd (andIndent (reservedP 'import') (or importClosedP (or importOpenP importAllP)))

moduleP = apply
  (\p -> case p of Pair is es -> case (splitEither es) of Pair dts dfs -> Module emptyAnn is dts dfs)
  (and (many importP) (many1 (or (apply Left dataP) (apply Right defP))))
  
parseModule = runParser moduleP
parseImports = runParser (many importP)
parseExpr = runParser exprP
parseType = runParser typeP
