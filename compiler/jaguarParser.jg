import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import * from '//compiler/parsers.jg'
import {tokenize, Token, WsTok, SymTok, NumTok, StrTok, OpTok, IdTok, ComTok} from '//compiler/jaguarLexer.jg'

data ParserState = ParserState
  (Array Token) // input (ts)
  Number // position (p)
  Number // current line indent (li)
  Number // required line indent (ri)

mkParserState = \ts -> ParserState ts 0 (case (getIx 0 ts) of Token t v l c -> c) 0

filterWhitespaceAndComments = filter (\t -> case t of
  Token (WsTok) v l c -> False
  Token (ComTok) v l c -> False
  t -> True)

runParser = \p s -> case (tokenize s) of
  Success ts s -> p (mkParserState (filterWhitespaceAndComments ts))
  Error e -> Error e

parseToken = \f s -> case s of
  // Check that we have not ran out of tokens.
  ParserState ts p li ri -> case (p < length ts) of
    False -> Error 'run out of tokens'
    // Check that the indentation is sufficient.
    True -> case (getIx p ts) of
      Token t v l c -> case (c < ri) of
        True -> Error 'token not indented sufficiently'
        // Run the actual token parsing function.
        False -> case (f (getIx p ts)) of
          Nothing -> Error 'parser fun failed'
          // Success, now need to update the position and current line indent.
          Just r -> case ((p + 1) < length ts) of
            False -> Success r (ParserState ts (p + 1) li ri)
            True -> case (getIx (p + 1) ts) of
              Token t v l2 c -> case (l2 > l) of
                False -> Success r (ParserState ts (p + 1) li ri)
                True -> Success r (ParserState ts (p + 1) c ri)

andIndent pa pb s = case s of
  ParserState ts p li ri -> case (pa s) of
    Success a (ParserState ts p2 li2 ri2) -> case (pb (ParserState ts p2 li2 (li + 1))) of
      Success b (ParserState ts p3 li3 ri3) -> Success (Pair a b) (ParserState ts p3 li3 ri)
      Error e -> Error e
    Error e -> Error e

precedesIndent pa pb = apply
  (\p -> case p of Pair _ r -> r)
  (andIndent pa pb)

reserved = push 'as' (push 'class' (push 'where' (push 'instance' (push 'let' (push 'in' (push 'from' (push 'import' (push 'case' (push 'of' (push 'data' emptyArray))))))))))

symP = \s -> parseToken (\t -> case t of
  Token (SymTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

operatorP = \s -> parseToken (\t -> case t of
  Token (OpTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

anyOpP = parseToken (\t -> case t of
  Token (OpTok) v i c -> Just v
  x -> Nothing)

reservedP = \s -> parseToken (\t -> case t of
  Token (IdTok) v i c -> case (v == s) of
    True -> Just s
    False -> Nothing
  x -> Nothing)

nonReservedP = parseToken (\t -> case t of
  Token (IdTok) v l c -> case (contains v reserved) of
    True -> Nothing
    False -> Just v
  x -> Nothing)

upperCaseId = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (containsChar (getChar 0 v) upperCaseLetters) of
    True -> Just v
    False -> Nothing
  t -> Nothing)

notUpperCaseId = parseToken (\t -> case t of
  Token (IdTok) v i c -> case (containsChar (getChar 0 v) upperCaseLetters) of
    False -> case (contains v reserved) of
      False -> Just v
      True -> Nothing
    True -> Nothing
  t -> Nothing)

parenP = \p -> between (symP '(') p (symP ')')

varP = parseToken (\t -> case t of
  Token (IdTok) v l c -> case (contains v reserved) of
    True -> Nothing
    False -> Just (Var emptyAnn v)
  x -> Nothing)

cnumP = parseToken (\t -> case t of
  Token (NumTok) v l c -> Just (Const emptyAnn (CNum (unsafeStringToInt v)))
  x -> Nothing)

cstrP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just (Const emptyAnn (CStr v))
  x -> Nothing)
  
constP = or cstrP cnumP

simpleExprP = \s -> or varP (or constP (parenP exprP)) s

appP = \s -> apply
  (\p -> case p of Pair f xs -> foldl (\f x -> App emptyAnn f x) f xs)
  (andIndent (or varP (parenP exprP)) (many simpleExprP))
  s

lamP = \s -> apply
  (\p -> case p of Pair _ (Pair ps a) -> foldr (\a p -> Lam emptyAnn p a) a ps)
  (andIndent (symP '\\') (and (many1 notUpperCaseId) (precedes (operatorP '->') exprP)))
  s

pvarP = apply (PVar emptyAnn) notUpperCaseId

pcnumP = parseToken (\t -> case t of
  Token (NumTok) v l c -> Just (PConst emptyAnn (CNum (unsafeStringToInt v)))
  x -> Nothing)

pcstrP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just (PConst emptyAnn (CStr v))
  x -> Nothing)

strP = parseToken (\t -> case t of
  Token (StrTok) v l c -> Just v
  x -> Nothing)

pconstP = or pcnumP pcstrP

pdataP = \s -> apply
  (\p -> case p of Pair n ps -> PData emptyAnn n ps)
  (andIndent upperCaseId (many (or pvarP (or pconstP (parenP patP)))))
  s

patP = or pvarP (or pconstP pdataP)

ofP = \s -> andIndent patP (precedes (operatorP '->') exprP) s

caseP = apply
  (\p -> case p of Pair _ (Pair e ps) -> Case emptyAnn e ps)
  (andIndent (reservedP 'case') (and simpleExprP (precedes (reservedP 'of') (many1 ofP))))

defP = apply
  (\p -> case p of Pair (Pair n ps) e -> Pair n (foldr (\e p -> Lam emptyAnn p e) e ps))
  (andIndent (andIndent notUpperCaseId (many notUpperCaseId)) (precedes (operatorP '=') (\s -> exprP s)))

letDefsP = apply
  snd
  (andIndent (reservedP 'let') (many1 defP))

letInP = \s -> (precedes (reservedP 'in') exprP) s

letP = apply
  (\p -> case p of Pair ds e -> Let emptyAnn ds e)
  (and letDefsP letInP)

primaryExprP = \s -> or appP (or constP (or lamP (or caseP letP))) s

exprP = apply
  (\p -> case p of Pair e oes -> foldl (\a ob -> case ob of Pair op b -> App emptyAnn (App emptyAnn (Var emptyAnn op) a) b) e oes)
  (andIndent primaryExprP (many (and anyOpP primaryExprP)))

// --------------- types -------------------

tconstP = apply (TConst emptyAnn) upperCaseId

tvarP = apply (TVar emptyAnn) notUpperCaseId

simpleTypeP = \s -> or tconstP (or tvarP (parenP typeP)) s

tappP = apply
  (\p -> case p of Pair t ts -> foldl (\a b -> TApp emptyAnn a b) t ts)
  (andIndent simpleTypeP (many simpleTypeP))

tfunP = apply
  (\p -> case p of Pair t ts -> foldr1 (\b a -> TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b) (enqueue t ts))
  (andIndent tappP (many (precedes (operatorP '->') tappP)))

typeP = tfunP

// ------------ type classes ---------------

classP = apply
  (\r -> case r of Pair (Pair name tv) maybeDefs -> Class emptyAnn name tv (justOr emptyArray maybeDefs))
  (precedesIndent (reservedP 'class') (and (and upperCaseId notUpperCaseId) (opt (precedes (reservedP 'where') (many1 classMemberP)))))

classMemberP = andIndent notUpperCaseId (precedes (operatorP '::') typeP)

instanceP = apply
  (\r -> case r of Pair (Pair name t) maybeDefs -> Instance emptyAnn name t (justOr emptyArray maybeDefs))
  (precedesIndent (reservedP 'instance') (and (and upperCaseId simpleTypeP) (opt (precedes (reservedP 'where') (many1 defP)))))

// --------------- module ------------------

dataConP = apply
  (\p -> case p of Pair n ts -> DataCon emptyAnn n ts)
  (andIndent upperCaseId (many simpleTypeP))

dataP = apply
  (\r -> case r of Pair _ (Pair n (Pair ps cs)) -> Data emptyAnn n ps cs)
  (andIndent (reservedP 'data') (and upperCaseId (and (many notUpperCaseId) (precedes (operatorP '=') (sepBy1 dataConP (operatorP '|'))))))

importClosedP = apply
  (\p -> case p of Pair n f -> ImportClosed emptyAnn f n)
  (and nonReservedP (precedes (reservedP 'from') strP))

importNoAliasP = apply
  (\n -> Pair n n)
  nonReservedP

importAliasP = and nonReservedP (precedes (reservedP 'as') nonReservedP)

importOpenP = apply
  (\p -> case p of Pair ns f -> ImportOpen emptyAnn f ns)
  (and (between (symP '{') (sepBy1 (or importAliasP importNoAliasP) (symP ',')) (symP '}')) (precedes (reservedP 'from') strP))

importAllP = apply
  (\p -> case p of Pair n f -> ImportAll emptyAnn f)
  (and (operatorP '*') (precedes (reservedP 'from') strP))

importP = apply snd (andIndent (reservedP 'import') (or importClosedP (or importOpenP importAllP)))

moduleP = apply
  (\p -> case p of Pair is es -> case (splitFourWay es) of Pair (Pair dts dfs) (Pair cs ins) -> Module emptyAnn is dts cs ins dfs)
  (and (many importP) (many1 topLevelP))

splitFourWay e = case (splitEither e) of
  Pair a b -> Pair (splitEither a) (splitEither b)

eitherP a b = or (apply Left a) (apply Right b)
topLevelP = eitherP (eitherP dataP defP) (eitherP classP instanceP)
  
parseModule = runParser moduleP
parseImports = runParser (many importP)
parseExpr = runParser exprP
parseType = runParser typeP
