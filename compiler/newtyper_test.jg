import * from '//compiler/prelude.jg'
import {assertTrue, assertEq, runTests, Test, withMsg, changeMsg, prefixMsg, Ok, Fail} from '//compiler/test/test.jg'
import * from '//compiler/newtyper.jg'
import * from '//compiler/ast.jg'
import {printType} from '//compiler/printer.jg'
import {parseModule, parseExpr, parseType, parseScope} from '//compiler/jaguarParser.jg'
import {Success, Error} from '//compiler/parsers.jg'
import {checkTopBindings, TOk, TErr} from '//compiler/typechecker.jg'

mustParseExpr s = case (parseExpr s 'test') of
  Error e -> error e
  Success e _ -> e

mustParseModule s = case (parseModule s 'test') of
  Error e -> error e
  Success m _ -> m

mustParseScope s = let
  fixSkolems t = case t of
    TVar ann v -> TSkolem ann v
    TApp ann f a -> TApp ann (fixSkolems f) (fixSkolems a)
    TForall ann vs bs t -> TForall ann vs bs (fixSkolems t)
    _ -> t
  fix t = let
    vs = sort (setToArray $ varsInType t)
    t2 = fixSkolems t
    in case (length vs) of
      0 -> t2
      _ -> TForall emptyAnn vs [] t2
  in case (parseScope s 'test') of
    Error e -> error e
    Success bs _ -> foldl (\s (n, t) -> insert n (fix t) s) Empty bs

mustParseBindings s = case (mustParseModule s) of
  Module _ _ _ _ _ _ bs -> bs

assertTOk r = case r of
  TOk -> Ok
  TErr _ m -> Fail ('want TOk, but got TErr: ' ++ jsonStringify r)

assertTFail r = case r of
  TOk -> Fail ('want TFail, but got TOk')
  TErr _ m -> Ok

assertIOk r = case r of
  IOk _ -> Ok
  e -> Fail ('want IOk, but got IErr:\n' ++ printIErr e)

assertIFail r = case r of
  IOk _ -> Fail ('want TFail, but got TOk')
  IErr _ m -> Ok

assertIOkAnd a f = case a of
  IOk a -> f a
  e -> Fail ('want IOk, but got IErr:\n' ++ printIErr e)

typeEq a b =
  case (a, b) of
    (TVar _ v, TVar _ w) -> v == w
    (TConst _ a, TConst _ b) -> a == b
    (TSkolem _ a, TSkolem _ b) -> a == b
    (TApp _ fa xa, TApp _ fb xb) -> typeEq fa fb && typeEq xa xb
    (TForall _ vsa _ ta, TForall _ vsb _ tb) -> forallEquiv vsa ta vsb tb
    _ -> False

forallEquiv vsa a vsb b = let
  asa = setAddAll vsa Empty
  asb = setAddAll vsb Empty
  equiv a b =
    case (a, b) of
      (TVar _ v, TVar _ w) -> ret (v == w)
      (TConst _ a, TConst _ b) -> ret (a == b)
      (TSkolem _ a, TSkolem _ b) -> case (setContains a asa, setContains b asb) of
        (True, True) -> gets >>= \(ma, mb) ->
          case (lookup a ma, lookup b mb) of
            (Nothing, Nothing) -> sets (insert a b ma, insert b a mb) >> ret True
            (Just b2, Just a2) -> ret ((b == b2) && (a == a2))
            _ -> ret False
        (False, False) -> ret (a == b)
        _ -> ret False
      (TApp _ fa xa, TApp _ fb xb) -> equiv fa fb >>= \fe ->
        equiv xa xb >>= \xe ->
          ret (fe && xe)
      _ -> ret False
  in evalState (Empty, Empty) (equiv a b)

assertTypeEq want got =
  case (typeEq want got) of
    True -> Ok
    False -> Fail ('want ' ++ printType want ++ ', but got ' ++ printType got)

assertTypeMapEq want got = let
  assertEntry r k wantType =
    case r of
      Ok -> case (lookup k got) of
        Nothing -> Fail ('want key ' ++ k ++ ', but did not find it')
        Just gotType -> prefixMsg ('var ' ++ k) $ assertTypeEq wantType gotType
      f -> f
  sizeCheck = withMsg ('want map of size ' ++ intToString (size want) ++ ', but got ' ++ intToString (size got)) $ assertEq (size want) (size got)
  in foldTrie assertEntry sizeCheck want

bsToScope = foldl (\m (n, e) -> insert n (getType e) m) Empty
assertInferredTypes want got = assertIOkAnd got (\got -> assertTypeMapEq want (bsToScope got))

assertTypecheckOk scope got =
  assertIOkAnd got (\got -> assertTOk (checkTopBindings [] scope got))

tc = TConst emptyAnn
tv = TVar emptyAnn
ts = TSkolem emptyAnn
tapp = TApp emptyAnn
tforall vs = TForall emptyAnn vs []

ant t = setAnnType t emptyAnn

tests = [
    Test 'forceType (Number)' $ \_ -> let
      vars = Empty
      t = tnum

      want = tnum

      got = evalState (US vars 0) (forceType t)
      in [assertTypeEq want got],

    Test 'forceType (check shorting)' $ \_ -> let
      vars = insert 'a' (tv 'b') (insert 'b' (tv 'c') Empty)
      t = tv 'a'

      wantT = tv 'c'
      wantVars = insert 'a' (tv 'c') (insert 'b' (tv 'c') Empty)

      (US gotVars _, gotT) = runState (US vars 0) (forceType t)
      in [
        prefixMsg 'type' $ assertTypeEq wantT gotT,
        prefixMsg 'vars' $ assertTypeMapEq wantVars gotVars],

    Test 'forceType (check shorting and TApp)' $ \_ -> let
      vars = insert 'a' (tapp (tv 'b') (tv 'c')) (insert 'b' (tc 'Maybe') Empty)
      t = tv 'a'

      wantT = tapp (tv 'b') (tv 'c') // note tha b did not get forced
      wantVars = vars // unchanged

      (US gotVars _, gotT) = runState (US vars 0) (forceType t)
      in [
        prefixMsg 'type' $ assertTypeEq wantT gotT,
        prefixMsg 'vars' $ assertTypeMapEq wantVars gotVars],

    Test 'unifyType (pick tvar to keep)' $ \_ -> let
      ctx = []
      vars = Empty
      
      a = tv '$1'
      b = tv '$11'

      wantT = tv '$1'
      wantVars = insert '$11' (tv '$1') Empty

      (US gotVars _, gotT) = runState (US vars 0) (unifyType ctx a b)
      in [
        prefixMsg 'type' $ assertIOkAnd gotT (assertTypeEq wantT),
        prefixMsg 'vars' $ assertTypeMapEq wantVars gotVars],

    Test 'unifyType (Strings keep spreading)' $ \_ -> let
      ctx = []
      vars = insert 'a' (tv 'x') (insert 'b' (tv 'x') Empty)
      
      a = tfun (tv 'a') (tv 'b')
      b = tfun tstr (tv 'x')

      wantT = tfun tstr tstr
      wantVars = insert 'a' (tv 'x') (insert 'b' tstr (insert 'x' tstr Empty))
      wantA = tstr

      (US gotVars _, gotT) = runState (US vars 0) (unifyType ctx a b)
      gotA = evalState (US gotVars 0) (forceType (tv 'a'))
      in [
        prefixMsg 'type' $ assertIOkAnd gotT (assertTypeEq wantT),
        prefixMsg 'vars' $ assertTypeMapEq wantVars gotVars,
        prefixMsg 'forced a' $ assertTypeEq wantA gotA],

    Test 'unifyType (mismatch in TApp)' $ \_ -> let
      ctx = []
      vars = insert 'a' (tv 'x') (insert 'b' (tv 'x') Empty)
      
      a = tfun (tv 'a') (tv 'b')
      b = tfun tstr tnum

      got = evalState (US vars 0) (unifyType ctx a b)
      in [assertIFail got],

    Test 'generalize' $ \_ -> let
      vars = insert 'a' (tfun (tv 'b') (tv 'x')) (insert 'b' (tv 'x') Empty)
      t = tv 'a'

      wantT = tforall ['x'] (tfun (ts 'x') (ts 'x'))
      wantVars = vars

      (US gotVars _, (_, gotT)) = runState (US vars 0) (generalize t)
      in [
        prefixMsg 'type' $ assertTypeEq wantT gotT,
        prefixMsg 'vars' $ assertTypeMapEq wantVars gotVars],

    Test 'infer simple' $ \_ -> let
      ctx = []
      scope = insertAll [
        ('id', tforall ['x'] (tfun (ts 'x') (ts 'x')))
        ] Empty

      want = insertAll [
        ('x', tstr)
        ] Empty

      bs = [
        ('x', App emptyAnn (Var emptyAnn 'id') (Const emptyAnn (CStr 'pony')))
        ]
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer simple with parsed data' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        id :: a -> a
      '

      want = mustParseScope '
        x :: String
      '

      bs = mustParseBindings '
        x = id "pony"
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer fib' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        sub :: Number -> Number -> Number
        add :: Number -> Number -> Number
      '

      want = mustParseScope '
        fib :: Number -> Number
      '

      bs = mustParseBindings '
        fib n = case n of
          0 -> 1
          1 -> 1
          _ -> add (fib (sub n 1)) (fib (sub n 2))
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer fib mutually recursive' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        sub :: Number -> Number -> Number
        add :: Number -> Number -> Number
      '

      want = mustParseScope '
        fib :: Number -> Number
        fib2 :: Number -> Number
      '

      bs = mustParseBindings '
        fib n = case n of
          0 -> 1
          1 -> 1
          _ -> add (fib2 (sub n 1)) (fib (sub n 2))
        
        fib2 n = case n of
          0 -> 1
          1 -> 1
          _ -> add (fib (sub n 1)) (fib2 (sub n 2))
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'polymorphic let binding' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        Pair :: a -> b -> Pair a b
      '

      want = mustParseScope '
        x :: Pair Number String
      '

      bs = mustParseBindings '
        x = let
          id z = z
          in (id 7, id "pony")
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer array' $ \_ -> let
      ctx = []
      scope = Empty

      want = mustParseScope '
        x :: Array Number
        y :: Number
      '

      bs = mustParseBindings '
        y = 13
        x = [42, y]
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer map based on fold' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        foldl :: (b -> a -> b) -> b -> Array a -> b
        push :: a -> Array a -> Array a
      '

      want = mustParseScope '
        map :: (a -> b) -> Array a -> Array b
      '

      bs = mustParseBindings '
        map f xs = foldl (\\rs x -> push (f x) rs) [] xs
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer recursive fold impl' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        length :: Array a -> Number
        head :: Array a -> a
        tail :: Array a -> Array a
      '

      want = mustParseScope '
        foldl :: (b -> a -> b) -> b -> Array a -> b
      '

      bs = mustParseBindings '
        foldl f b xs = case (length xs) of
          0 -> b
          _ -> foldl f (f b (head xs)) (tail xs)
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got],

    Test 'infer mutually recursive fold impl' $ \_ -> let
      ctx = []
      scope = mustParseScope '
        length :: Array a -> Number
        head :: Array a -> a
        tail :: Array a -> Array a
      '

      want = mustParseScope '
        foldl :: (b -> a -> b) -> b -> Array a -> b
        foldl2 :: (b -> a -> b) -> b -> Array a -> b
      '

      bs = mustParseBindings '
        foldl f b xs = case (length xs) of
          0 -> b
          _ -> foldl2 f (f b (head xs)) (tail xs)
        foldl2 f b xs = case (length xs) of
          0 -> b
          _ -> foldl f (f b (head xs)) (tail xs)
      '
      got = inferTopBindings ctx scope bs
      in [
        prefixMsg 'types' $ assertInferredTypes want got,
        prefixMsg 'full check' $ assertTypecheckOk scope got]
  ]

main argv = runTests 'newtyper_test' tests
