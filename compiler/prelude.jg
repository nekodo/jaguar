class Functor f where
  fmap :: (a -> b) -> f a -> f b

class Applicative a where
  pure :: x -> a x
  (<*>) :: a (x -> y) -> a x -> a y

data Maybe a = Just a | Nothing

instance Functor Maybe where
  fmap f m = case m of
    Just x -> Just (f x)
    Nothing -> Nothing

instance Applicative Maybe where
  pure x = Just x
  (<*>) f x = case f of
    Nothing -> Nothing
    Just f -> case x of
      Nothing -> Nothing
      Just x -> Just (f x)

maybe = \a b m -> case m of
  Just x -> a x
  Nothing -> b

justOr d m = case m of
  Just x -> x
  Nothing -> d

data Pair a b = Pair a b

fst = \p -> case p of Pair a b -> a
snd = \p -> case p of Pair a b -> b

data Either a b = Left a | Right b

instance Functor (Either a) where
  fmap f e = case e of
    Left l -> Left l
    Right r -> Right (f r)

either = \f g e -> case e of
  Left a -> f a
  Right b -> g b

// Array (Either a b) -> Pair (Array a) (Array b)
splitEither = \a -> Pair
  (map (\e -> case e of Left a -> a) (filter (either (\_ -> True) (\_ -> False)) a))
  (map (\e -> case e of Right b -> b) (filter (either (\_ -> False) (\_ -> True)) a))

not = \b -> case b of
  True -> False
  False -> True

// (a -> Either a b) -> a -> b
loop f start = let
  // Pair a (Maybe b) -> Bool
  shouldStop x = case x of
    Pair _ (Nothing) -> False
    _ -> True
  // Pair a (Maybe b) -> Pair a (Maybe c)
  // f :: a -> Either a c
  next xr = case xr of
    Pair x _ -> case (f x) of
      Left x2 -> Pair x2 Nothing
      Right r -> Pair x (Just r)
  sp = Pair start Nothing
  result = iterate sp shouldStop next
  in case (snd result) of
    Just r -> r    

contains x xs = let
  f i = case (i < length xs) of
    False -> Right False
    True -> case (x == getIx i xs) of
      True -> Right True
      False -> Left (i + 1)
  in loop f 0
  
find predicate xs = let
  f i = case (i < length xs) of
    False -> Right Nothing
    True -> case (predicate (getIx i xs)) of
      True -> Right (Just (getIx i xs))
      False -> Left (i + 1)
  in loop f 0

containsChar x xs = let 
  f i = case (i < length xs) of
    False -> False
    True -> case (getChar i xs == x) of
      True -> True
      False -> f (i + 1)
  in f 0

exists f xs = foldl (\r x -> f x || r) False xs

join = \xs s -> case (length xs) of
  0 -> ''
  n -> foldl1 (\a b -> a ++ s ++ b) xs

zipWithIndex2 = \n xs -> case (length xs) of
  0 -> emptyArray
  x -> enqueue (Pair n (head xs)) (zipWithIndex2 (n + 1) (tail xs))

zipWithIndex = zipWithIndex2 0

zip xs ys = case ((length xs == 0) || (length ys == 0)) of
  True -> emptyArray
  False -> enqueue (Pair (head xs) (head ys)) (zip (tail xs) (tail ys))

concatMap = \f a -> foldl concat emptyArray (map f a)

head = getIx 0
tail = slice 1
last l = getIx (length l - 1) l
init l = slice2 0 (length l - 1) l

arr1 = \x -> push x emptyArray
arr2 = \x y -> push y (arr1 x)
arr3 = \x y z -> push z (arr2 x y)
arr4 = \x y z xx -> push xx (arr3 x y z)

mergeSet = \xs ys -> case (length xs) of
  0 -> ys
  lx -> case (length ys) of
    0 -> xs
    ly -> case (head xs < head ys) of
      True -> enqueue (head xs) (mergeSet (tail xs) ys)
      False -> case (head xs == head ys) of
        True -> enqueue(head xs) (mergeSet (tail xs) (tail ys))
        False -> enqueue (head ys) (mergeSet xs (tail ys))

uniq xs = case (length xs < 2) of
  True -> xs
  False -> case (getIx 0 xs == getIx 1 xs) of
    False -> enqueue (head xs) (uniq (tail xs))
    True -> uniq (tail xs)

reverse = foldl (\xs x -> enqueue x xs) emptyArray

toRecord = foldl (\r p -> case p of Pair k v -> set k v r) empty

strToArray s = let
  f p = case p of
    Pair i r -> case (i < length s) of
      False -> Right r
      True -> Left (Pair (i + 1) (push (getChar i s) r))
  in loop f (Pair 0 emptyArray)
