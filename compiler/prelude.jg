data Unit = Unit
($) f a = f a

class Eq a where
  (==) :: a -> a -> Bool

(/=) a b = not (a == b)

instance Eq Number where
  (==) = jsEq

instance Eq String where
  (==) = jsEq

class Ord a where
  (<) :: a -> a -> Bool

(>) a b = b < a
(<=) a b = not (b < a)
(>=) a b = not (a < b)

instance Ord Number where
  (<) = jsLt

instance Ord String where
  (<) = jsLt

class Functor f where
  fmap :: (a -> b) -> f a -> f b

class Applicative a where
  pure :: x -> a x
  (<*>) :: a (x -> y) -> a x -> a y

class Alternative f where
  zero :: f a
  (<|>) :: f a -> f a -> f a

class Monad m where
  ret :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b

(>>) a b = a >>= \_ -> b

data Maybe a = Just a | Nothing

instance Functor Maybe where
  fmap f m = case m of
    Just x -> Just (f x)
    Nothing -> Nothing

instance Applicative Maybe where
  pure x = Just x
  (<*>) f x = case f of
    Nothing -> Nothing
    Just f -> fmap f x

instance Alternative Maybe where
  zero = Nothing
  (<|>) a b = case a of
    Nothing -> b
    _ -> a

instance Monad Maybe where
  ret = pure
  (>>=) a f = case a of
    Nothing -> Nothing
    Just a -> f a

maybe = \a b m -> case m of
  Just x -> a x
  Nothing -> b

justOr d m = case m of
  Just x -> x
  Nothing -> d

fromJust m = case m of
  Just x -> x
  Nothing -> error 'expected Just but got Nothing'

isJust m = case m of
  Just _ -> True
  Nothing -> False

data Pair a b = Pair a b

fst = \p -> case p of Pair a b -> a
snd = \p -> case p of Pair a b -> b

data Either a b = Left a | Right b

instance Functor (Either a) where
  fmap f e = case e of
    Left l -> Left l
    Right r -> Right (f r)

either = \f g e -> case e of
  Left a -> f a
  Right b -> g b

// Array (Either a b) -> Pair (Array a) (Array b)
splitEither = \a -> Pair
  (map (\e -> case e of Left a -> a) (filter (either (\_ -> True) (\_ -> False)) a))
  (map (\e -> case e of Right b -> b) (filter (either (\_ -> False) (\_ -> True)) a))

not = \b -> case b of
  True -> False
  False -> True

// (a -> Either a b) -> a -> b
loop f start = let
  // Pair a (Maybe b) -> Bool
  shouldStop x = case x of
    Pair _ (Nothing) -> False
    _ -> True
  // Pair a (Maybe b) -> Pair a (Maybe c)
  // f :: a -> Either a c
  next xr = case xr of
    Pair x _ -> case (f x) of
      Left x2 -> Pair x2 Nothing
      Right r -> Pair x (Just r)
  sp = Pair start Nothing
  result = iterate sp shouldStop next
  in case (snd result) of
    Just r -> r    

contains x xs = let
  f i = case (i < length xs) of
    False -> Right False
    True -> case (x == getIx i xs) of
      True -> Right True
      False -> Left (i + 1)
  in loop f 0
  
find predicate xs = let
  f i = case (i < length xs) of
    False -> Right Nothing
    True -> case (predicate (getIx i xs)) of
      True -> Right (Just (getIx i xs))
      False -> Left (i + 1)
  in loop f 0

mapIx f ix xs = setIx ix (f (getIx ix xs)) xs

containsChar x xs = let 
  f i = case (i < length xs) of
    False -> False
    True -> case (getChar i xs == x) of
      True -> True
      False -> f (i + 1)
  in f 0

exists f xs = foldl (\r x -> f x || r) False xs
all f xs = foldl (\r x -> f x && r) True xs

join = \xs s -> case (length xs) of
  0 -> ''
  n -> foldl1 (\a b -> a ++ s ++ b) xs

zipWithIndex2 = \n xs -> case (length xs) of
  0 -> []
  x -> enqueue (Pair n (head xs)) (zipWithIndex2 (n + 1) (tail xs))

zipWithIndex = zipWithIndex2 0

zip xs ys = case ((length xs == 0) || (length ys == 0)) of
  True -> []
  False -> enqueue (Pair (head xs) (head ys)) (zip (tail xs) (tail ys))

concatMap = \f a -> foldl concat [] (map f a)

mapJust f xs = let
  g r x = case (f x) of
    Nothing -> r
    Just x -> push x r
  in foldl g [] xs

head = getIx 0
tail = slice 1
last l = getIx (length l - 1) l
init l = slice2 0 (length l - 1) l

mergeSet = \xs ys -> case (length xs) of
  0 -> ys
  lx -> case (length ys) of
    0 -> xs
    ly -> case (head xs < head ys) of
      True -> enqueue (head xs) (mergeSet (tail xs) ys)
      False -> case (head xs == head ys) of
        True -> enqueue(head xs) (mergeSet (tail xs) (tail ys))
        False -> enqueue (head ys) (mergeSet xs (tail ys))

uniq xs = case (length xs < 2) of
  True -> xs
  False -> case (getIx 0 xs == getIx 1 xs) of
    False -> enqueue (head xs) (uniq (tail xs))
    True -> uniq (tail xs)

reverse = foldl (\xs x -> enqueue x xs) []

toRecord = foldl (\r p -> case p of Pair k v -> set k v r) empty

strToArray s = let
  f p = case p of
    Pair i r -> case (i < length s) of
      False -> Right r
      True -> Left (Pair (i + 1) (push (getChar i s) r))
  in loop f (Pair 0 [])

foldM f r xs = foldl (\r x -> r >>= \r -> f r x) (ret r) xs

mapM f xs = foldM (\xs x -> f x >>= \x -> ret (push x xs)) [] xs
forM xs f = mapM f xs

data State s a = State (s -> Pair s a)

instance Functor (State s) where
  fmap f s = case s of State sf -> State (\s -> case (sf s) of Pair s a -> Pair s (f a))

instance Applicative (State s) where
  pure a = State (\s -> Pair s a)
  (<*>) f a = case f of State sf -> case a of State sa -> State
    (\s -> case (sf s) of Pair s f -> case (sa s) of Pair s a -> Pair s (f a))

instance Monad (State s) where
  ret = pure
  (>>=) a f = case a of State sa -> State
    (\s -> case (sa s) of Pair s a -> case (f a) of State sb -> sb s)

gets = State (\s -> Pair s s)
sets s = State (\_ -> Pair s Unit)

runState s m = case m of State f -> f s
evalState s m = snd (runState s m)


class Hashable a where
  hashCode :: a -> Number

instance Hashable Number where
  hashCode n = n

instance Hashable String where
  hashCode s = strHashCode s

data Map k v =
  Empty
  | Leaf Number k v
  | Collision Number (Array (Pair k v))
  | BitmapIndexed Number Number (Array (Map k v))

nodeMask t = case t of
  Empty -> 0
  Leaf m _ _ -> m
  Collision m _ -> m
  BitmapIndexed m _ _ -> m

popCount n = let
  n2 = n - (bitAnd (bitShiftRight n 1) 1431655765)
  n3 = (bitAnd n2 858993459) + (bitAnd (bitShiftRight n2 2) 858993459)
  n4 = bitAnd (n3 + bitShiftRight n3 4) 252645135
  n5 = n4 + bitShiftRight n4 8
  n6 = n5 + bitShiftRight n5 16
  in bitAnd n6 127

hamtMask depth hash = let
  // Just the 5 bits of the hash for this depth (value 0-31).
  h = bitAnd (bitShiftRight hash (depth * 5)) 31
  // The mask for the h-th bit (from the right).
  in bitShiftLeft 1 h

hamtIndex bitmap mask = popCount (bitAnd bitmap (mask - 1))

lookup k t = let
  hash = hashCode k
  f depth t = case t of
    Empty -> Nothing
    Leaf _ k2 v -> case (k == k2) of
      False -> Nothing
      True -> Just v
    Collision _ entries -> fmap snd $ find (\e -> fst e == k) entries
    BitmapIndexed _ bitmap entries -> let
      m = hamtMask depth hash
      in case (bitAnd m bitmap) of
        0 -> Nothing
        _ -> f (depth + 1) (getIx (hamtIndex bitmap m) entries) 
  in f 0 t

insert k v t = let
  hash = hashCode k
  f depth t = case t of
    Empty -> Leaf 0 k v
    Collision mp entries -> Collision mp (push (Pair k v) (filter (\e -> fst e /= k) entries))
    Leaf mp k2 v2 -> case (k == k2) of
      True -> Leaf mp k v
      False -> case depth of
        7 -> Collision mp [Pair k2 v2, Pair k v]
        _ -> let
          m = hamtMask depth (hashCode k2)
          in f depth (BitmapIndexed mp m [Leaf m k2 v2])
    BitmapIndexed mp bitmap entries -> let
      m = hamtMask depth hash
      bitmap2 = bitOr m bitmap
      ix = hamtIndex bitmap2 m
      in case (bitAnd m bitmap) of
        0 -> BitmapIndexed mp bitmap2 (arrIns ix (Leaf m k v) entries)
        _ -> BitmapIndexed mp bitmap2 (mapIx (f (depth + 1)) ix entries)
  in f 0 t

updateOrSet k f d m = case (lookup k m) of
  Nothing -> insert k d m
  Just x -> insert k (f x) m

remove k t = let
  hash = hashCode k
  f depth t = case t of
    Empty -> Empty
    Leaf _ k2 _ -> case (k2 == k) of
      True -> Empty
      False -> t
    Collision mp entries -> let
      entries2 = filter (\e -> fst e /= k) entries
      in case (length entries2) of
        0 -> Empty
        1 -> Leaf mp (fst (getIx 0 entries2)) (snd (getIx 0 entries2))
        _ -> Collision mp entries2
    BitmapIndexed mp bitmap entries -> let
      m = hamtMask depth hash
      ix = hamtIndex bitmap m
      in case (bitAnd m bitmap) of
        0 -> t
        _ -> case (f (depth + 1) (getIx ix entries)) of
          Empty -> let
            bitmap2 = bitAnd (bitNot m) bitmap
            in case (length entries) of
              1 -> Empty
              2 -> getIx (bitAnd 1 (bitNot ix)) entries
              _ -> BitmapIndexed mp bitmap2 (arrDel ix 1 entries)
          e -> BitmapIndexed mp bitmap (setIx ix e entries)
  in f 0 t

nextSetBitMask m n = case (bitAnd m n) of
  0 -> nextSetBitMask (bitShiftLeft m 1) n
  _ -> m

filterTrie f t = case t of
  Empty -> Empty
  Leaf _ k v -> case (f k v) of
    False -> Empty
    True -> t
  Collision mp entries -> let
    entries2 = filter (\e -> f (fst e) (snd e)) entries
    in case (length entries2) of
      0 -> Empty
      1 -> Leaf mp (fst (getIx 0 entries2)) (snd (getIx 0 entries2))
      _ -> Collision mp entries2
  BitmapIndexed mp bitmap entries -> let
    pred e = not (isEmpty e)
    entries2 = filter pred (map (filterTrie f) entries)
    bitmap2 = foldl (\r e -> bitOr r (nodeMask e)) 0 entries2
    in case bitmap2 of
      0 -> Empty
      _ -> BitmapIndexed mp bitmap2 entries2

foldTrie f a t = case t of
  Empty -> a
  Leaf _ k v -> f a k v
  Collision _ entries -> foldl (\a e -> f a (fst e) (snd e)) a entries
  BitmapIndexed _ _ entries -> foldl (foldTrie f) a entries

mapTrie f t = case t of
  Empty -> Empty
  Leaf mp k v -> Leaf mp k (f k v)
  Collision mp entries -> Collision mp $ map (\e -> Pair (fst e) $ f (fst e) (snd e)) entries
  BitmapIndexed mp bitmap entries -> BitmapIndexed mp bitmap $ map (mapTrie f) entries

size t = case t of
  Empty -> 0
  Leaf _ _ _ -> 1
  Collision _ entries -> length entries
  BitmapIndexed _ _ entries -> foldl (+) 0 (map size entries)

isEmpty t = case t of
  Empty -> True
  _ -> False

mergeTrie a b = foldTrie (\a k v -> insert k v a) a b

trieKeys m = foldTrie (\ks k _ -> push k ks) [] m

emptySet = Empty
setAdd a s = insert a Unit s
setAddAll vs s = foldl (\s v -> setAdd v s) s vs
setRemove = remove
setContains a s = isJust (lookup a s)
setUnion = mergeTrie
setToArray = foldTrie (\vs v _ -> push v vs) []
setDiff a b = foldTrie (\r k _ -> remove k r) a b
setIntersection a b = let
  f r k _ = case (setContains k a) of
    False -> r
    True -> setAdd k r
  in foldTrie f emptySet b

debug2 p x = snd (Pair (debug p) x)

data Identity a = Identity a

instance Functor Identity where
  fmap f i = case i of
    Identity a -> Identity (f a)

instance Applicative Identity where
  pure x = Identity x
  (<*>) f x = case f of
    Identity f -> fmap f x

instance Monad Identity where
  ret = pure
  (>>=) a f = case a of
    Identity a -> f a

(>=>) a b x = a x >>= b

mapFst f p = case p of
  Pair a b -> Pair (f a) b

mapSnd f p = case p of
  Pair a b -> Pair a (f b)

assert s b = case b of
  True -> True
  False -> error s
