data Unit = Unit
($) f a = f a

class Functor f where
  fmap :: (a -> b) -> f a -> f b

class Applicative a where
  pure :: x -> a x
  (<*>) :: a (x -> y) -> a x -> a y

class Alternative f where
  zero :: f a
  (<|>) :: f a -> f a -> f a

class Monad m where
  ret :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b

(>>) a b = a >>= \_ -> b

data Maybe a = Just a | Nothing

instance Functor Maybe where
  fmap f m = case m of
    Just x -> Just (f x)
    Nothing -> Nothing

instance Applicative Maybe where
  pure x = Just x
  (<*>) f x = case f of
    Nothing -> Nothing
    Just f -> fmap f x

instance Alternative Maybe where
  zero = Nothing
  (<|>) a b = case a of
    Nothing -> b
    _ -> a

instance Monad Maybe where
  ret = pure
  (>>=) a f = case a of
    Nothing -> Nothing
    Just a -> f a

maybe = \a b m -> case m of
  Just x -> a x
  Nothing -> b

justOr d m = case m of
  Just x -> x
  Nothing -> d

data Pair a b = Pair a b

fst = \p -> case p of Pair a b -> a
snd = \p -> case p of Pair a b -> b

data Either a b = Left a | Right b

instance Functor (Either a) where
  fmap f e = case e of
    Left l -> Left l
    Right r -> Right (f r)

either = \f g e -> case e of
  Left a -> f a
  Right b -> g b

// Array (Either a b) -> Pair (Array a) (Array b)
splitEither = \a -> Pair
  (map (\e -> case e of Left a -> a) (filter (either (\_ -> True) (\_ -> False)) a))
  (map (\e -> case e of Right b -> b) (filter (either (\_ -> False) (\_ -> True)) a))

not = \b -> case b of
  True -> False
  False -> True

// (a -> Either a b) -> a -> b
loop f start = let
  // Pair a (Maybe b) -> Bool
  shouldStop x = case x of
    Pair _ (Nothing) -> False
    _ -> True
  // Pair a (Maybe b) -> Pair a (Maybe c)
  // f :: a -> Either a c
  next xr = case xr of
    Pair x _ -> case (f x) of
      Left x2 -> Pair x2 Nothing
      Right r -> Pair x (Just r)
  sp = Pair start Nothing
  result = iterate sp shouldStop next
  in case (snd result) of
    Just r -> r    

contains x xs = let
  f i = case (i < length xs) of
    False -> Right False
    True -> case (x == getIx i xs) of
      True -> Right True
      False -> Left (i + 1)
  in loop f 0
  
find predicate xs = let
  f i = case (i < length xs) of
    False -> Right Nothing
    True -> case (predicate (getIx i xs)) of
      True -> Right (Just (getIx i xs))
      False -> Left (i + 1)
  in loop f 0

mapIx f ix xs = setIx ix (f (getIx ix xs)) xs

containsChar x xs = let 
  f i = case (i < length xs) of
    False -> False
    True -> case (getChar i xs == x) of
      True -> True
      False -> f (i + 1)
  in f 0

exists f xs = foldl (\r x -> f x || r) False xs

join = \xs s -> case (length xs) of
  0 -> ''
  n -> foldl1 (\a b -> a ++ s ++ b) xs

zipWithIndex2 = \n xs -> case (length xs) of
  0 -> emptyArray
  x -> enqueue (Pair n (head xs)) (zipWithIndex2 (n + 1) (tail xs))

zipWithIndex = zipWithIndex2 0

zip xs ys = case ((length xs == 0) || (length ys == 0)) of
  True -> emptyArray
  False -> enqueue (Pair (head xs) (head ys)) (zip (tail xs) (tail ys))

concatMap = \f a -> foldl concat emptyArray (map f a)

head = getIx 0
tail = slice 1
last l = getIx (length l - 1) l
init l = slice2 0 (length l - 1) l

arr1 = \x -> push x emptyArray
arr2 = \x y -> push y (arr1 x)
arr3 = \x y z -> push z (arr2 x y)
arr4 = \x y z xx -> push xx (arr3 x y z)

mergeSet = \xs ys -> case (length xs) of
  0 -> ys
  lx -> case (length ys) of
    0 -> xs
    ly -> case (head xs < head ys) of
      True -> enqueue (head xs) (mergeSet (tail xs) ys)
      False -> case (head xs == head ys) of
        True -> enqueue(head xs) (mergeSet (tail xs) (tail ys))
        False -> enqueue (head ys) (mergeSet xs (tail ys))

uniq xs = case (length xs < 2) of
  True -> xs
  False -> case (getIx 0 xs == getIx 1 xs) of
    False -> enqueue (head xs) (uniq (tail xs))
    True -> uniq (tail xs)

reverse = foldl (\xs x -> enqueue x xs) emptyArray

toRecord = foldl (\r p -> case p of Pair k v -> set k v r) empty

strToArray s = let
  f p = case p of
    Pair i r -> case (i < length s) of
      False -> Right r
      True -> Left (Pair (i + 1) (push (getChar i s) r))
  in loop f (Pair 0 emptyArray)

foldM f r xs = foldl (\r x -> r >>= \r -> f r x) (ret r) xs

mapM f xs = foldM (\xs x -> f x >>= \x -> ret (push x xs)) emptyArray xs
forM xs f = mapM f xs

data State s a = State (s -> Pair s a)

instance Functor (State s) where
  fmap f s = case s of State sf -> State (\s -> case (sf s) of Pair s a -> Pair s (f a))

instance Applicative (State s) where
  pure a = State (\s -> Pair s a)
  (<*>) f a = case f of State sf -> case a of State sa -> State
    (\s -> case (sf s) of Pair s f -> case (sa s) of Pair s a -> Pair s (f a))

instance Monad (State s) where
  ret = pure
  (>>=) a f = case a of State sa -> State
    (\s -> case (sa s) of Pair s a -> case (f a) of State sb -> sb s)

gets = State (\s -> Pair s s)
sets s = State (\_ -> Pair s Unit)

runState s m = case m of State f -> f s
evalState s m = snd (runState s m)


class Hashable a where
  hashCode :: a -> Number

instance Hashable Number where
  hashCode n = n

instance Hashable String where
  hashCode s = strHashCode s

data HAMT k v =
  Empty
  | Leaf k v
  | Collision (Array (Pair k v))
  | BitmapIndexed Number (Array (HAMT k v))

popCount n = let
  n2 = n - (bitAnd (bitShiftRight n 1) 1431655765)
  n3 = (bitAnd n2 858993459) + (bitAnd (bitShiftRight n2 2) 858993459)
  n4 = bitAnd (n3 + bitShiftRight n3 4) 252645135
  n5 = n4 + bitShiftRight n4 8
  n6 = n5 + bitShiftRight n5 16
  in bitAnd n6 127

hamtMask depth hash = let
  // Just the 5 bits of the hash for this depth (value 0-31).
  h = bitAnd (bitShiftRight hash (depth * 5)) 31
  // The mask for the h-th bit (from the right).
  in bitShiftLeft 1 h

hamtIndex bitmap mask = popCount (bitAnd bitmap (mask - 1))

lookup k t = let
  hash = hashCode k
  f depth t = case t of
    Empty -> Nothing
    Leaf k2 v -> case (k == k2) of
      False -> Nothing
      True -> Just v
    Collision entries -> fmap snd $ find (\e -> fst e == k) entries
    BitmapIndexed bitmap entries -> let
      m = hamtMask depth hash
      in case (bitAnd m bitmap) of
        0 -> Nothing
        _ -> f (depth + 1) (getIx (hamtIndex bitmap m) entries) 
  in f 0 t

insert k v t = let
  hash = hashCode k
  f depth t = case t of
    Empty -> Leaf k v
    Collision entries -> Collision (push (Pair k v) (filter (\e -> fst e /= k) entries))
    Leaf k2 v2 -> case (k == k2) of
      True -> Leaf k v
      False -> case depth of
        7 -> Collision (arr2 (Pair k2 v2) (Pair k v))
        _ -> f depth (BitmapIndexed (hamtMask depth (hashCode k2)) (arr1 t))
    BitmapIndexed bitmap entries -> let
      m = hamtMask depth hash
      bitmap2 = bitOr m bitmap
      ix = hamtIndex bitmap2 m
      in case (bitAnd m bitmap) of
        0 -> BitmapIndexed bitmap2 (splice ix 0 (arr1 (Leaf k v)) entries)
        _ -> BitmapIndexed bitmap2 (mapIx (f (depth + 1)) ix entries)
  in f 0 t

remove k t = let
  hash = hashCode k
  f depth t = case t of
    Empty -> Empty
    Leaf k2 _ -> case (k2 == k) of
      True -> Empty
      False -> t
    Collision entries -> let
      entries2 = filter (\e -> fst e /= k) entries
      in case (length entries2) of
        0 -> Empty
        1 -> Leaf (fst (getIx 0 entries2)) (snd (getIx 0 entries2))
        _ -> Collision entries2
    BitmapIndexed bitmap entries -> let
      m = hamtMask depth hash
      ix = hamtIndex bitmap m
      in case (bitAnd m bitmap) of
        0 -> t
        _ -> case (f (depth + 1) (getIx ix entries)) of
          Empty -> let
            bitmap2 = bitAnd (bitNot m) bitmap
            in case bitmap2 of
              0 -> Empty
              _ -> BitmapIndexed bitmap2 (splice ix 1 emptyArray entries)
          e -> BitmapIndexed bitmap (setIx ix e entries)
  in f 0 t

foldTrie f a t = case t of
  Empty -> a
  Leaf k v -> f a k v
  Collision entries -> foldl (\a e -> f a (fst e) (snd e)) a entries
  BitmapIndexed _ entries -> foldl (foldTrie f) a entries

mapTrie f t = case t of
  Empty -> Empty
  Leaf k v -> Leaf k (f k v)
  Collision entries -> Collision $ map (\e -> Pair (fst e) $ f (fst e) (snd e)) entries
  BitmapIndexed bitmap entries -> BitmapIndexed bitmap $ map (mapTrie f) entries

size t = case t of
  Empty -> 0
  Leaf _ _ -> 1
  Collision entries -> length entries
  BitmapIndexed _ entries -> foldl (+) 0 (map size entries)

isEmpty t = case t of
  Empty -> True
  _ -> False

mergeTrie a b = foldTrie (\a k v -> insert k v a) a b

emptySet = Empty
setAdd a s = insert a Unit s
setAddAll vs s = foldl (\s v -> setAdd v s) s vs
setRemove = remove
setContains a s = case (lookup a s) of
  Just _ -> True
  Nothing -> False
setUnion = mergeTrie
setToArray = foldTrie (\vs v _ -> push v vs) emptyArray
setDiff a b = foldTrie (\a v _ -> setRemove v a) a b
setIntersection a b = let
  f r v _ = case (setContains v b) of
    False -> r
    True -> setAdd v r
  in foldTrie f emptySet a
