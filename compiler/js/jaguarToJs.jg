import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import * from '//compiler/js/ast.jg'

binOp2 op a b = rewriteExpr a >>= \a -> rewriteExpr b >>= \b -> ret (JSBinOp op a b)

data RewriteState = RewriteState
  (Map String (Maybe Number))   // Constructors of single-con data types
  (Map String JSExpr) // Values to inline (used in case compilation)
  (Array JSStmt)      // Preceding statements for this scope
  Number              // Unique ids

addStmt stmt = gets >>= \s -> case s of
  RewriteState cons rep stmts i -> sets (RewriteState cons rep (push stmt stmts) i)

addConst n e = addStmt (JSConst (opName n) e)

newPhi = gets >>= \s -> case s of
  RewriteState cons rep stmts i -> sets (RewriteState cons rep stmts (i + 1)) >> ret ('$phi$' ++ intToString i)

rewriteExprToStmts w e = gets >>= \s -> case s of
  RewriteState cons rep stmts i -> sets (RewriteState cons rep [] i) >>
    rewriteExpr e >>= \e -> gets >>= \s -> case s of
      RewriteState cons rep2 stmts2 i2 -> sets (RewriteState cons rep2 stmts i2) >> ret (push (w e) stmts2)

withRep rep m = gets >>= \s -> case s of
  RewriteState cons oldRep stmts i -> sets (RewriteState cons (mergeTrie oldRep rep) stmts i) >>
    m >>= \r -> gets >>= \s -> case s of
      RewriteState cons _ stmts2 i2 -> sets (RewriteState cons oldRep stmts2 i2) >> ret r

getRep n = gets >>= \s -> case s of
  RewriteState _ rep _ _ -> ret (lookup n rep)

getCons = gets >>= \s -> case s of
  RewriteState cons _ _ _ -> ret cons

rewriteExpr e = case e of
  Var _ 'True' -> ret (JSBool True)
  Var _ 'False' -> ret (JSBool False)
  Var _ v -> getRep (opName v) >>= \r -> case r of
    Nothing -> ret (JSRef (opName v))
    Just e -> ret e
  Const _ (CNum n) -> ret (JSNum n)
  Const _ (CStr s) -> ret (JSString s)
  App _ (App _ (Var _ '+') a) b -> binOp2 '+' a b
  App _ (App _ (Var _ '-') a) b -> binOp2 '-' a b
  App _ (App _ (Var _ '*') a) b -> binOp2 '*' a b
  App _ (App _ (Var _ '++') a) b -> binOp2 '+' a b
  App _ (App _ (Var _ '&&') a) b -> binOp2 '&&' a b
  App _ (App _ (Var _ '||') a) b -> binOp2 '||' a b
  App _ (App _ (Var _ 'jsLt') a) b -> binOp2 '<' a b
  App _ (App _ (Var _ 'jsEq') a) b -> binOp2 '===' a b
  App _ (App _ (Var _ 'bitAnd') a) b -> binOp2 '&' a b
  App _ (App _ (Var _ 'bitOr') a) b -> binOp2 '|' a b
  App _ (App _ (Var _ 'bitShiftLeft') a) b -> binOp2 '<<' a b
  App _ (App _ (Var _ 'bitShiftRight') a) b -> binOp2 '>>>' a b
  App _ f a -> rewriteExpr f >>= \f -> 
    rewriteExpr a >>= \a -> ret (JSCall f [a])
  Lam _ p e -> rewriteExprToStmts JSReturn e >>= \stmts -> ret (JSFun [p] stmts)
  Case _ e ps -> newPhi >>= \phiOut ->
    addStmt (JSLet phiOut Nothing) >> rewriteExpr e >>= \e -> (case e of
      JSRef _ -> ret e
      JSIndex _ _ -> ret e
      _ -> newPhi >>= \p -> addConst p e >> ret (JSRef p)) >>= \phiIn ->
        foldM (assemblePatternMatch2 phiIn phiOut) [JSExpr (JSCall (JSRef 'error') [JSString 'pattern match fail', phiIn])] (reverse ps) >>=
          mapM addStmt >> ret (JSRef phiOut)
  Let _ ds e->
    mapM (\d -> case d of Pair n e -> rewriteExpr e >>= addConst n) ds >> rewriteExpr e
  New _ '@closure' xs -> case (length xs) of
    2 -> case (getIx 0 xs) of
      Const _ (CNum n) -> mkClosure n (getIx 1 xs)
    _ -> error 'invalid @closure'
  New _ '@bind' xs -> case (last xs) of
    Var _ f -> mkBind (init xs) f
  New _ 'Array' es -> mapM rewriteExpr es >>= \es -> ret (JSArray es)
  New _ tag es -> mapM rewriteExpr es >>= \es -> getCons >>= \cons -> case (lookup tag cons) of
    Nothing -> error ('unrecognized tag in New: ' ++ tag)
    Just (Nothing) -> ret (JSObject (zip (dataConFieldIds es) es))
    Just (Just tag) -> ret (JSObject (push (Pair '$tag' (JSNum tag)) (zip (dataConFieldIds es) es)))

mkClosure n e = let
  gather n e = case e of
    Lam _ p e -> case n of
      0 -> ([p], e)
      _ -> case (gather (n - 1) e) of
        (ps, e) -> (enqueue p ps, e)
  in case (gather n e) of
    (ps, e) -> rewriteExprToStmts JSReturn e >>= \stmts -> ret (JSFun ps stmts)

mkBind args f = mapM rewriteExpr args >>= \args ->
  ret (JSCall (JSIndex (JSRef f) (JSString 'bind')) (enqueue JSNull args))

assemblePatternMatch2 phiIn phiOut alts p = getCons >>= \cons -> case p of
  Pair pat e -> case (processPattern cons phiIn pat) of
    Pair f (Pair ns vs) -> let
      rep = foldl (\r p -> insert (fst p) (snd p) r) Empty (zip ns vs)
      out stmts = case f of
        JSBool (True) -> ret stmts
        _ -> ret [JSIf f stmts alts]
      in withRep rep (rewriteExprToStmts (JSAssign (JSRef phiOut)) e) >>= out

checkUndefined label expr =
  JSTernary (JSBinOp '===' expr JSUndefined) (JSCall (JSRef 'error') [JSString label]) expr

combineChecks a b = case a of
  JSBool (True) -> b
  _ -> case b of
    JSBool (True) -> a
    _ -> JSBinOp '&&' a b

processPattern cons pm p = case p of
  PVar _ '_' -> Pair (JSBool True) (Pair [] [])
  PVar _ v -> Pair (JSBool True) (Pair [opName v] [pm])
  PConst _ (CNum n) -> Pair
    (JSBinOp '==' (JSNum n) pm)
    (Pair [] [])
  PConst _ (CStr s) -> Pair
    (JSBinOp '==' (JSString s) pm)
    (Pair [] [])
  PData _ 'True' ps -> Pair pm (Pair [] [])
  PData _ 'False' ps -> Pair (JSUnOp '!' pm) (Pair [] [])
  PData _ t ps ->let
    tagCheck = case (lookup t cons) of
      Just (Nothing) -> JSBool True
      Just (Just tag) -> JSBinOp '==' (JSIndex pm (JSString '$tag')) (JSNum tag)
      _ -> error ('unknown data type in code gen: ' ++ t)
    in foldl
      (\a b -> case a of
        Pair fa (Pair na va) -> case b of
          Pair fb (Pair nb vb) ->
            Pair (combineChecks fa fb) (Pair (concat na nb) (concat va vb)))
      (Pair tagCheck (Pair [] []))
      (map
        (\p -> case p of
          Pair n pat ->
            processPattern cons (JSIndex pm (JSString ('$' ++ intToString n))) pat)
        (zipWithIndex ps))
  z -> error 'failure to match pattern during processing'

requireExpr = \f -> JSCall (JSRef '_require') [JSString f]

buildImports = \f ns ->
  map (\n -> case n of Pair n a -> JSConst (opName a) (JSIndex (requireExpr f) (JSString (opName n)))) ns

importToJs i = case i of
  ImportOpen _ f ns -> buildImports f ns

dataConFieldIds = \ts ->
  map (\p -> '$' ++ intToString (fst p)) (zipWithIndex ts)

exportObject bs = let
  f b = case b of
    Pair n e -> case (getAnn 'export' (annOf e)) of
      Nothing -> Nothing
      Just (AnnExport en) -> Just (Pair (opName en) (JSRef (opName n)))
  in JSObject (mapJust f bs)

moduleToJs m = case m of
  Module _ _ is _ _ _ vs -> let
    imports = concatMap importToJs is
    gatherCons m d = case d of
      Pair n e -> case (getAnn 'data' (annOf e)) of
        Nothing -> m
        Just (AnnData tag) -> insert n tag m
    cons = foldl gatherCons Empty vs
    vs2 = let
      f p = case p of
        Pair n e -> not (isJust (getAnn 'dead' (annOf e)))
      in filter f vs
    defs = foldl1 concat $ evalState (RewriteState cons Empty [] 0) (mapM (\v -> case v of Pair n e -> rewriteExprToStmts (JSConst (opName n)) e) vs2)
    exportDef = JSConst 'exports' (exportObject vs2)
    in optStmts (push exportDef (concat imports defs))

opName = \op -> case op of
  '+' -> '$add'
  '-' -> '$del'
  '*' -> '$mul'
  '&&' -> '$and'
  '||' -> '$or'
  '++' -> '$concat'
  'new' -> '$new'
  nonOp -> foldl (\s c -> s ++ opChar c) '' (strToArray nonOp) 

opChar c = case c of
  '-' -> '$mns'
  '+' -> '$pls'
  '*' -> '$mul'
  '/' -> '$div'
  '=' -> '$eq'
  ':' -> '$col'
  '&' -> '$amp'
  '|' -> '$pip'
  '<' -> '$lt'
  '>' -> '$gt'
  '^' -> '$rof'
  _ -> c

optExpr e = case e of
  JSRef _ -> e
  JSIndex x i -> JSIndex (optExpr x) (optExpr i)
  JSUnOp op a -> JSUnOp op (optExpr a)
  JSBinOp op a b -> JSBinOp op (optExpr a) (optExpr b)
  JSCall f xs -> JSCall (optExpr f) (map optExpr xs)
  JSFun ps bs -> JSFun ps (optStmts bs)
  JSTernary p a b -> JSTernary (optExpr p) (optExpr a) (optExpr b)
  JSNum _ -> e
  JSString _ -> e
  JSBool _ -> e
  JSNull -> e
  JSUndefined -> e
  JSObject kvs -> JSObject (map (\kv -> case kv of (k, v) -> (k, optExpr v)) kvs)
  JSArray vs -> JSArray (map optExpr vs)
  JSInstanceOf a b -> JSInstanceOf (optExpr a) (optExpr b)
  JSNew c xs -> JSNew (optExpr c) (map optExpr xs)

safeLast xs = case (length xs) of
  0 -> Nothing
  _ -> Just (last xs)

optStmts ss = let
  f s = case s of
    JSExpr e -> JSExpr (optExpr e)
    JSVar v e -> JSVar v (optExpr e)
    JSConst v e -> JSConst v (optExpr e)
    JSLet v e -> JSLet v (fmap optExpr e)
    JSAssign a b -> JSAssign (optExpr a) (optExpr b)
    //JSIf (JSRef v) xs (JSIf (JSUnOp '!' (JSRef w)) ys zs) -> case (v == w) of
    //  True -> JSIf 
    JSIf p xs ys -> JSIf (optExpr p) (optStmts xs) (optStmts ys)
    JSReturn e -> JSReturn (optExpr e)
  hasLet v = let
    f s = case s of
      JSLet w _ -> v == w
      _ -> False
    in exists f ss
  in case (safeLast ss) of
    Just (JSReturn (JSRef v)) -> case (hasLet v) of
      True -> optStmts (concatMap (directReturn v) (init ss))
      False ->  map f ss
    _ -> map f ss

directReturn v s = case s of
  JSLet w e -> case (v == w) of
    False -> [s]
    True -> case e of
      Nothing -> []
      Just _ -> error 'unexpected let assignment'
  JSConst w e -> case (v == w) of
    False -> [s]
    True -> [JSReturn e]
  JSAssign (JSRef w) e -> case (v == w) of
    False -> [s]
    True -> [JSReturn e]
  JSIf p xs ys -> [JSIf p (concatMap (directReturn v) xs) (concatMap (directReturn v) ys)]
  _ -> [s]
