import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import * from '//compiler/js/ast.jg'

binOp op a b = JSBinOp op (jaguarExprToJsExpr a) (jaguarExprToJsExpr b)

jaguarExprToJsExpr = \e -> case e of
  Var _ 'True' -> JSBool True
  Var _ 'False' -> JSBool False
  Var _ v -> JSRef (opName v)
  Const _ (CNum n) -> JSNum n
  Const _ (CStr s) -> JSString s
  App _ (App _ (Var _ '+') a) b -> binOp '+' a b
  App _ (App _ (Var _ '-') a) b -> binOp '-' a b
  App _ (App _ (Var _ '*') a) b -> binOp '*' a b
  App _ (App _ (Var _ 'bitAnd') a) b -> binOp '&' a b
  App _ (App _ (Var _ 'bitOr') a) b -> binOp '|' a b
  App _ (App _ (Var _ 'bitShiftLeft') a) b -> binOp '<<' a b
  App _ (App _ (Var _ 'bitShiftRight') a) b -> binOp '>>>' a b
  App _ f a -> JSCall (jaguarExprToJsExpr f) (arr1 (jaguarExprToJsExpr a))
  Lam _ p e -> JSFun (arr1 p) (arr1 (JSReturn (jaguarExprToJsExpr e)))
  Case _ e ps -> JSCall
    (JSFun
      emptyArray
      (arr2
        (JSVar '$pm' (jaguarExprToJsExpr e))
        (JSReturn (foldr
          assemblePatternMatch
          (JSCall (JSRef 'error') (arr1 (JSString 'pattern match fail')))
          ps))))
    emptyArray
  Let _ ds e-> JSCall
    (JSFun
      emptyArray
      (push
        (JSReturn (jaguarExprToJsExpr e))
        (map defToJs ds)))
    emptyArray

assemblePatternMatch = \alt p -> case p of
  Pair pat e -> case (processPattern (JSRef '$pm') pat) of
    Pair f (Pair ns vs) ->
      JSTernary
        f
        (JSCall (JSFun ns (arr1 (JSReturn (jaguarExprToJsExpr e)))) vs)
        alt

checkUndefined label expr =
  JSTernary (JSBinOp '===' expr JSUndefined) (JSCall (JSRef 'error') (arr1 (JSString label))) expr

processPattern = \pm p -> case p of
  PVar _ '_' -> Pair (JSBool True) (Pair emptyArray emptyArray)
  PVar _ v -> Pair (JSBool True) (Pair (arr1 (opName v)) (arr1 pm))
  PConst _ (CNum n) -> Pair
    (JSBinOp '==' (JSNum n) pm)
    (Pair emptyArray emptyArray)
  PConst _ (CStr s) -> Pair
    (JSBinOp '==' (JSString s) pm)
    (Pair emptyArray emptyArray)
  PData _ 'True' ps -> Pair pm (Pair emptyArray emptyArray)
  PData _ 'False' ps -> Pair (JSUnOp '!' pm) (Pair emptyArray emptyArray)
  PData _ t ps -> 
    foldl
      (\a b -> case a of
        Pair fa (Pair na va) -> case b of
          Pair fb (Pair nb vb) ->
            Pair (JSBinOp '&&' fa fb) (Pair (concat na nb) (concat va vb)))
      (Pair (JSBinOp '==' (JSIndex pm (JSString '$tag')) (JSIndex (JSRef t) (JSString '$tag'))) (Pair emptyArray emptyArray))
      (map
        (\p -> case p of
          Pair n pat ->
            processPattern (JSIndex pm (JSString ('$' ++ intToString n))) pat)
        (zipWithIndex ps))
  z -> error 'failure to match pattern during processing'

defToJs = \p -> case p of
  Pair n e -> JSVar (opName n) (jaguarExprToJsExpr e)

requireExpr = \f -> JSCall (JSRef '_require') (arr1 (JSString f))

buildImports = \f ns ->
  map (\n -> case n of Pair n a -> JSVar (opName a) (JSIndex (requireExpr f) (JSString (opName n)))) ns

importToJs i = case i of
  ImportOpen _ f ns -> buildImports f ns

dataConFieldIds = \ts ->
  map (\p -> '$' ++ intToString (fst p)) (zipWithIndex ts)

dataConToJs = \dc -> case dc of
  DataCon _ n ts -> let
    conName = '$' ++ n
    in arr3
      (JSVar conName (JSFun (dataConFieldIds ts) (push (JSExpr (JSBinOp '=' (JSIndex (JSRef 'this') (JSString '$tag')) (JSString n))) (map (\f -> JSExpr (JSBinOp '=' (JSIndex (JSRef 'this') (JSString f)) (checkUndefined 'con' $ JSRef f))) (dataConFieldIds ts)))))
      (JSVar n (foldr (\b f -> JSFun (arr1 f) (arr1 (JSReturn b))) (JSNew (JSRef conName) (map JSRef (dataConFieldIds ts))) (dataConFieldIds ts)))
      (JSAssign (JSIndex (JSRef n) (JSString '$tag')) (JSString n))

dataToJs = \d -> case d of
  Data _ n ps cs -> concatMap dataConToJs cs

exportObject = \m -> JSObject (map (\n -> Pair (opName n) (JSRef (opName n))) (getExports m))

moduleToJs importSymbols m = case m of
  Module _ is ds cs ins vs -> let
    imports = concatMap importToJs is
    dataDefs = concatMap dataToJs ds
    defs = map defToJs vs
    exportDef = JSVar 'exports' (exportObject m)
    in push exportDef (concat imports (concat dataDefs defs))

opName = \op -> case op of
  '+' -> '$add'
  '-' -> '$del'
  '*' -> '$mul'
  '<' -> '$lt'
  '>' -> '$gt'
  '==' -> '$eq'
  '/=' -> '$neq'
  '&&' -> '$and'
  '||' -> '$or'
  '++' -> '$concat'
  nonOp -> foldl (\s c -> s ++ opChar c) '' (strToArray nonOp) 

opChar c = case c of
  '-' -> '$mns'
  '+' -> '$pls'
  '*' -> '$mul'
  '/' -> '$div'
  '=' -> '$eq'
  ':' -> '$col'
  '&' -> '$amp'
  '|' -> '$pip'
  '<' -> '$lt'
  '>' -> '$gt'
  '^' -> '$rof'
  _ -> c
