import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import * from '//compiler/js/ast.jg'

binOp2 op a b = rewriteExpr a >>= \a -> rewriteExpr b >>= \b -> ret (JSBinOp op a b)

data RewriteState = RewriteState
  (Map String (Maybe Number))   // Constructors of single-con data types
  (Map String JSExpr) // Values to inline (used in case compilation)
  (Array JSStmt)      // Preceding statements for this scope
  Number              // Unique ids

addStmt stmt = gets >>= \s -> case s of
  RewriteState cons rep stmts i -> sets (RewriteState cons rep (push stmt stmts) i)

addVar n e = addStmt (JSVar (opName n) e)

newPhi = gets >>= \s -> case s of
  RewriteState cons rep stmts i -> sets (RewriteState cons rep stmts (i + 1)) >> ret ('$phi$' ++ intToString i)

rewriteExprToStmts w e = gets >>= \s -> case s of
  RewriteState cons rep stmts i -> sets (RewriteState cons rep [] i) >>
    rewriteExpr e >>= \e -> gets >>= \s -> case s of
      RewriteState cons rep2 stmts2 i2 -> sets (RewriteState cons rep2 stmts i2) >> ret (push (w e) stmts2)

withRep rep m = gets >>= \s -> case s of
  RewriteState cons oldRep stmts i -> sets (RewriteState cons (mergeTrie oldRep rep) stmts i) >>
    m >>= \r -> gets >>= \s -> case s of
      RewriteState cons _ stmts2 i2 -> sets (RewriteState cons oldRep stmts2 i2) >> ret r

getRep n = gets >>= \s -> case s of
  RewriteState _ rep _ _ -> ret (lookup n rep)

getCons = gets >>= \s -> case s of
  RewriteState cons _ _ _ -> ret cons

rewriteExpr e = case e of
  Var _ 'True' -> ret (JSBool True)
  Var _ 'False' -> ret (JSBool False)
  Var _ v -> getRep (opName v) >>= \r -> case r of
    Nothing -> ret (JSRef (opName v))
    Just e -> ret e
  Const _ (CNum n) -> ret (JSNum n)
  Const _ (CStr s) -> ret (JSString s)
  App _ (App _ (Var _ '+') a) b -> binOp2 '+' a b
  App _ (App _ (Var _ '-') a) b -> binOp2 '-' a b
  App _ (App _ (Var _ '*') a) b -> binOp2 '*' a b
  App _ (App _ (Var _ 'jsLt') a) b -> binOp2 '<' a b
  App _ (App _ (Var _ 'jsEq') a) b -> binOp2 '===' a b
  App _ (App _ (Var _ 'bitAnd') a) b -> binOp2 '&' a b
  App _ (App _ (Var _ 'bitOr') a) b -> binOp2 '|' a b
  App _ (App _ (Var _ 'bitShiftLeft') a) b -> binOp2 '<<' a b
  App _ (App _ (Var _ 'bitShiftRight') a) b -> binOp2 '>>>' a b
  App _ f a -> rewriteExpr f >>= \f -> 
    rewriteExpr a >>= \a -> ret (JSCall f [a])
  Lam _ p e -> rewriteExprToStmts JSReturn e >>= \stmts -> ret (JSFun [p] stmts)
  Case _ e ps -> newPhi >>= \phiOut ->
    rewriteExpr e >>= \e -> (case e of
      JSRef _ -> ret e
      JSIndex _ _ -> ret e
      _ -> newPhi >>= \p -> addVar p e >> ret (JSRef p)) >>= \phiIn ->
        foldM (assemblePatternMatch2 phiIn phiOut) (JSExpr (JSCall (JSRef 'error') [JSString 'pattern match fail', phiIn])) (reverse ps) >>=
          addStmt >> ret (JSRef phiOut)
  Let _ ds e->
    mapM (\d -> case d of Pair n e -> rewriteExpr e >>= addVar n) ds >> rewriteExpr e
  New _ 'Array' es -> mapM rewriteExpr es >>= \es -> ret (JSArray es)
  New _ tag es -> mapM rewriteExpr es >>= \es -> getCons >>= \cons -> case (lookup tag cons) of
    Nothing -> error ('unrecognized tag in New: ' ++ tag)
    Just (Nothing) -> ret (JSObject (zip (dataConFieldIds es) es))
    Just (Just tag) -> ret (JSObject (push (Pair '$tag' (JSNum tag)) (zip (dataConFieldIds es) es)))

assemblePatternMatch2 phiIn phiOut alt p = getCons >>= \cons -> case p of
  Pair pat e -> case (processPattern cons phiIn pat) of
    Pair f (Pair ns vs) -> let
      rep = foldl (\r p -> insert (fst p) (snd p) r) Empty (zip ns vs)
      in withRep rep (rewriteExprToStmts (JSVar phiOut) e) >>= \stmts -> ret (JSIf f stmts [alt])

checkUndefined label expr =
  JSTernary (JSBinOp '===' expr JSUndefined) (JSCall (JSRef 'error') [JSString label]) expr

processPattern cons pm p = case p of
  PVar _ '_' -> Pair (JSBool True) (Pair [] [])
  PVar _ v -> Pair (JSBool True) (Pair [opName v] [pm])
  PConst _ (CNum n) -> Pair
    (JSBinOp '==' (JSNum n) pm)
    (Pair [] [])
  PConst _ (CStr s) -> Pair
    (JSBinOp '==' (JSString s) pm)
    (Pair [] [])
  PData _ 'True' ps -> Pair pm (Pair [] [])
  PData _ 'False' ps -> Pair (JSUnOp '!' pm) (Pair [] [])
  PData _ t ps ->let
    tagCheck = case (lookup t cons) of
      Just (Nothing) -> JSBool True
      Just (Just tag) -> JSBinOp '==' (JSIndex pm (JSString '$tag')) (JSNum tag)
      _ -> error ('unknown data type in code gen: ' ++ t)
    in foldl
      (\a b -> case a of
        Pair fa (Pair na va) -> case b of
          Pair fb (Pair nb vb) ->
            Pair (JSBinOp '&&' fa fb) (Pair (concat na nb) (concat va vb)))
      (Pair tagCheck (Pair [] []))
      (map
        (\p -> case p of
          Pair n pat ->
            processPattern cons (JSIndex pm (JSString ('$' ++ intToString n))) pat)
        (zipWithIndex ps))
  z -> error 'failure to match pattern during processing'

requireExpr = \f -> JSCall (JSRef '_require') [JSString f]

buildImports = \f ns ->
  map (\n -> case n of Pair n a -> JSVar (opName a) (JSIndex (requireExpr f) (JSString (opName n)))) ns

importToJs i = case i of
  ImportOpen _ f ns -> buildImports f ns

dataConFieldIds = \ts ->
  map (\p -> '$' ++ intToString (fst p)) (zipWithIndex ts)

exportObject bs = JSObject (map (\n -> Pair (opName n) (JSRef (opName n))) (map fst bs))

moduleToJs importSymbols m = case m of
  Module _ _ is _ _ _ vs -> let
    imports = concatMap importToJs is
    gatherCons m d = case d of
      Pair n e -> case (getAnn 'data' (annOf e)) of
        Nothing -> m
        Just (AnnData tag) -> insert n tag m
    cons = foldl gatherCons Empty vs
    vs2 = let
      f p = case p of
        Pair n e -> not (isJust (getAnn 'dead' (annOf e)))
      in filter f vs
    defs = foldl1 concat $ evalState (RewriteState cons Empty [] 0) (mapM (\v -> case v of Pair n e -> rewriteExprToStmts (JSVar (opName n)) e) vs2)
    exportDef = JSVar 'exports' (exportObject vs2)
    in push exportDef (concat imports defs)

opName = \op -> case op of
  '+' -> '$add'
  '-' -> '$del'
  '*' -> '$mul'
  '&&' -> '$and'
  '||' -> '$or'
  '++' -> '$concat'
  nonOp -> foldl (\s c -> s ++ opChar c) '' (strToArray nonOp) 

opChar c = case c of
  '-' -> '$mns'
  '+' -> '$pls'
  '*' -> '$mul'
  '/' -> '$div'
  '=' -> '$eq'
  ':' -> '$col'
  '&' -> '$amp'
  '|' -> '$pip'
  '<' -> '$lt'
  '>' -> '$gt'
  '^' -> '$rof'
  _ -> c
