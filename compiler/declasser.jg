import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {classToBindings, unify, applySubsBound, instanceToTypeBound, satisfiesBound, skolemizeSubs, instantiate} from '//compiler/typer.jg'
import {printType, printTypeBound, reallyPrintExpr, printInst} from '//compiler/printer.jg'
import {mkConFun} from '//compiler/adt.jg'
import {instanceMatches} from '//compiler/typeutil.jg'
import {instFromDef} from '//compiler/newtyper.jg'

declassModule ms m = case m of
  Module ann fn imps dt cs ins ds -> let
    // Materialize instances from import modules as reified instance object imports.
    _isi = foldl (rewriteImportedInstances ms) (Pair [] []) imps
    impsWithImportedInstances = fst _isi
    importedInstances = snd _isi

    // Translate class declarations
    classFuns = concat
      (map mkClassDictConstructor cs)
      (concatMap mkClassDictAccessors cs)

    // Find all instances visible in this module.
    // List of pairs of (instance name, type bound)
    availableInstances = concat
      importedInstances
      (map (mapSnd instFromDef) ins)

    // Construct the environment, i.e. map of (name -> type)
    env = let
      importedSymbols = importsToTypeEnv ms imps
      localBindings = concat classFuns ds
      in foldl
        (\env b -> case b of Pair v e -> set v (getType e) env)
        importedSymbols
        localBindings

    // We currently do not support type classes in ADT.
    // Furthermore, we want the class funs to appear after ADT defs.
    // For that reason we will separate our defs.
    _sds = let
      splitData d = case (lookup 'data' (annOf (snd d))) of
        Nothing -> Right d
        Just _ -> Left d
      in splitEither (map splitData ds)
    adtDs = fst _sds
    nonAdtDs = snd _sds

    // Rewrite all expressions.
    declassedDs = map
      (\d -> Pair (fst d) (rewriteExpr availableInstances env (snd d)))
      nonAdtDs

    // Rewrite instances as class dict instantiations.
    instancesAsDicts = map
      (\p -> case p of Pair n i -> rewriteInstance availableInstances env n i)
      ins

    // Put it all together in some reasonable order and return.
    finalDs = concat adtDs (concat classFuns (concat instancesAsDicts declassedDs))
    in Module ann fn impsWithImportedInstances dt [] [] finalDs

// Adds explicit imports for instances and classes provided by the imported module.
// Also gathers the imported instances as (local name, type bound).
rewriteImportedInstances ms _isi imp = case _isi of
  Pair outImps outIns -> case imp of
    ImportOpen ann f ns -> case (get f ms) of
      ModuleInterface _ cls ins -> let
        importedClassNames = map
          (\n -> Pair n n)
          (concatMap
            (\c -> case c of Class _ n _ bs -> enqueue (className n) (map fst bs))
            cls)
        importedBounds = trieEntries ins
        importedInsNames = map (\ni -> (fst ni, fst ni)) importedBounds
        in Pair
          (push
            (ImportOpen ann f (concat ns (concat importedInsNames importedClassNames)))
            outImps)
          (concat outIns importedBounds)

// Translates the class declaration into a data type constructor function.
// Will be used to create the class dictionaries.
mkClassDictConstructor c = case c of
  Class _ n tvn _  -> let
    // Construct the class name.
    name = className n
    // Get the bindings with types from the class def, sort to ensure stable
    // mapping (because ADTs have no field labels) then get the types.
    params = map snd (sort (classToBindings c))
    // All classes have the form (ClassName tvar)
    type = TApp emptyAnn (TConst emptyAnn n) (TVar emptyAnn tvn)
    // Make the constructor function, note no tag since there is only one variant.
    in mkConFun Nothing type [tvn] name params

// Translates the class memebers into accessor functions which
// take the class dict as the first arg, unpack the class member and return it.
// Marks the accessors as exported as classes are implicitly.
mkClassDictAccessors c = case c of
  Class _ _ _ bs -> let
    name = className2 c
    bsForPat = let
      f b = PVar emptyAnn (fst b ++ '_')
      in map f (sort bs)
    v = 'x_' ++ name
    rewrite b = case b of
      Pair n t -> Pair n (setType t (Lam (setAnn 'export' (AnnExport n) emptyAnn) v (Case emptyAnn (Var emptyAnn v) [Pair (PData emptyAnn name bsForPat) (Var emptyAnn (n ++ '_'))])))
    in map rewrite (classToBindings c)

// Translates the instance into a class dict by calling the constructor.
// We sort the bindings by name (the need to match what the constructor is doing).
// We also mark this function as exported as all instances are implicitly exported.
rewriteInstance is env n i = case i of
  Instance _ c _ bs -> let
    args = map (rewriteExpr is env) (map snd (sort bs))
    e = foldl (App emptyAnn) (Var emptyAnn (className c)) args
    in Pair n (withAnn (setAnn 'export' (AnnExport n) emptyAnn) e)

// State of the rewriter which keeps track of:
// - environment
// - available instance bounds
data State = S (Array (Record Type)) (Array (Pair String Inst)) Number
getEnv s = case s of
  S env _ _ -> env
setEnv env s = case s of
  S _ is n -> S env is n

// 1. if type has a bound then wrap it in lambdas to pass the correct instances
// 2. a reference to a var with a bound is replaced by a App of the instance
//    dict to the var
rewriteExpr is env e = let
  // On the descent when we find a forall with bounds then replace the bounds
  // with explicit lambdas and add the new locally available instances to the state.
  boundsToLam a e = let
    addInstance vs b a = case a of
      S env is n -> let
        name = instanceNameFromBound n b
        in Pair (S env (push (Pair name (Inst [] b)) is) (n + 1)) name
    rewriteBound vs ae ib = case ib of
      Pair ix b -> case ae of
        Pair a e -> case (addInstance vs b a) of
          Pair a name -> Pair a (Lam emptyAnn name e)
    in case (getType e) of
      TForall _ vs bs t -> case (length bs > 0) of
        False -> Pair a e
        True -> let
          rewritten = foldr (rewriteBound vs) (Pair a (setType t e)) (zipWithIndex bs)
          in mapSnd (\re -> withAnn (copyAnn ['export'] (annOf e)) re) rewritten
      _ -> Pair a e
  rewriteVar a e = case e of
    Var _ v ->
      //case (getType e) of
      // Not 100% why this was added, but it seems necessary.
      // Might be for fully polymorphic invocations of data constructors.
      //TForall _ _ _ _ -> case v of
      //  'pure' -> debug2 ('**dcls: pure not rewritten') (a, e) 
      //  _ -> Pair a e
      //tv -> 
      let
        tv = case (getType e) of
          TForall _ _ _ t -> t
          t -> t
        // We might be dealing with a class accessor.
        fromEnv n envs = let
          env = head envs
          in case (has n env) of
            False -> error ('no ' ++ n ++ ' in env ' ++ jsonStringify (keys env))
            True -> get n env
        findMatching b a = case a of
          S _ is _ -> let
            matching = filter (\p -> case p of Pair _ i -> instanceMatches [] b i) is
            in case (length matching) of
              0 -> error ('declasser failed to find satisfying instance for ' ++ printTypeBound b ++ ' ' ++ exprLoc e ++
                            '\nKnown type class instances:' ++
                            concatMap (\(_, i) -> '\n  # ' ++ printInst i) is)
              1 -> fst (getIx 0 matching)
              _ -> error ('declasser found more than 1 satisfying instance for ' ++ printTypeBound b  ++ ' ' ++ exprLoc e ++
                '\n' ++ join (map (\m -> printInst (snd m)) matching) ',')
        requiredInstances tv td = case (instantiate Unit (\_ v -> Pair Unit $ TVar emptyAnn ('$ins$' ++ v)) td) of
          Pair (Pair t bs) _ -> let
            subs = unify (\s -> 'declasser: ' ++ s) tv t
            in map (applySubsBound subs) bs
          _ -> []
        t = fromEnv v (getEnv a)
        is = requiredInstances tv t
        mis = map (\b -> findMatching b a) is
        e2 = foldl (\e v -> App emptyAnn e (Var emptyAnn v)) e mis
        in Pair a e2
    // When exiting a lambda drop the associated instance.
    // This will be called whether a lambda is froma type bound or not.
    // We rely on our constructed names being unique.
    Lam _ p _ -> let
      dropInstance v a = case a of
        S env is n -> S env (filter (\p -> fst p /= v) is) n
      in Pair (dropInstance p a) e
    _ -> Pair a e
  in snd (breakableDownAndUpWithEnv
    getEnv
    setEnv
    (\a e -> Left (boundsToLam a e))
    rewriteVar
    (S [env] is 0) e)

breakableDownAndUpWithEnv getEnv setEnv down up a e = let
  go a e = breakableDownAndUp processDown processUp a e
  enterScope bs a = let
    es = getEnv a
    e = merge (head es) bs
    in setEnv (enqueue e es) a
  exitScope a = setEnv (tail (getEnv a)) a
  processDown a e = case (down a e) of
    Right ae -> Right ae
    Left (Pair a e) -> case e of
      Lam _ p b -> let
        t = case (getType e) of
          TApp _ (TApp _ (TConst _ '->') t) _ -> t
          TForall _ _ _ (TApp _ (TApp _ (TConst _ '->') t) _) -> t
          _ -> TUnknown
        in Left (Pair (enterScope (set p t empty) a) e)
      Let _ bs _ -> let
        ts = foldl (\ts b -> case b of Pair n e -> set n (getType e) ts) empty bs
        in Left (Pair (enterScope ts a) e)
      Case ann e ps -> case (go a e) of
        Pair a e -> case (foldl processPat (Pair a []) ps) of
          Pair a ps -> Right (Pair a (Case ann e ps))
      _ -> Left (Pair a e)
  processPat ar pat = case ar of
    Pair a r -> case pat of
      Pair pat e -> let
        bs = patBindings pat
        in case (go (enterScope bs a) e) of
          Pair a e -> Pair (exitScope a) (push (Pair pat e) r)
  processUp a e = let
    a2 = case e of
      Lam _ _ _ -> exitScope a
      Let _ _ _ -> exitScope a
      _ -> a
    in up a2 e
  patBindings p = case p of
    PConst _ _ -> empty
    PVar ann v -> set v (getAnnType ann) empty
    PData _ _ ps -> foldr (\env p -> merge (patBindings p) env) empty ps
  in go a e

importsToTypeEnv ms is = let
  getFile i = case i of
    ImportAll _ f -> f
    ImportOpen _ f _ -> f
    ImportClosed _ f _ -> f
  addClass env c = foldl (\env b -> set (fst b) (snd b) env) env (classToBindings c)
  addImports env i = case (get (getFile i) ms) of
    ModuleInterface bs cs _ -> let
      env2 = case i of
        ImportAll _ f -> merge env bs
        ImportOpen _ f ns -> foldl (\env n -> case n of Pair n a -> set a (get n bs) env) env ns
        _ -> error 'import type not supported in type inference'
      env3 = foldl addClass env2 cs
      in env3
  in foldl addImports empty (enqueue (ImportAll emptyAnn './builtins.js') is)

className n = '$class$' ++ n

className2 c = case c of
  Class _ n _ _ -> className n

instanceNameFromBound ix b = case b of
  TCBound _ n _ -> 'local$instance$' ++ n ++ '$' ++ intToString ix
