import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType, printTypeBound, reallyPrintExpr, printDef} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'

// --------------- Subs -------------------------------

data Subs = Subs (Map String Type) (Map String Type)

getSub v (Subs sat unsat) = lookup v sat <|> lookup v unsat

emptySubs = Subs Empty Empty

composeSubs ef sa (Subs sat unsat) = foldTrie (\r v t -> addSub ef v t r) (foldTrie (\r v t -> addSatSub ef v t r) sa sat) unsat

addSub ef v t subs = let
  t2 = applySubs subs t
  in case (getSub v subs) of
    Nothing -> case subs of
      Subs sat unsat -> let
        subUnsat su uv ut = case su of
          Pair sat unsat -> let
            ut2 = substitute v t2 ut
            in case (isEmpty (freeTVars ut2)) of
              True -> Pair (insert uv ut2 sat) unsat
              False -> Pair sat (insert uv ut2 unsat)
        su = foldTrie subUnsat (Pair sat Empty) unsat
        sat2 = fst su
        unsat2 = snd su
        in case (isEmpty (freeTVars t2)) of
          True -> Subs (insert v t2 sat2) unsat2
          False -> Subs sat2 (insert v t2 unsat2)
    Just subT -> composeSubs ef subs (unify ef subT t2)

addSatSub ef v t subs = case (getSub v subs) of
  Nothing -> case subs of
    Subs sat unsat -> let
      subUnsat su uv ut = case su of
        Pair sat unsat -> let
          ut2 = substitute v t ut
          in case (isEmpty (freeTVars ut2)) of
            True -> Pair (insert uv ut2 sat) unsat
            False -> Pair sat (insert uv ut2 unsat)
      su = foldTrie subUnsat (Pair sat Empty) unsat
      sat2 = fst su
      unsat2 = snd su
      in Subs (insert v t sat2) unsat2
  Just subT -> composeSubs ef subs (unify ef subT t)

dropSubs vs subs = case subs of
  Subs sat unsat -> Subs (foldl (\r v -> remove v r) sat vs) (foldl (\r v -> remove v r) unsat vs)

// -------------- Context -----------------------------

data InferenceContext = ICtx Subs (Array TypeBound) Number (String -> String)

newTVar ctx = case ctx of
  ICtx subs bs i e -> let
    n = '$' ++ intToString i
    in Pair (ICtx subs bs (i + 1) e) (TVar emptyAnn n)

newTVarM = gets >>= \ctx -> case ctx of
  ICtx subs bs i e -> let
    n = '$' ++ intToString i
    in sets (ICtx subs bs (i + 1) e) >> ret (TVar emptyAnn n)

newCtx = ICtx emptySubs [] 1 (\s -> 'unknown error context: ' ++ s)

getSubs ctx = case ctx of
  ICtx subs _ _ _ -> subs

setSubs subs ctx = case ctx of
  ICtx _ bs i e -> ICtx subs (map (applySubsBound subs) bs) i e

addBound b ctx = case ctx of
  ICtx subs bs i e -> ICtx subs (push b bs) i e

getBounds ctx = case ctx of
  ICtx _ bs _ _ -> bs

setBounds bs ctx = case ctx of
  ICtx subs _ i e -> ICtx subs bs i e

errorM s = gets >>= \ctx -> case ctx of
  ICtx _ _ _ e -> error (e s)

onError e = gets >>= \ctx -> case ctx of
  ICtx subs bs i _ -> sets (ICtx subs bs i e)

withError e f = getErrorF >>= \old -> onError e >> f >>= \r -> onError old >> ret r

getErrorF = gets >>= \ctx -> case ctx of
  ICtx _ _ _ e -> ret e

// -------------- Environment -------------------------

data InferenceEnvironment = IEnv (Map String Type) (Array TypeBound) (Map String Unit)

emptyEnv = IEnv Empty [] emptySet

getBinding n env = case env of
  IEnv bs _ _ -> lookup n bs

getBindingM n env = gets >>= \ctx -> ret $ fmap (applySubs (getSubs ctx)) (getBinding n env)

getBindings env = case env of
  IEnv bs _ _ -> bs

addBinding n t env = case env of
  IEnv bs ts fvs -> IEnv (insert n t bs) ts (setUnion fvs (freeTVars t))

addBindings nbs env = case env of
  IEnv bs ts fvs -> IEnv (mergeTrie bs nbs) ts (foldTrie (\fvs _ t -> setUnion fvs (freeTVars t)) fvs nbs)

freeTVarsInEnv env = case env of
  IEnv _ _ fvs -> fvs

addInstance b env = case env of
  IEnv bs ts fvs -> IEnv bs (push b ts) fvs

getInstances env = case env of
  IEnv _ ts _ -> ts

// ------------ Inference Engine ----------------------

freeTVars t = case t of
  TVar _ v -> setAdd v emptySet
  TBot -> emptySet
  TUnknown -> emptySet
  TConst _ c -> emptySet
  TSkolem _ _ -> emptySet
  TForall _ vs bs t ->
    foldl (\s v -> setRemove v s) (foldl setUnion (freeTVars t) (map freeTVarsInBound bs)) vs
  TApp _ f a -> setUnion (freeTVars f) (freeTVars a)
  TRow _ ms r -> foldl setUnion (justOr emptySet $ fmap freeTVars r) (map (\m -> setUnion (freeTVars (fst m)) (freeTVars (snd m))) ms)

f1 a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

mkTForall ann vs bs t = let
  f bs b = case (exists (equivBound b) bs) of
    True -> bs
    False -> push b bs
  in TForall ann vs (foldl f [] bs) t

instantiateM t = gets >>= \ctx -> case (instantiate ctx (\ctx _ -> newTVar ctx) t) of
  Pair (Pair t bs) ctx ->
    sets (foldl (\ctx b -> addBound b ctx) ctx bs) >> ret t

instantiate ctx mkvar t = case t of
  TForall ann vs bs t -> let
    (subs, ctx2) = let
      f (subs, ctx) v = case (mkvar ctx v) of
        (ctx, tv) -> (insert v tv subs, ctx)
      in foldl f (Empty, ctx) vs
    replace t = case t of
      TConst _ _ -> t
      TVar _ _ -> t
      TBot -> t
      TSkolem _ n -> case (lookup n subs) of
        Nothing -> t
        Just tv -> tv
      TApp ann f a -> TApp ann (replace f) (replace a)
      TRow ann ms r -> TRow
        ann
        (map (\(k, v) -> (replace k, replace v)) ms)
        (fmap replace r)
      TForall _ _ _ _ -> error 'nested universal quantification'
    replaceBound b = case b of
      TCBound ann n t -> TCBound ann n (replace t)
    in Pair (Pair (replace t) (map replaceBound bs)) ctx2
  _ -> Pair (Pair t []) ctx

substitute n s t = applySubs (addSub (\s -> 'substitute: ' ++ s) n s emptySubs) t

applySubs subs t = case t of
  TForall ann vs bs t -> let
    subs2 = dropSubs vs subs
    in mkTForall ann vs (map (applySubsBound subs2) bs) (applySubs subs2 t)
  TVar _ v -> justOr t (getSub v subs)
  TApp ann f a -> TApp ann (applySubs subs f) (applySubs subs a)
  TRow ann ms r -> TRow ann (map (\(k, v) -> (applySubs subs k, applySubs subs v)) ms) (fmap (applySubs subs) r)
  _ -> t

applySubsM t = gets >>= \ctx -> ret (applySubs (getSubs ctx) t)

applySubsBound subs b = case b of
  TCBound ann n t -> TCBound ann n (applySubs subs t)

unifyM a b = gets >>= \ctx -> getErrorF >>= \ef -> let
  ef2 s = ef ('unifying ' ++ printType a ++ ' and ' ++ printType b ++ ': ' ++ s)
  in sets (setSubs (composeSubs ef2 (getSubs ctx) (unify ef2 a b)) ctx)

unify ef a b = let
  bind n t = case t of
    TVar _ m -> case (n == m) of
      True -> emptySubs
      False -> addSub ef n t emptySubs
    _ -> case (setContains n (freeTVars t)) of
      True ->
        //debug (printType a)
        //_ = debug (printType b)
        error (ef 'occurs check failed')
      False -> addSub ef n t emptySubs
  err a b = error
    (ef ('cannot unify ' ++ printType a ++ ' with ' ++ printType b))
  in case a of
    TVar _ v -> case b of
      //TSkolem _ _ -> err a b
      _ -> bind v b
    TSkolem _ va -> case b of
      TSkolem _ vb -> case (va == vb) of
        True -> emptySubs
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TConst _ ca -> case b of
      TConst _ cb -> case (ca == cb) of
        True -> emptySubs
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TUnknown -> err a b
    TBot -> err a b
    TApp _ fa xa -> case b of
      TVar _ v -> bind v a
      TApp _ fb xb -> let
        fsubs = unify ef fa fb
        xsubs = unify ef (applySubs fsubs xa) (applySubs fsubs xb)
        in composeSubs ef fsubs xsubs
      _ -> err a b
    TRow _ _ (Nothing) -> case b of
      TVar _ v -> bind v a
      _ -> err a b
    TRow _ ms _ -> case b of
      TVar _ v -> bind v a
      TRow _ ms2 (Nothing) -> err a b
      _ -> err a b
    _ -> err a b

freeTVarsInBound b = case b of
  TCBound _ _ t -> freeTVars t

withLocError e f = case (getAnnCodeLoc (annOf e)) of
  Nothing -> f
  Just loc -> withError (\s -> s ++ ' ' ++ printCodeLoc loc) f

infer env e = let
  setFinalType t e = case (hasAnnE 'data' e) of
    // Skip this check for generated data constructor functions as they contain
    // skolems in a way that confuses the typer.
    True -> ret e
    False -> case (getType e) of
      TUnknown -> ret (setType t e)
      //te -> instantiateM te >>= \ite -> unifyM t ite >> ret e
      te -> instantiateM te >>= \ite -> unifyM t ite >> applySubsM t >>= \t -> case (satisfies t ite) of
        True -> ret e
        False -> errorM ('inferred type ' ++ printType t ++ ' does not satisfy explicit type ' ++ printType te ++ ' for <<<' ++ reallyPrintExpr False e ++ '>>>')
  inferCase env te (pat, e) = inferPat env te pat >>= \(bs, pat) ->
    infer (addBindings bs env) e >>= \e -> ret (pat, e)
  inferPat env te pat = case pat of
    PVar ann v -> newTVarM >>= \tv ->
      unifyM te tv >> ret (insert v tv Empty, PVar (setAnnType tv ann) v)
    PConst _ (CNum n) -> unifyM te (TConst emptyAnn 'Number') >> ret (Empty, pat)
    PConst _ (CStr s) -> unifyM te (TConst emptyAnn 'String') >> ret (Empty, pat)
    PData ann n ps -> getBindingM n env >>= \bt -> case bt of
      Nothing -> error ('unknown data type ' ++ n)
      Just t -> instantiateM t >>= \t ->
        case (unrollDataConType t) of (tps, dt) ->
          case (length ps == length tps) of
            False -> errorM 'number of pattern params does not match the number of constructor params'
            True -> foldM (inferSubPat env) (Empty, []) (zip ps tps) >>= \(bs, ps) ->
              unifyM te dt >> ret (bs, PData ann n ps)
  inferSubPat env (bs, ps) (pat, t) = inferPat env t pat >>= \(bs2, pat) ->
    ret (mergeTrie bs bs2, push pat ps)
  in withLocError e $ case e of
    Const _ (CNum n) -> setFinalType (TConst emptyAnn 'Number') e
    Const _ (CStr s) -> setFinalType (TConst emptyAnn 'String') e
    Var _ v -> withError (\s -> 'Var: ' ++ s) (getBindingM v env >>= \vt -> case vt of
      Nothing -> errorM ('unknown identifier ' ++ v ++ ', env: ' ++ jsonStringify (trieKeys $ getBindings env))
      Just t -> instantiateM t >>= \t -> setFinalType t e)
    Lam ann p a -> withError (\s -> 'Lam: ' ++ s) (newTVarM >>= \tv ->
      infer (addBinding p tv env) a >>= \a ->
        setFinalType (TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') tv) (getType a)) (Lam ann p a))
    App ann f a -> withError (\s -> 'App: ' ++ s) (newTVarM >>= \tv ->
      infer env f >>= \f ->
        infer env a >>= \a -> let
          synth = f1 (getType a) tv
          in unifyM (getType f) synth >>
            setFinalType tv (App ann f a))
    Case ann e ps -> withError (\s -> 'Case: ' ++ s) $ infer env e >>= \e ->
      mapM (inferCase env (getType e)) ps >>= \ps -> let
        t = getType (snd (head ps))
        in mapM (\(_, e) -> unifyM t (getType e)) (tail ps) >>
          setFinalType t (Case ann e ps)
    Let ann ds e -> withError (\s -> 'Let: ' ++ s) (inferDefs env ds >>= \ds -> let
      env2 = foldl (\env (n, e) -> addBinding n (getType e) env) env ds
      in infer env2 e >>= \e ->
        setFinalType (getType e) (Let ann ds e))
    New ann 'Array' es -> mapM (infer env) es >>= \es ->
      newTVarM >>= \tv ->
        mapM (\e -> unifyM tv (getType e)) es >>
          setFinalType (TApp emptyAnn (TConst emptyAnn 'Array') tv) (New ann 'Array' es)
    New ann '@Rec' es -> let
      unpack es = let
        f (out, n) e = case n of
          Just n -> (push (n, e) out, Nothing)
          Nothing -> case e of Const _ (CStr n) -> (out, Just n)
        in fst (foldl f ([], Nothing) es)
      pack bs = concatMap (\(n, e) -> [Const emptyAnn (CStr n), e]) bs
      mkType bs = let
        f (n, e) = (TConst emptyAnn ('@' ++ n), getType e)
        in TRow emptyAnn (map f bs) Nothing
      in mapM (\(n, e) -> infer env e >>= \e -> ret (n, e)) (unpack es) >>= \bs ->
        setFinalType (mkType bs) (New ann '@Rec' (pack bs))
    New ann tag es -> withError (\s -> 'New: ' ++ s) (mapM (infer env) es >>= \es -> getBindingM tag env >>= \t -> case t of
      Nothing -> error ('unknown data constructor ' ++ tag)
      Just t -> instantiateM t >>= \t ->
        case (unrollDataConType t) of
          (tps, dt) -> case (length es == length tps) of
            False -> errorM ('number of New args does not match the number of constructor params ' ++ jsonStringify es ++ ' ' ++ printType t)
            True -> mapM (\(t, e) -> unifyM t (getType e)) (zip tps es) >>
              withError (\s -> 't = ' ++ printType t ++ ': ' ++ s) (setFinalType dt (New ann tag es)))
    _ -> error 'type inference not supported for this AST node'

inferSccDefs env ds = let
  generateTVar env d = case (getType (snd d)) of
    TUnknown -> newTVarM >>= \tv -> ret (addBinding (fst d) tv env)
    t -> ret (addBinding (fst d) t env)
  inferDef env (n, e) = infer env e >>= \e -> ret (n, e)
  unifyDef env (n, e) = case (getType e) of
    TForall _ _ _ _ -> ret Unit
    t -> unifyM t (fromJust $ getBinding n env)
  generalizeDef env (n, e) = case (getType e) of
    TForall _ _ _ _ -> ret (n, e)
    t -> generalize env t >>= \t -> ret (n, skolemize (setType t e))
  in foldM generateTVar env ds >>= \env2 ->
    mapM (inferDef env2) ds >>= \ds2 ->
      mapM (unifyDef env2) ds2 >>
        mapM applySubsDef ds2 >>= \ds3 ->
          dropSatisfiedBounds env >>
            mapM (generalizeDef env) ds3

skolemizeSubs =
  foldl (\subs v -> addSub (\s -> 'skolemize: ' ++ s) v (TSkolem emptyAnn v) subs) emptySubs

skolemizeType t = case t of
  TForall ann vs bs t -> let
    subs = skolemizeSubs vs
    in TForall ann vs (map (applySubsBound subs) bs) (applySubs subs t)
  _ -> t

skolemize e = case (getType e) of
  TForall ann vs bs t -> let
    subs = skolemizeSubs vs
    t2 = TForall ann vs (map (applySubsBound subs) bs) (applySubs subs t)
    in applySubsE subs (setType t2 e)
  _ -> e

dropSatisfiedBounds env = gets >>= \ctx -> let
  is = getInstances env
  bs = getBounds ctx
  bs2 = filter (\b -> not (exists (\i -> satisfiesBound i b) is)) bs
  in sets (setBounds bs2 ctx)

bindingsScc bs = let
  ns = map fst bs
  g = foldl (\g (n, e) -> insert n (filter (\v -> contains v ns && (v /= n)) (freeVars e)) g) Empty bs
  ccs = sccSorted g
  in map (\cc -> filter (\(n, _) -> contains n cc) bs) ccs

inferDefs env ds = let
  infer rs ds = fmap (concat rs) (inferSccDefs (foldl (\env r -> addBinding (fst r) (getType (snd r)) env) env rs) ds)
  in foldM infer [] (bindingsScc ds)

generalize env t = gets >>= \ctx -> let
  Subs sat unsat = getSubs ctx
  envTVars = freeTVarsInEnv env
  nonFree = foldTrie (\s v _ -> setUnion s (justOr Empty (fmap freeTVars (lookup v unsat)))) envTVars envTVars
  vs = setDiff (freeTVars t) nonFree
  processBounds (bvs, rbs, obs) b = let
    boundVars = freeTVarsInBound b
    sharedVars = setIntersection boundVars vs
    in case (isEmpty sharedVars) of
      True -> (bvs, rbs, push b obs)
      False -> case (size sharedVars == size boundVars) of
        True -> (bvs, push b rbs, obs)
        False -> (setUnion bvs sharedVars, rbs, push b obs)
  (bvs, rbs, obs) = foldl processBounds (emptySet, [], []) (getBounds ctx)
  finalVars = setDiff vs bvs
  drop r v t = case (isEmpty $ setIntersection finalVars (freeTVars t)) of
    True -> insert v t r
    False -> r
  subs2 = Subs sat (foldTrie drop Empty unsat)
  in sets (setBounds obs (setSubs subs2 ctx)) >>
    case ((not $ isEmpty finalVars) || (length rbs > 0)) of
      True -> ret (mkTForall emptyAnn (setToArray finalVars) rbs t)
      False -> ret t

generalizeStandalone t = evalState newCtx (generalize emptyEnv t)

// a -> (b -> (c -> Foo a b c))
unrollDataConType t = case t of
  TApp _ (TApp _ (TConst _ '->') a) b -> case (unrollDataConType b) of
    (ps, t) -> (enqueue a ps, t)
  _ -> ([], t)

applySubsDef (n, e) = gets >>= \ctx -> ret (n, applySubsE (getSubs ctx) e)

applySubsE subs e = let
  f a e = let
    t2 = applySubs subs (getType e)
    in (a, setType t2 e)
  in snd (down f True e)

freeVars e = let
  freeVarsInPat (pat, e) =
    mergeSet
      (filter (\v -> not (contains v (namesInPat pat))) (freeVars e))
      (freeVarsInPData pat)
  freeVarsInPData p = case p of
    PData _ n ps -> foldl mergeSet [n] (map freeVarsInPData ps)
    _ -> []
  in case e of
    Var _ v -> [v]
    Const _ c -> []
    App _ f x -> mergeSet (freeVars f) (freeVars x)
    Lam _ p b -> filter (\v -> v /= p) (freeVars b)
    Case _ e ps -> foldl mergeSet (freeVars e) (map freeVarsInPat ps)
    Let _ ds e -> filter (\v -> not (contains v (map fst ds))) (foldl mergeSet (freeVars e) (map (\d -> freeVars (snd d)) ds))
    New _ _ es -> foldl mergeSet [] (map freeVars es)

inferInstance env cs i = let
  inferE e = case (runState newCtx $ infer env e) of
    (ctx, e2) -> applySubsE (getSubs ctx) e2
  in case i of
    Instance ann n it ds -> case (find (\(Class _ m _ _) -> n == m) cs) of
      Nothing -> error ('Cannot find clas ' ++ n)
      Just (Class _ _ v bs) -> let
        bs2 = foldl (\bs (n, t) -> insert n (substitute v it t) bs) Empty bs
        ds2 = map (\(dn, e) -> (dn, inferE (setType (fromJust $ lookup dn bs2) e))) ds
        in Instance ann n it ds2

instanceToTypeBound (Instance _ n t _) = TCBound emptyAnn n t

classToBindings (Class _ n tv bs) = let
  process (v, t) = let
    ftv = freeTVars t
    in case (setContains tv ftv) of
      False -> error ('invalid clas definition ' ++ n ++ ', binding ' ++ v)
      True -> (v, skolemizeType (mkTForall emptyAnn (setToArray ftv) [TCBound emptyAnn n (TVar emptyAnn tv)] t))
  in map process bs

inferTypeModule ms (Module ann fn is ts cs ins ds) = let
  addImports env (ImportOpen _ f ns) = case (get f ms) of
    ModuleInterface bs cs is -> let
      env2 = foldl (\env (n, a) -> addBinding a (get n bs) env) env ns
      env3 = foldl addClass env2 cs
      env4 = foldTrie (\env _ i -> addInstance i env) env3 is
      in env4
  addClass env c = foldl (\env (n, t) -> addBinding n t env) env (classToBindings c)
  addIns env (_, i) = addInstance (instanceToTypeBound i) env
  checkForUnsatisfiedBounds (n, e) = case (getType e) of
    TForall _ _ bs t -> case t of
      TApp _ (TApp _ (TConst _ '->') _) _ -> (n, e)
      _ -> case (length bs) of
        0 -> (n, e)
        _ -> error ('unsatisfied bounds in def of ' ++ n ++ ' :: ' ++ printType (getType e))
    _ -> (n, e)
  // compute stuff!
  env = emptyEnv
  env2 = foldl addImports env is
  env3 = foldl addClass env2 cs
  env4 = foldl addIns env3 ins
  ds2 = evalState newCtx (inferDefs env4 ds)
  ds3 = map checkForUnsatisfiedBounds ds2
  env5 = foldl (\env (n, e) -> addBinding n (getType e) env) env4 ds3
  ins2 = let
    allCls = concat cs (concatMap (\(ImportOpen _ f _) -> case (get f ms) of ModuleInterface _ cs _ -> cs) is)
    in map (mapSnd (inferInstance env5 allCls)) ins
  in Module ann fn is ts cs ins2 ds3

getTypedExports (Module _ _ _ _ cs ins ds) = let
  collectExports es (_, e) = case (getAnn 'export' (annOf e)) of
    Nothing -> es
    Just (AnnExport n) -> set n (getType e) es
  bs = foldl collectExports empty ds
  in ModuleInterface bs cs (foldl (\m (n, i) -> insert n (instanceToTypeBound i) m) Empty ins)

satisfies a b = // :: Type -> Type -> Pair Bool subs
  let
    instantiateTop t = case (instantiate Unit (\_ v -> (Unit, TVar emptyAnn ('$sat$' ++ v))) t) of
      ((t, _), _) -> t
    sat subs a b = case a of
      TConst _ ca -> case b of
        TConst _ cb -> (ca == cb, subs)
        _ -> (False, subs)
      TApp _ fa xa -> case b of
        TApp _ fb xb -> let
          (fs, subs2) = sat subs fa fb
          (xs, subs3) = sat subs2 xa xb
          in (fs && xs, subs3)
        _ -> (False, subs)
      TSkolem _ va -> case b of
        TSkolem _ vb -> (va == vb, subs)
        _ -> (False, subs)
      TVar _ va -> case (lookup va subs) of
        Nothing -> (True, insert va b subs)
        Just t -> (equivType t b, subs)
      _ -> error ('satisfies does not support type ' ++ printType a)
  in fst (sat Empty (instantiateTop a) b)

satisfiesBound (TCBound _ na ta) (TCBound _ nb tb) = na == nb && satisfies ta tb
