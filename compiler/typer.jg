import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType} from '//compiler/printer.jg'

data InferenceContext = ICtx (Record Type) Number

f1 a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

newTVar ctx = case ctx of
  ICtx subs i -> let
    n = '$' ++ intToString i
    in Pair (ICtx subs (i + 1)) (TVar emptyAnn n)

newCtx = ICtx empty 1

instantiate ctx t = case t of
  TForall _ v t -> case (newTVar ctx) of
    Pair ctx2 tv -> case (instantiate ctx2 t) of
      Pair ctx3 t2 -> Pair ctx3 (substitute v tv t2)
  _ -> Pair ctx t

substitute n s t = applySubs (set n s empty) t

applySubs subs t = case t of
  TForall ann v t -> TForall ann v (applySubs (del v subs) t)
  TVar _ v -> case (has v subs) of
    False -> t
    True -> get v subs
  TApp ann f a -> TApp ann (applySubs subs f) (applySubs subs a)
  _ -> t

applySubsEnv subs env = mapRecord (applySubs subs) env

composeSubs sa sb = let
  compose subs n t = let
    t2 = applySubs subs t
    in case (has n subs) of
      False -> set n t2 (mapRecord (substitute n t2) subs)
      True -> let
        msubs = unify (get n subs) t2
        in composeSubs subs msubs
  in foldRecord compose sa sb

unify a b = let
  bind n t = case t of
    TVar _ m -> case (n == m) of
      True -> empty
      False -> set n t empty
    _ -> case (contains n (freeTVars t)) of
      True -> let
        _ = 13//debug (printType a)
        //_ = debug (printType b)
        in error 'occurs check failed'
      False -> set n t empty
  err a b = error
    ('cannot unify ' ++ printType a ++ ' with ' ++ printType b)
  in case a of
    TVar _ v -> bind v b
    TConst _ ca -> case b of
      TConst _ cb -> case (ca == cb) of
        True -> empty
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TUnknown _ -> err a b
    TBot -> err a b
    TApp _ fa xa -> case b of
      TVar _ v -> bind v a
      TApp _ fb xb -> let
        fsubs = unify fa fb
        xsubs = unify (applySubs fsubs xa) (applySubs fsubs xb)
        in composeSubs fsubs xsubs
      _ -> err a b

freeTVars t = case t of
  TVar _ v -> arr1 v
  TBot -> emptyArray
  TUnknown _ -> emptyArray
  TConst _ c -> emptyArray
  TForall _ v t -> filter (\n -> n /= v) (freeTVars t)
  TApp _ f a -> mergeSet (freeTVars f) (freeTVars a)

infer env ctx e = let
  inferCase env cps p = case cps of
    Pair ctx (Pair te ps) -> case p of
      Pair pat e -> case (inferPat env ctx te pat) of
        Pair (ICtx subs i) bs -> let
          te2 = applySubs subs te
          bs2 = mapRecord (applySubs subs) bs
          in case (infer (merge env bs2) (ICtx subs i) e) of
            Pair ctx2 e2 -> Pair ctx2 (Pair te2 (push (Pair pat e2) ps))
  inferPat env ctx te pat = case pat of
    PVar _ v -> case (newTVar ctx) of
      Pair (ICtx subs i) tv -> let
        usubs = unify te tv
        subs2 = composeSubs subs usubs
        in Pair (ICtx subs2 i) (set v (applySubs subs2 tv) empty)
    PConst _ (CNum n) -> case ctx of
      ICtx subs i -> let
        usubs = unify te (TConst emptyAnn 'Number')
        subs2 = composeSubs subs usubs
        in Pair (ICtx subs2 i) empty
    PConst _ (CStr s) -> case ctx of
      ICtx subs i -> let
        usubs = unify te (TConst emptyAnn 'String')
        subs2 = composeSubs subs usubs
        in Pair (ICtx subs2 i) empty
    PData _ n ps -> case (has n env) of
      False -> error ('unknown data type ' ++ n)
      True -> case (instantiate ctx (get n env)) of
        Pair ctx2 t -> case (unrollDataConType t) of
          Pair tps dt -> case (length ps == length tps) of
            False -> error 'number of pattern params does not match the number of constructor params'
            True -> case (foldl (inferSubPat env) (Pair ctx2 empty) (zip ps tps)) of
              Pair (ICtx subs i) bs -> let
                usubs = unify te (applySubs subs dt)
                subs2 = composeSubs subs usubs
                in Pair (ICtx subs2 i) (mapRecord (applySubs subs2) bs)
  inferSubPat env cbs pt = case cbs of
    Pair ctx bs -> case pt of
      Pair pat t -> case (inferPat env ctx t pat) of
        Pair ctx2 bs2 -> Pair ctx2 (merge bs bs2)
  in case e of
    Const _ (CNum n) -> Pair ctx (setType (TConst emptyAnn 'Number') e)
    Const _ (CStr s) -> Pair ctx (setType (TConst emptyAnn 'String') e)
    Var _ v -> case (has v env) of
      False -> error ('no var ' ++ v ++ ' in environment')
      True -> case (instantiate ctx (get v env)) of
        Pair ctx2 t -> Pair ctx2 (setType t e)
    Lam ann p a -> case (newTVar ctx) of
      Pair ctx2 tv -> case (infer (set p tv env) ctx2 a) of
        Pair (ICtx subs i) a2 ->
          Pair
            (ICtx subs i)
            (setType (TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') (applySubs subs tv)) (getType a2)) (Lam ann p a2))
    App ann f a -> case (newTVar ctx) of
      Pair ctx2 tv -> case (infer env ctx2 f) of
        Pair (ICtx subs i) f2 -> case (infer (applySubsEnv subs env) (ICtx subs i) a) of
          Pair (ICtx subs2 i2) a2 -> let
            tf = applySubs subs2 (getType f2)
            synth = f1 (getType a2) tv
            //_ = debug (printType tf)
            //_ = debug (printType synth)
            usubs = unify tf synth
            subs3 = composeSubs subs2 usubs
            t = applySubs subs3 tv
            in Pair (ICtx subs3 i2) (setType t (App ann f2 a2))
    Case ann e ps -> case (infer env ctx e) of
      Pair ctx2 e2 -> case (foldl (inferCase env) (Pair ctx2 (Pair (getType e2) emptyArray)) ps) of
        Pair (ICtx subs i) (Pair te ps2) -> let
          t = getType (snd (head ps2))
          subs2 = foldl composeSubs subs (map (\p -> unify t (getType (snd p))) ps2)
          in Pair (ICtx subs2 i) (setType (applySubs subs2 t) (Case ann (setType te e2) ps2))
    Let ann ds e -> case (inferDefs env ctx ds) of
      Pair ctx2 ds2 -> let
        env2 = foldl (\env d -> case d of Pair n e -> set n (getType e) env) env ds2
        //_ = debug (mapRecord printType env2)
        in case (infer env2 ctx2 e) of
          Pair ctx3 e2 -> Pair ctx3 (setType (getType e2) (Let ann ds2 e2))
    _ -> error 'type inference not supported for this AST node'

inferType env ctx e = case (infer env ctx e) of
  Pair (ICtx subs i) e2 -> applySubsE subs e2

inferSccDefs env ctx ds = let
  generateTVar ce d = case ce of
    Pair ctx env -> case d of
      Pair n _ -> case (newTVar ctx) of
        Pair ctx2 tv -> Pair ctx2 (set n tv env)
  inferDef env cds d = case cds of
    Pair ctx ds -> case d of
      Pair n e ->
        //_ = debug ('inferring for binding ' ++ n)
        //_ = debug (mapRecord printType env)
        //_ = debug (case ctx of ICtx subs _ -> mapRecord printType subs)
        case (infer env ctx e) of
          Pair ctx2 e2 -> Pair ctx2 (push (Pair n e2) ds)
  unifyDef env d = case d of
    Pair n e -> unify (getType e) (get n env)
  generalizeDef env subs d = case d of
    Pair n e -> Pair n (setType (generalize env subs (getType e)) e)
  in case (foldl generateTVar (Pair ctx env) ds) of
    Pair ctx2 env2 -> case (foldl (inferDef env2) (Pair ctx2 emptyArray) ds) of
      Pair (ICtx subs i) ds2 -> let
        dsSubs = map (unifyDef env2) ds2
        subs2 = foldl composeSubs subs dsSubs
        ds3 = map (applySubsDef subs2) ds2
        //_ = debug (mapRecord printType subs2)
        // NOTE: generalizing with env *without* the bindings being generalized.
        ds4 = map (generalizeDef env subs2) ds3
        //_ = debug ('inferred ' ++ jsonStringify (map (\d -> case d of Pair n e -> Pair n (printType (getType e))) ds4))
        in Pair (ICtx subs2 i) ds4
        
inferDefs env ctx ds = let
  ns = map fst ds
  g = foldl (\g d -> case d of Pair n e -> set n (filter (\v -> contains v ns && (v /= n)) (freeVars e)) g) empty ds
  ccs = scc g
  //_ = debug g
  //_ = debug ccs
  infer cr cc = case cr of
    Pair ctx rs -> case (inferSccDefs (foldl (\env r -> set (fst r) (getType (snd r)) env) env rs) ctx (filter (\d -> contains (fst d) cc) ds)) of
      Pair ctx2 ds -> Pair ctx2 (concat rs ds)
  in foldl infer (Pair ctx emptyArray) ccs

checkSubs subs = let
  rhs = foldRecord (\rs _ t -> concat rs (freeTVars t)) emptyArray subs
  check _ v _ = case (contains v rhs) of
    True -> error ('tvar ' ++ v ++ ' appears both at LHS and RHS of subs')
    False -> True
  in foldRecord check True subs

generalize env subs t = let
  freeTVarsInEnv = foldRecord (\vs _ t -> concat vs (freeTVars t)) emptyArray env
  tvarsSubstitutingForEnvTVars = let
    f rs v t = case (contains v freeTVarsInEnv) of
      False -> rs
      True -> concat rs (freeTVars t)
    in foldRecord f emptyArray subs
  //_ = debug freeTVarsInEnv
  //_ = debug tvarsSubstitutingForEnvTVars
  nonFree = concat freeTVarsInEnv tvarsSubstitutingForEnvTVars
  vs = filter (\v -> not (contains v nonFree)) (freeTVars t)
  in foldr (\t v -> TForall emptyAnn v t) t vs

// a -> (b -> (c -> Foo a b c))
unrollDataConType t = case t of
  TApp _ (TApp _ (TConst _ '->') a) b -> case (unrollDataConType b) of
    Pair ps t -> Pair (enqueue a ps) t
  _ -> Pair emptyArray t

applySubsDef subs d = case d of
  Pair n e -> Pair n (applySubsE subs e)

applySubsE subs e = let
    applySubsCase p = case p of
      Pair pat e -> Pair pat (applySubsE subs e)
  in case e of
    Var (Ann t) v -> Var (Ann (applySubs subs t)) v
    Const (Ann t) c -> Const (Ann (applySubs subs t)) c
    App (Ann t) f a -> App (Ann (applySubs subs t)) (applySubsE subs f) (applySubsE subs a)
    Lam (Ann t) p b -> Lam (Ann (applySubs subs t)) p (applySubsE subs b)
    Case (Ann t) e ps -> Case (Ann (applySubs subs t)) (applySubsE subs e) (map applySubsCase ps)
    Let (Ann t) ds e -> Let (Ann (applySubs subs t)) (map (applySubsDef subs) ds) (applySubsE subs e)

setType t e = case e of
  Var (Ann x) v -> Var (Ann t) v
  Const (Ann x) c -> Const (Ann t) c
  App (Ann x) f a -> App (Ann t) f a
  Lam (Ann x) p b -> Lam (Ann t) p b
  Case (Ann x) e ps -> Case (Ann t) e ps
  Let (Ann x) ds e -> Let (Ann t) ds e

getType e = case e of
  Var (Ann t) v -> t
  Const (Ann t) c -> t
  App (Ann t) f a -> t
  Lam (Ann t) p b -> t
  Case (Ann t) e ps -> t
  Let (Ann t) ds e -> t

scc g = let
  //_ = debug 'commencing SCC'
  dfs i pre g visited v = let
    //_ = debug i
    visit r e = concat (dfs (i + 1) pre g (push v (concat r visited)) e) r
    es = filter (\v -> not (contains v visited)) (get v g)
    r = foldr visit emptyArray es
    in case pre of
      True -> enqueue v r
      False -> push v r
  fullDfs pre g = let
    //_ = debug g
    visit result v _ = case (contains v result) of
      True -> result
      False -> case pre of
        False -> concat result (dfs 0 pre g result v)
        True -> concat (dfs 0 pre g result v) result
    result = foldRecord visit emptyArray g
    in result
  invertedG = let
    invertEdge v ig e = case (has e ig) of
      True -> set e (push v (get e ig)) ig
      False -> set e (arr1 v) ig
    invert ig v es = let
      ig2 = case (has v ig) of
        True -> ig
        False -> set v emptyArray ig
      in foldl (invertEdge v) ig2 es
    in foldRecord invert empty g
  //_ = debug 'computed the inverse of the graph'
  assembleCc gs v = case gs of
    Pair ig ccs -> case (exists (contains v) ccs) of
      True -> Pair ig ccs
      False -> let
        cc = dfs 0 False ig emptyArray v
        ig2 = foldl (\g v -> del v (mapRecord (filter (\w -> w /= v)) g)) ig cc
        in Pair ig2 (push cc ccs)
  topSort ccs = let
    g2g = let
      f r icc = case icc of
        Pair i cc -> foldl (\r c -> set c (intToString i) r) r cc
      in foldl f empty (zipWithIndex ccs)
    addGraph r v es = let
      rv = get v g2g
      res = uniq (sort (filter (\re -> re /= rv) (map (\e -> get e g2g) es)))
      in case (has rv r) of
        False -> set rv res r
        True -> set rv (mergeSet res (get rv r)) r
    cg = foldRecord addGraph empty g
    ord = fullDfs True cg
    //_ = debug ccs
    //_ = debug cg
    //_ = debug g2g
    //_ = debug ord
    in reverse (map (\i -> getIx (unsafeStringToInt i) ccs) ord)
  firstDfs = fullDfs False g
  //_ = debug 'computed the first DFS'
  ccs = snd (foldr assembleCc (Pair invertedG emptyArray) firstDfs)
  //_ = debug 'computed the SCC'
  result = topSort ccs
  //_ = debug 'computed the topological sort'
  in result

freeVars e = let
  freeVarsInPat p = case p of
    Pair pat e ->
      mergeSet
        (filter (\v -> not (contains v (namesInPat pat))) (freeVars e))
        (freeVarsInPData pat)
  freeVarsInPData p = case p of
    PData _ n ps -> foldl mergeSet (arr1 n) (map freeVarsInPData ps)
    _ -> emptyArray
  namesInPat p = case p of
    PVar _ v -> arr1 v
    PConst _ c -> emptyArray
    PData _ n ps -> foldl mergeSet emptyArray (map namesInPat ps)
  in case e of
    Var _ v -> arr1 v
    Const _ c -> emptyArray
    App _ f x -> mergeSet (freeVars f) (freeVars x)
    Lam _ p b -> filter (\v -> v /= p) (freeVars b)
    Case _ e ps -> foldl mergeSet (freeVars e) (map freeVarsInPat ps)
    Let _ ds e -> filter (\v -> not (contains v (map fst ds))) (foldl mergeSet (freeVars e) (map (\d -> freeVars (snd d)) ds))

inferTypeModule ms m = let
  addImports env i = case i of
    ImportAll _ f -> merge env (get f ms)
    ImportOpen _ f ns -> foldl (\env n -> set n (get n (get f ms)) env) env ns
    _ -> error 'import type not supported in type inference'
  addTypes env dt = foldl (\env c -> case c of Pair n t -> set n t env) env (conTypes dt)
  in case m of
    Module ann is ts ds -> let
      env = foldl addImports (get './builtins.js' ms) is
      env2 = foldl addTypes env ts
      //_ = debug (mapRecord printType env2)
      ds2 = snd (inferDefs env2 newCtx ds)
      in Module ann is ts ds2

conTypes d = case d of
  Data _ n vs cs -> map (conType n vs) cs

conType dn tvs c = case c of
  DataCon _ n ts -> Pair n (forall tvs (foldr (\b a -> f1 a b) (foldl (\r v -> TApp emptyAnn r (TVar emptyAnn v)) (TConst emptyAnn dn) tvs) ts))

forall tvs t = foldl (\t tv -> TForall emptyAnn tv t) t tvs

getTypedExports m = case m of
  Module _ _ ts ds -> let
    et = concatMap conTypes ts
    ed = map (\d -> Pair (fst d) (getType (snd d))) ds
    in foldl (\es e -> set (fst e) (snd e) es) empty (concat et ed)
