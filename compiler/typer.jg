import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType, printTypeBound, reallyPrintExpr} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'

getSafe k r = case (has k r) of
  False -> error ('no ' ++ k ++ ' in record ' ++ jsonStringify r)
  True -> get k r

// --------------- Subs -------------------------------

data Subs = Subs (Map String Type) (Map String Type)

getSub v subs = case subs of
  Subs sat unsat -> lookup v sat <|> lookup v unsat

emptySubs = Subs Empty Empty

composeSubs ef sa sb = case sb of
  Subs sat unsat -> foldTrie (\r v t -> addSub ef v t r) (foldTrie (\r v t -> addSatSub ef v t r) sa sat) unsat

addSub ef v t subs = let
  t2 = applySubs subs t
  in case (getSub v subs) of
    Nothing -> case subs of
      Subs sat unsat -> let
        subUnsat su uv ut = case su of
          Pair sat unsat -> let
            ut2 = substitute v t2 ut
            in case (isEmpty (freeTVars ut2)) of
              True -> Pair (insert uv ut2 sat) unsat
              False -> Pair sat (insert uv ut2 unsat)
        su = foldTrie subUnsat (Pair sat Empty) unsat
        sat2 = fst su
        unsat2 = snd su
        in case (isEmpty (freeTVars t2)) of
          True -> Subs (insert v t2 sat2) unsat2
          False -> Subs sat2 (insert v t2 unsat2)
    Just subT -> composeSubs ef subs (unify ef subT t2)

addSatSub ef v t subs = case (getSub v subs) of
  Nothing -> case subs of
    Subs sat unsat -> let
      subUnsat su uv ut = case su of
        Pair sat unsat -> let
          ut2 = substitute v t ut
          in case (isEmpty (freeTVars ut2)) of
            True -> Pair (insert uv ut2 sat) unsat
            False -> Pair sat (insert uv ut2 unsat)
      su = foldTrie subUnsat (Pair sat Empty) unsat
      sat2 = fst su
      unsat2 = snd su
      in Subs (insert v t sat2) unsat2
  Just subT -> composeSubs ef subs (unify ef subT t)

dropSubs vs subs = case subs of
  Subs sat unsat -> Subs (foldl (\r v -> remove v r) sat vs) (foldl (\r v -> remove v r) unsat vs)

// -------------- Context -----------------------------

data InferenceContext = ICtx Subs (Array TypeBound) Number (String -> String)

newTVar ctx = case ctx of
  ICtx subs bs i e -> let
    n = '$' ++ intToString i
    in Pair (ICtx subs bs (i + 1) e) (TVar emptyAnn n)

newTVarM = gets >>= \ctx -> case ctx of
  ICtx subs bs i e -> let
    n = '$' ++ intToString i
    in sets (ICtx subs bs (i + 1) e) >> ret (TVar emptyAnn n)

newCtx = ICtx emptySubs emptyArray 1 (\s -> 'unknown error context: ' ++ s)

getSubs ctx = case ctx of
  ICtx subs _ _ _ -> subs

setSubs subs ctx = case ctx of
  ICtx _ bs i e -> ICtx subs (map (applySubsBound subs) bs) i e

addBound b ctx = case ctx of
  ICtx subs bs i e -> ICtx subs (push b bs) i e

getBounds ctx = case ctx of
  ICtx _ bs _ _ -> bs

setBounds bs ctx = case ctx of
  ICtx subs _ i e -> ICtx subs bs i e

errorM s = gets >>= \ctx -> case ctx of
  ICtx _ _ _ e -> error (e s)

onError e = gets >>= \ctx -> case ctx of
  ICtx subs bs i _ -> sets (ICtx subs bs i e)

withError e f = getErrorF >>= \old -> onError e >> f >>= \r -> onError old >> ret r

getErrorF = gets >>= \ctx -> case ctx of
  ICtx _ _ _ e -> ret e

// -------------- Environment -------------------------

data InferenceEnvironment = IEnv (Record Type) (Array TypeBound) (Map String Unit)

emptyEnv = IEnv empty emptyArray emptySet

getBinding n env = case env of
  IEnv bs _ _ -> getSafe n bs

getBindingM n env = gets >>= \ctx -> ret $ applySubs (getSubs ctx) (getBinding n env)

getBindings env = case env of
  IEnv bs _ _ -> bs

hasBinding n env = case env of
  IEnv bs _ _ -> has n bs

addBinding n t env = case env of
  IEnv bs ts fvs -> IEnv (set n t bs) ts (setUnion fvs (freeTVars t))

addBindings nbs env = case env of
  IEnv bs ts fvs -> IEnv (merge bs nbs) ts (foldRecord (\fvs _ t -> setUnion fvs (freeTVars t)) fvs nbs)

freeTVarsInEnv env = case env of
  IEnv _ _ fvs -> fvs

addInstance b env = case env of
  IEnv bs ts fvs -> IEnv bs (push b ts) fvs

getInstances env = case env of
  IEnv _ ts _ -> ts

// ------------ Inference Engine ----------------------

f1 a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

mkTForall ann vs bs t = let
  f bs b = case (exists (equivBound b) bs) of
    True -> bs
    False -> push b bs
  in TForall ann vs (foldl f emptyArray bs) t

instantiate t = gets >>= \ctx -> let
  mkvar cs v = case cs of
    Pair ctx subs -> case (newTVar ctx) of
      Pair ctx2 tv -> Pair ctx2 (addSub (\s -> 'instantiate: ' ++ s) v tv subs)
  in case t of
    TForall _ vs bs t -> case (foldl mkvar (Pair ctx emptySubs) vs) of
      Pair ctx2 subs -> let
        t2 = applySubs subs t
        bs2 = map (applySubsBound subs) bs
        ctx3 = foldl (\ctx b -> addBound b ctx) ctx2 bs2
        in sets ctx3 >> ret t2
    _ -> ret t

substitute n s t = applySubs (addSub (\s -> 'substitute: ' ++ s) n s emptySubs) t

applySubs subs t = case t of
  TForall ann vs bs t -> let
    subs2 = dropSubs vs subs
    in mkTForall ann vs (map (applySubsBound subs2) bs) (applySubs subs2 t)
  TVar _ v -> case (getSub v subs) of
    Nothing -> t
    Just subT -> subT
  TApp ann f a -> TApp ann (applySubs subs f) (applySubs subs a)
  _ -> t

applySubsBound subs b = case b of
  TCBound ann n t -> TCBound ann n (applySubs subs t)

unifyM a b = gets >>= \ctx -> getErrorF >>= \ef -> sets (setSubs (composeSubs ef (getSubs ctx) (unify ef a b)) ctx)

unify ef a b = let
  bind n t = case t of
    TVar _ m -> case (n == m) of
      True -> emptySubs
      False -> addSub ef n t emptySubs
    _ -> case (setContains n (freeTVars t)) of
      True ->
        //debug (printType a)
        //_ = debug (printType b)
        error (ef 'occurs check failed')
      False -> addSub ef n t emptySubs
  err a b = error
    (ef ('cannot unify ' ++ printType a ++ ' with ' ++ printType b))
  in case a of
    TVar _ v -> bind v b
    TConst _ ca -> case b of
      TConst _ cb -> case (ca == cb) of
        True -> emptySubs
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TUnknown -> err a b
    TBot -> err a b
    TApp _ fa xa -> case b of
      TVar _ v -> bind v a
      TApp _ fb xb -> let
        fsubs = unify ef fa fb
        xsubs = unify ef (applySubs fsubs xa) (applySubs fsubs xb)
        in composeSubs ef fsubs xsubs
      _ -> err a b
    _ -> err a b

freeTVars t = case t of
  TVar _ v -> setAdd v emptySet
  TBot -> emptySet
  TUnknown -> emptySet
  TConst _ c -> emptySet
  TForall _ vs bs t -> 
    foldl (\s v -> setRemove v s) (foldl setUnion (freeTVars t) (map freeTVarsInBound bs)) vs
  TApp _ f a -> setUnion (freeTVars f) (freeTVars a)

freeTVarsInBound b = case b of
  TCBound _ _ t -> freeTVars t

withLocError e f = case (getAnnCodeLoc (annOf e)) of
  Nothing -> f
  Just loc -> withError (\s -> s ++ ' ' ++ printCodeLoc loc) f

infer env e = let
  setFinalType t e = case (getType e) of
    TUnknown -> ret (setType t e)
    te -> unifyM t te >> ret e
  inferCase env te p = case p of
    Pair pat e -> inferPat env te pat >>= \cb -> case cb of
      Pair bs pat ->
        infer (addBindings bs env) e >>= \e ->
          ret (Pair pat e)
  inferPat env te pat = case pat of
    PVar ann v -> newTVarM >>= \tv ->
      unifyM te tv >>
        ret (Pair (set v tv empty) (PVar (setAnnType tv ann) v))
    PConst _ (CNum n) -> unifyM te (TConst emptyAnn 'Number') >> ret (Pair empty pat)
    PConst _ (CStr s) -> unifyM te (TConst emptyAnn 'String') >> ret (Pair empty pat)
    PData ann n ps -> case (hasBinding n env) of
      False -> error ('unknown data type ' ++ n)
      True -> (getBindingM n env >>= instantiate) >>= \t ->
        case (unrollDataConType t) of
          Pair tps dt -> case (length ps == length tps) of
            False -> errorM 'number of pattern params does not match the number of constructor params'
            True -> foldM (inferSubPat env) (Pair empty emptyArray) (zip ps tps) >>= \bps -> case bps of
              Pair bs ps ->
                unifyM te dt >>
                  (ret $ Pair bs (PData ann n ps))
  inferSubPat env bp pt = case bp of
    Pair bs ps -> case pt of
      Pair pat t -> inferPat env t pat >>= \bp -> case bp of
        Pair bs2 pat -> (ret $ Pair (merge bs bs2) (push pat ps))
  in withLocError e $ case e of
    Const _ (CNum n) -> setFinalType (TConst emptyAnn 'Number') e
    Const _ (CStr s) -> setFinalType (TConst emptyAnn 'String') e
    Var _ v -> case (hasBinding v env) of
      False -> errorM ('unknown identifier ' ++ v ++ ', env: ' ++ jsonStringify (keys $ getBindings env))
      True -> getBindingM v env >>= instantiate >>= \t -> setFinalType t e
    Lam ann p a -> newTVarM >>= \tv ->
      infer (addBinding p tv env) a >>= \a ->
        setFinalType (TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') tv) (getType a)) (Lam ann p a)
    App ann f a -> newTVarM >>= \tv ->
      infer env f >>= \f ->
        infer env a >>= \a -> let
          synth = f1 (getType a) tv
          in unifyM (getType f) synth >>
            setFinalType tv (App ann f a)
    Case ann e ps -> infer env e >>= \e ->
      mapM (inferCase env (getType e)) ps >>= \ps -> let
        t = getType (snd (head ps))
        in mapM (\p -> unifyM t (getType $ snd p)) (tail ps) >>
          setFinalType t (Case ann e ps)
    Let ann ds e -> inferDefs env ds >>= \ds -> let
      env2 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env ds
      in infer env2 e >>= \e ->
        setFinalType (getType e) (Let ann ds e)
    _ -> error 'type inference not supported for this AST node'

inferSccDefs env ds = let
  generateTVar env d = newTVarM >>= \tv -> ret (addBinding (fst d) tv env)
  inferDef env d = case d of
    Pair n e -> infer env e >>= \e -> ret (Pair n e)
  unifyDef env d = case d of
    Pair n e -> unifyM (getType e) (getBinding n env)
  generalizeDef env d = case d of
      Pair n e -> generalize env (getType e) >>= \t -> ret (Pair n (setType t e))
  in foldM generateTVar env ds >>= \env2 ->
    mapM (inferDef env2) ds >>= \ds2 ->
      mapM (unifyDef env2) ds2 >>
        mapM applySubsDef ds2 >>= \ds3 ->
          dropSatisfiedBounds env >>
            mapM (generalizeDef env) ds3

dropSatisfiedBounds env = gets >>= \ctx -> let
  is = getInstances env
  bs = getBounds ctx
  bs2 = filter (\b -> not (exists (\i -> satisfiesBound i b) is)) bs
  in sets (setBounds bs2 ctx)

inferDefs env ds = let
  ns = map fst ds
  g = foldl (\g d -> case d of Pair n e -> set n (filter (\v -> contains v ns && (v /= n)) (freeVars e)) g) empty ds
  ccs = sccSorted g
  infer rs cc = fmap (concat rs) (inferSccDefs (foldl (\env r -> addBinding (fst r) (getType (snd r)) env) env rs) (filter (\d -> contains (fst d) cc) ds))
  in foldM infer emptyArray ccs

generalize env t = gets >>= \ctx -> let
  subs = getSubs ctx
  envTVars = freeTVarsInEnv env
  nonFree = case subs of Subs _ unsat ->
    foldTrie (\s v _ -> setUnion s (justOr Empty (fmap freeTVars (lookup v unsat)))) envTVars envTVars
  vs = setDiff (freeTVars t) nonFree
  vbb = foldl processBounds (Pair emptySet (Pair emptyArray emptyArray)) (getBounds ctx)
  processBounds vbb b = case vbb of
    Pair bvs (Pair rbs obs) -> let
      boundVars = freeTVarsInBound b
      sharedVars = setIntersection boundVars vs
      in case (isEmpty sharedVars) of
        True -> Pair bvs (Pair rbs (push b obs))
        False -> case (size sharedVars == size boundVars) of
          True -> Pair bvs (Pair (push b rbs) obs)
          False -> Pair (setUnion bvs sharedVars) (Pair rbs (push b obs))
  in case vbb of
    Pair bvs (Pair rbs obs) -> let
      finalVars = setDiff vs bvs
      drop r v t = case (isEmpty $ setIntersection finalVars (freeTVars t)) of
        True -> insert v t r
        False -> r
      subs2 = case subs of
        Subs sat unsat -> Subs sat (foldTrie drop Empty unsat)
      in sets (setBounds obs (setSubs subs2 ctx)) >>
        case ((not $ isEmpty finalVars) || (length rbs > 0)) of
          True -> ret $ mkTForall emptyAnn (setToArray finalVars) rbs t
          False -> ret t

// a -> (b -> (c -> Foo a b c))
unrollDataConType t = case t of
  TApp _ (TApp _ (TConst _ '->') a) b -> case (unrollDataConType b) of
    Pair ps t -> Pair (enqueue a ps) t
  _ -> Pair emptyArray t

applySubsDef d = case d of
  Pair n e -> gets >>= \ctx -> ret $ Pair n (applySubsE (getSubs ctx) e)

applySubsE subs e = let
  f a e = let
    t2 = applySubs subs (getType e)
    in Pair a (setType t2 e)
  in snd (down f True e)

freeVars e = let
  freeVarsInPat p = case p of
    Pair pat e ->
      mergeSet
        (filter (\v -> not (contains v (namesInPat pat))) (freeVars e))
        (freeVarsInPData pat)
  freeVarsInPData p = case p of
    PData _ n ps -> foldl mergeSet (arr1 n) (map freeVarsInPData ps)
    _ -> emptyArray
  namesInPat p = case p of
    PVar _ v -> arr1 v
    PConst _ c -> emptyArray
    PData _ n ps -> foldl mergeSet emptyArray (map namesInPat ps)
  in case e of
    Var _ v -> arr1 v
    Const _ c -> emptyArray
    App _ f x -> mergeSet (freeVars f) (freeVars x)
    Lam _ p b -> filter (\v -> v /= p) (freeVars b)
    Case _ e ps -> foldl mergeSet (freeVars e) (map freeVarsInPat ps)
    Let _ ds e -> filter (\v -> not (contains v (map fst ds))) (foldl mergeSet (freeVars e) (map (\d -> freeVars (snd d)) ds))

inferInstance env cs i = let
  inferE e = case (runState newCtx $ infer env e) of
    Pair ctx e2 -> applySubsE (getSubs ctx) e2
  in case i of
    Instance ann n it ds -> case (find (\c -> case c of Class _ m _ _ -> n == m) cs) of
      Nothing -> error ('Cannot find clas ' ++ n)
      Just (Class _ _ v bs) -> let
        bs2 = foldl (\bs b -> case b of Pair n t -> set n (substitute v it t) bs) empty bs
        ds2 = map (\d -> case d of Pair dn e -> Pair dn (inferE (setType (getSafe dn bs2) e))) ds
        in Instance ann n it ds2

instanceToTypeBound i = case i of
  Instance _ n t _ -> TCBound emptyAnn n t

classToBindings c = case c of
  Class _ n tv bs -> let
    process b = case b of
      Pair v t -> let
        ftv = freeTVars t
        in case (setContains tv ftv) of
          False -> error ('invalid clas definition ' ++ n ++ ', binding ' ++ v)
          True -> Pair v (mkTForall emptyAnn (setToArray ftv) (arr1 (TCBound emptyAnn n (TVar emptyAnn tv))) t)
    in map process bs

inferTypeModule ms m = let
  getFile i = case i of
    ImportOpen _ f _ -> f
  addImports env i = case (getSafe (getFile i) ms) of
    ModuleInterface bs cs is -> let
      env2 = case i of
        ImportOpen _ f ns -> foldl (\env n -> case n of Pair n a -> addBinding a (getSafe n bs) env) env ns
      env3 = foldl addClass env2 cs
      env4 = foldl (\env i -> addInstance i env) env3 is
      in env4
  addTypes env dt = foldl (\env c -> case c of Pair n t -> addBinding n t env) env (conTypes dt)
  addClass env c = foldl (\env b -> addBinding (fst b) (snd b) env) env (classToBindings c)
  addIns env i = addInstance (instanceToTypeBound i) env
  checkForUnsatisfiedBounds d = case (getType (snd d)) of
    TForall _ _ bs t -> case t of
      TApp _ (TApp _ (TConst _ '->') _) _ -> d
      _ -> case (length bs) of
        0 -> d
        _ -> error ('unsatisfied bounds in def of ' ++ (fst d) ++ ' :: ' ++ printType (getType (snd d)))
    _ -> d
  in case m of
    Module ann fn is ts cs ins ds -> let
      //ds = let _ = debug $ intercalate '\n' (map (\d -> case d of Pair n e -> n ++ ' = ' ++ reallyPrintExpr False e) _ds) in _ds
      env = emptyEnv
      env2 = foldl addImports env is
      env3 = foldl addTypes env2 ts
      env4 = foldl addClass env3 cs
      env5 = foldl addIns env4 ins
      //_ = debugEnv env5
      ds2 = evalState newCtx (inferDefs env5 ds)
      //_2 = debug (map (\d -> printType (getType (snd d))) ds2)
      ds3 = map checkForUnsatisfiedBounds ds2
      env6 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env5 ds3
      ins2 = map (inferInstance env6 (concat cs (concatMap (\i -> case (getSafe (getFile i) ms) of ModuleInterface _ cs _ -> cs) is))) ins
      in Module ann fn is ts cs ins2 ds3

conTypes d = case d of
  Data _ n vs cs -> map (conType n vs) cs

conType dn tvs c = case c of
  DataCon _ n ts -> Pair n (mkTForall emptyAnn tvs emptyArray (foldr (\b a -> f1 a b) (foldl (\r v -> TApp emptyAnn r (TVar emptyAnn v)) (TConst emptyAnn dn) tvs) ts))

getTypedExports m = case m of
  Module _ _ _ ts cs ins ds -> let
    et = concatMap conTypes ts
    ed = map (\d -> Pair (fst d) (getType (snd d))) ds
    bs = foldl (\es e -> set (fst e) (snd e) es) empty (concat et ed)
    in ModuleInterface bs cs (map instanceToTypeBound ins)

satisfies a b = case a of
  TVar _ _ -> True
  TConst _ c -> case b of
    TConst _ c2 -> c == c2
    _ -> False
  TApp _ fa xa -> case b of
    TApp _ fb xb -> satisfies fa fb && satisfies xa xb
    _ -> False
  _ -> error ('unexpected type in satisfies ' ++ printType a)

satisfiesBound a b = case a of
  TCBound _ na ta -> case b of
    TCBound _ nb tb -> na == nb && satisfies ta tb
