import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'

// -------------- Context -----------------------------

data InferenceContext = ICtx (Record Type) Number

newTVar ctx = case ctx of
  ICtx subs i -> let
    n = '$' ++ intToString i
    in Pair (ICtx subs (i + 1)) (TVar emptyAnn n)

newCtx = ICtx empty 1

getSubs ctx = case ctx of
  ICtx subs i -> subs

setSubs subs ctx = case ctx of
  ICtx _ i -> ICtx subs i

// -------------- Environment -------------------------

data InferenceEnvironment = IEnv (Record Type) (Array TypeBound)

getBinding n env = case env of
  IEnv bs _ -> get n bs

hasBinding n env = case env of
  IEnv bs _ -> has n bs

addBinding n t env = case env of
  IEnv bs ts -> IEnv (set n t bs) ts

addBindings nbs env = case env of
  IEnv bs ts -> IEnv (merge bs nbs) ts

applySubsEnv subs env = case env of
  IEnv bs ts -> IEnv (mapRecord (applySubs subs) bs) ts

freeTVarsInEnv env = case env of
  IEnv bs _ -> foldRecord (\vs _ t -> concat vs (freeTVars t)) emptyArray bs

emptyEnv = IEnv empty emptyArray

// ------------ Inference Engine ----------------------

f1 a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

instantiate ctx t = let
  mkvar cs v = case cs of
    Pair ctx subs -> case (newTVar ctx) of
      Pair ctx2 tv -> Pair ctx2 (set v tv subs)
  in case t of
    TForall _ vs bs t -> case (foldl mkvar (Pair ctx empty) vs) of
      Pair ctx2 subs -> Pair ctx2 (applySubs subs t)
    _ -> Pair ctx t

substitute n s t = applySubs (set n s empty) t

applySubs subs t = case t of
  TForall ann vs bs t -> let
    subs2 = foldl (\s v -> del v s) subs vs
    in TForall ann vs (map (applySubsBound subs2) bs) (applySubs subs2 t)
  TVar _ v -> case (has v subs) of
    False -> t
    True -> get v subs
  TApp ann f a -> TApp ann (applySubs subs f) (applySubs subs a)
  _ -> t

applySubsBound subs b = case b of
  TCBound ann n t -> TCBound ann n (applySubs subs t)

composeSubs sa sb = let
  compose subs n t = let
    t2 = applySubs subs t
    in case (has n subs) of
      False -> set n t2 (mapRecord (substitute n t2) subs)
      True -> let
        msubs = unify (get n subs) t2
        in composeSubs subs msubs
  in foldRecord compose sa sb

unify a b = let
  bind n t = case t of
    TVar _ m -> case (n == m) of
      True -> empty
      False -> set n t empty
    _ -> case (contains n (freeTVars t)) of
      True -> let
        _ = 13//debug (printType a)
        //_ = debug (printType b)
        in error 'occurs check failed'
      False -> set n t empty
  err a b = error
    ('cannot unify ' ++ printType a ++ ' with ' ++ printType b)
  in case a of
    TVar _ v -> bind v b
    TConst _ ca -> case b of
      TConst _ cb -> case (ca == cb) of
        True -> empty
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TUnknown _ -> err a b
    TBot -> err a b
    TApp _ fa xa -> case b of
      TVar _ v -> bind v a
      TApp _ fb xb -> let
        fsubs = unify fa fb
        xsubs = unify (applySubs fsubs xa) (applySubs fsubs xb)
        in composeSubs fsubs xsubs
      _ -> err a b

freeTVars t = case t of
  TVar _ v -> arr1 v
  TBot -> emptyArray
  TUnknown _ -> emptyArray
  TConst _ c -> emptyArray
  TForall _ vs bs t -> let
    freeTVarInBound ftv b = case b of
      TCBound _ _ t -> mergeSet ftv (freeTVars t)
    in filter (\n -> not (contains n vs)) (foldl freeTVarInBound (freeTVars t) bs)
  TApp _ f a -> mergeSet (freeTVars f) (freeTVars a)

infer env ctx e = let
  inferCase env cps p = case cps of
    Pair ctx (Pair te ps) -> case p of
      Pair pat e -> case (inferPat env ctx te pat) of
        Pair ctx2 bs -> let
          subs = getSubs ctx2
          te2 = applySubs subs te
          bs2 = mapRecord (applySubs subs) bs
          in case (infer (addBindings bs2 env) ctx2 e) of
            Pair ctx2 e2 -> Pair ctx2 (Pair te2 (push (Pair pat e2) ps))
  inferPat env ctx te pat = case pat of
    PVar _ v -> case (newTVar ctx) of
      Pair ctx2 tv -> let
        usubs = unify te tv
        subs2 = composeSubs (getSubs ctx2) usubs
        in Pair (setSubs subs2 ctx2) (set v (applySubs subs2 tv) empty)
    PConst _ (CNum n) -> let
      usubs = unify te (TConst emptyAnn 'Number')
      subs2 = composeSubs (getSubs ctx) usubs
      in Pair (setSubs subs2 ctx) empty
    PConst _ (CStr s) -> let
      usubs = unify te (TConst emptyAnn 'String')
      subs2 = composeSubs (getSubs ctx) usubs
      in Pair (setSubs subs2 ctx) empty
    PData _ n ps -> case (hasBinding n env) of
      False -> error ('unknown data type ' ++ n)
      True -> case (instantiate ctx (getBinding n env)) of
        Pair ctx2 t -> case (unrollDataConType t) of
          Pair tps dt -> case (length ps == length tps) of
            False -> error 'number of pattern params does not match the number of constructor params'
            True -> case (foldl (inferSubPat env) (Pair ctx2 empty) (zip ps tps)) of
              Pair ctx3 bs -> let
                usubs = unify te (applySubs (getSubs ctx3) dt)
                subs = composeSubs (getSubs ctx3) usubs
                in Pair (setSubs subs ctx3) (mapRecord (applySubs subs) bs)
  inferSubPat env cbs pt = case cbs of
    Pair ctx bs -> case pt of
      Pair pat t -> case (inferPat env ctx t pat) of
        Pair ctx2 bs2 -> Pair ctx2 (merge bs bs2)
  in case e of
    Const _ (CNum n) -> Pair ctx (setType (TConst emptyAnn 'Number') e)
    Const _ (CStr s) -> Pair ctx (setType (TConst emptyAnn 'String') e)
    Var _ v -> case (hasBinding v env) of
      False -> error ('no var ' ++ v ++ ' in environment')
      True -> case (instantiate ctx (getBinding v env)) of
        Pair ctx2 t -> Pair ctx2 (setType t e)
    Lam ann p a -> case (newTVar ctx) of
      Pair ctx2 tv -> case (infer (addBinding p tv env) ctx2 a) of
        Pair ctx3 a2 ->
          Pair
            ctx3
            (setType (TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') (applySubs (getSubs ctx3) tv)) (getType a2)) (Lam ann p a2))
    App ann f a -> case (newTVar ctx) of
      Pair ctx2 tv -> case (infer env ctx2 f) of
        Pair ctx3 f2 -> case (infer (applySubsEnv (getSubs ctx3) env) ctx3 a) of
          Pair ctx4 a2 -> let
            subs2 = getSubs ctx4
            tf = applySubs subs2 (getType f2)
            synth = f1 (getType a2) tv
            //_ = debug (printType tf)
            //_ = debug (printType synth)
            usubs = unify tf synth
            subs3 = composeSubs subs2 usubs
            t = applySubs subs3 tv
            in Pair (setSubs subs3 ctx4) (setType t (App ann f2 a2))
    Case ann e ps -> case (infer env ctx e) of
      Pair ctx2 e2 -> case (foldl (inferCase env) (Pair ctx2 (Pair (getType e2) emptyArray)) ps) of
        Pair ctx3 (Pair te ps2) -> let
          t = getType (snd (head ps2))
          subs = foldl composeSubs (getSubs ctx3) (map (\p -> unify t (getType (snd p))) ps2)
          in Pair (setSubs subs ctx3) (setType (applySubs subs t) (Case ann (setType te e2) ps2))
    Let ann ds e -> case (inferDefs env ctx ds) of
      Pair ctx2 ds2 -> let
        env2 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env ds2
        //_ = debug (mapRecord printType env2)
        in case (infer env2 ctx2 e) of
          Pair ctx3 e2 -> Pair ctx3 (setType (getType e2) (Let ann ds2 e2))
    _ -> error 'type inference not supported for this AST node'

inferType env ctx e = case (infer env ctx e) of
  Pair ctx e2 -> applySubsE (getSubs ctx) e2

inferSccDefs env ctx ds = let
  generateTVar ce d = case ce of
    Pair ctx env -> case d of
      Pair n _ -> case (newTVar ctx) of
        Pair ctx2 tv -> Pair ctx2 (addBinding n tv env)
  inferDef env cds d = case cds of
    Pair ctx ds -> case d of
      Pair n e ->
        //_ = debug ('inferring for binding ' ++ n)
        //_ = debug (mapRecord printType env)
        //_ = debug (case ctx of ICtx subs _ -> mapRecord printType subs)
        case (infer env ctx e) of
          Pair ctx2 e2 -> Pair ctx2 (push (Pair n e2) ds)
  unifyDef env d = case d of
    Pair n e -> unify (getType e) (getBinding n env)
  generalizeDef env subs d = case d of
    Pair n e -> Pair n (setType (generalize env subs (getType e)) e)
  in case (foldl generateTVar (Pair ctx env) ds) of
    Pair ctx2 env2 -> case (foldl (inferDef env2) (Pair ctx2 emptyArray) ds) of
      Pair ctx3 ds2 -> let
        subs = getSubs ctx3
        dsSubs = map (unifyDef env2) ds2
        subs2 = foldl composeSubs subs dsSubs
        ds3 = map (applySubsDef subs2) ds2
        subs3 = dropNonEnvSubs env subs2
        //_ = debug (mapRecord printType subs3)
        // NOTE: generalizing with env *without* the bindings being generalized.
        ds4 = map (generalizeDef env subs3) ds3
        //_ = debug ('inferred ' ++ jsonStringify (map (\d -> case d of Pair n e -> Pair n (printType (getType e))) ds4))
        in Pair (setSubs subs3 ctx3) ds4

dropNonEnvSubs env subs = let
  ftv = freeTVarsInEnv env
  drop subs v t = case (contains v ftv) of
    False -> subs
    True -> set v t subs
  in foldRecord drop empty subs

inferDefs env ctx ds = let
  ns = map fst ds
  g = foldl (\g d -> case d of Pair n e -> set n (filter (\v -> contains v ns && (v /= n)) (freeVars e)) g) empty ds
  ccs = sccSorted g
  //_ = debug g
  //_ = debug ccs
  infer cr cc = case cr of
    Pair ctx rs -> case (inferSccDefs (foldl (\env r -> addBinding (fst r) (getType (snd r)) env) env rs) ctx (filter (\d -> contains (fst d) cc) ds)) of
      Pair ctx2 ds -> Pair ctx2 (concat rs ds)
  in foldl infer (Pair ctx emptyArray) ccs

checkSubs subs = let
  rhs = foldRecord (\rs _ t -> concat rs (freeTVars t)) emptyArray subs
  check _ v _ = case (contains v rhs) of
    True -> error ('tvar ' ++ v ++ ' appears both at LHS and RHS of subs')
    False -> True
  in foldRecord check True subs

generalize env subs t = let
  envTVars = freeTVarsInEnv env
  tvarsSubstitutingForEnvTVars = let
    f rs v t = case (contains v envTVars) of
      False -> rs
      True -> concat rs (freeTVars t)
    in foldRecord f emptyArray subs
  //_ = debug freeTVarsInEnv
  //_ = debug tvarsSubstitutingForEnvTVars
  nonFree = concat envTVars tvarsSubstitutingForEnvTVars
  vs = filter (\v -> not (contains v nonFree)) (freeTVars t)
  in TForall emptyAnn vs emptyArray t

// a -> (b -> (c -> Foo a b c))
unrollDataConType t = case t of
  TApp _ (TApp _ (TConst _ '->') a) b -> case (unrollDataConType b) of
    Pair ps t -> Pair (enqueue a ps) t
  _ -> Pair emptyArray t

applySubsDef subs d = case d of
  Pair n e -> Pair n (applySubsE subs e)

applySubsE subs e = let
    applySubsCase p = case p of
      Pair pat e -> Pair pat (applySubsE subs e)
  in case e of
    Var (Ann t) v -> Var (Ann (applySubs subs t)) v
    Const (Ann t) c -> Const (Ann (applySubs subs t)) c
    App (Ann t) f a -> App (Ann (applySubs subs t)) (applySubsE subs f) (applySubsE subs a)
    Lam (Ann t) p b -> Lam (Ann (applySubs subs t)) p (applySubsE subs b)
    Case (Ann t) e ps -> Case (Ann (applySubs subs t)) (applySubsE subs e) (map applySubsCase ps)
    Let (Ann t) ds e -> Let (Ann (applySubs subs t)) (map (applySubsDef subs) ds) (applySubsE subs e)

setType t e = case e of
  Var (Ann x) v -> Var (Ann t) v
  Const (Ann x) c -> Const (Ann t) c
  App (Ann x) f a -> App (Ann t) f a
  Lam (Ann x) p b -> Lam (Ann t) p b
  Case (Ann x) e ps -> Case (Ann t) e ps
  Let (Ann x) ds e -> Let (Ann t) ds e

getType e = case e of
  Var (Ann t) v -> t
  Const (Ann t) c -> t
  App (Ann t) f a -> t
  Lam (Ann t) p b -> t
  Case (Ann t) e ps -> t
  Let (Ann t) ds e -> t

freeVars e = let
  freeVarsInPat p = case p of
    Pair pat e ->
      mergeSet
        (filter (\v -> not (contains v (namesInPat pat))) (freeVars e))
        (freeVarsInPData pat)
  freeVarsInPData p = case p of
    PData _ n ps -> foldl mergeSet (arr1 n) (map freeVarsInPData ps)
    _ -> emptyArray
  namesInPat p = case p of
    PVar _ v -> arr1 v
    PConst _ c -> emptyArray
    PData _ n ps -> foldl mergeSet emptyArray (map namesInPat ps)
  in case e of
    Var _ v -> arr1 v
    Const _ c -> emptyArray
    App _ f x -> mergeSet (freeVars f) (freeVars x)
    Lam _ p b -> filter (\v -> v /= p) (freeVars b)
    Case _ e ps -> foldl mergeSet (freeVars e) (map freeVarsInPat ps)
    Let _ ds e -> filter (\v -> not (contains v (map fst ds))) (foldl mergeSet (freeVars e) (map (\d -> freeVars (snd d)) ds))

inferTypeModule ms m = let
  getFile i = case i of
    ImportAll _ f -> f
    ImportOpen _ f _ -> f
    ImportClosed _ f _ -> f
  addImports env i = case (get (getFile i) ms) of
    ModuleInterface bs cs is -> case i of
      ImportAll _ f -> addBindings bs env
      ImportOpen _ f ns -> foldl (\env n -> addBinding n (get n bs) env) env ns
      _ -> error 'import type not supported in type inference'
  addTypes env dt = foldl (\env c -> case c of Pair n t -> addBinding n t env) env (conTypes dt)
  in case m of
    Module ann is ts cs ins ds -> let
      env = emptyEnv
      env2 = foldl addImports env (enqueue (ImportAll emptyAnn './builtins.js') is)
      env3 = foldl addTypes env2 ts
      //_ = debug (mapRecord printType env2)
      ds2 = snd (inferDefs env3 newCtx ds)
      in Module ann is ts cs ins ds2

conTypes d = case d of
  Data _ n vs cs -> map (conType n vs) cs

conType dn tvs c = case c of
  DataCon _ n ts -> Pair n (forall tvs (foldr (\b a -> f1 a b) (foldl (\r v -> TApp emptyAnn r (TVar emptyAnn v)) (TConst emptyAnn dn) tvs) ts))

forall tvs t = TForall emptyAnn tvs emptyArray t

getTypedExports m = case m of
  Module _ _ ts cs ins ds -> let
    et = concatMap conTypes ts
    ed = map (\d -> Pair (fst d) (getType (snd d))) ds
    bs = foldl (\es e -> set (fst e) (snd e) es) empty (concat et ed)
    in ModuleInterface bs emptyArray emptyArray
