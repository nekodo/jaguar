import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType, printTypeBound} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'

// -------------- Context -----------------------------

data InferenceContext = ICtx (Record Type) (Array TypeBound) Number

newTVar ctx = case ctx of
  ICtx subs bs i -> let
    n = '$' ++ intToString i
    in Pair (ICtx subs bs (i + 1)) (TVar emptyAnn n)

newCtx = ICtx empty emptyArray 1

getSubs ctx = case ctx of
  ICtx subs _ _ -> subs

setSubs subs ctx = case ctx of
  ICtx _ bs i -> ICtx subs (map (applySubsBound subs) bs) i

addBound b ctx = case ctx of
  ICtx subs bs i -> ICtx subs (push b bs) i

getBounds ctx = case ctx of
  ICtx _ bs _ -> bs

setBounds bs ctx = case ctx of
  ICtx subs _ i -> ICtx subs bs i

// -------------- Environment -------------------------

data InferenceEnvironment = IEnv (Record Type) (Array TypeBound)

getBinding n env = case env of
  IEnv bs _ -> get n bs

hasBinding n env = case env of
  IEnv bs _ -> has n bs

addBinding n t env = case env of
  IEnv bs ts -> IEnv (set n t bs) ts

addBindings nbs env = case env of
  IEnv bs ts -> IEnv (merge bs nbs) ts

applySubsEnv subs env = case env of
  IEnv bs ts -> IEnv (mapRecord (applySubs subs) bs) ts

freeTVarsInEnv env = case env of
  IEnv bs _ -> foldRecord (\vs _ t -> concat vs (freeTVars t)) emptyArray bs

emptyEnv = IEnv empty emptyArray

addInstance b env = case env of
  IEnv bs ts -> IEnv bs (push b ts)

getInstances env = case env of
  IEnv _ ts -> ts

debugEnv e = case e of
  IEnv bs ts -> let
    _ = debug (mapRecord printType bs)
    _2 = debug (map printTypeBound ts)
    in e

// ------------ Inference Engine ----------------------

f1 a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

instantiate ctx t = let
  mkvar cs v = case cs of
    Pair ctx subs -> case (newTVar ctx) of
      Pair ctx2 tv -> Pair ctx2 (set v tv subs)
  in case t of
    TForall _ vs bs t -> case (foldl mkvar (Pair ctx empty) vs) of
      Pair ctx2 subs -> let
        t2 = applySubs subs t
        bs2 = map (applySubsBound subs) bs
        ctx3 = foldl (\ctx b -> addBound b ctx) ctx2 bs2
        in Pair ctx3 t2
    _ -> Pair ctx t

substitute n s t = applySubs (set n s empty) t

applySubs subs t = case t of
  TForall ann vs bs t -> let
    subs2 = foldl (\s v -> del v s) subs vs
    in TForall ann vs (map (applySubsBound subs2) bs) (applySubs subs2 t)
  TVar _ v -> case (has v subs) of
    False -> t
    True -> get v subs
  TApp ann f a -> TApp ann (applySubs subs f) (applySubs subs a)
  _ -> t

applySubsBound subs b = case b of
  TCBound ann n t -> TCBound ann n (applySubs subs t)

composeSubs sa sb = let
  compose subs n t = let
    t2 = applySubs subs t
    in case (has n subs) of
      False -> set n t2 (mapRecord (substitute n t2) subs)
      True -> let
        msubs = unify (get n subs) t2
        in composeSubs subs msubs
  in foldRecord compose sa sb

unify a b = let
  bind n t = case t of
    TVar _ m -> case (n == m) of
      True -> empty
      False -> set n t empty
    _ -> case (contains n (freeTVars t)) of
      True -> let
        _ = 13//debug (printType a)
        //_ = debug (printType b)
        in error 'occurs check failed'
      False -> set n t empty
  err a b = error
    ('cannot unify ' ++ printType a ++ ' with ' ++ printType b)
  in case a of
    TVar _ v -> bind v b
    TConst _ ca -> case b of
      TConst _ cb -> case (ca == cb) of
        True -> empty
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TUnknown _ -> err a b
    TBot -> err a b
    TApp _ fa xa -> case b of
      TVar _ v -> bind v a
      TApp _ fb xb -> let
        fsubs = unify fa fb
        xsubs = unify (applySubs fsubs xa) (applySubs fsubs xb)
        in composeSubs fsubs xsubs
      _ -> err a b
    _ -> err a b

freeTVars t = case t of
  TVar _ v -> arr1 v
  TBot -> emptyArray
  TUnknown _ -> emptyArray
  TConst _ c -> emptyArray
  TForall _ vs bs t -> 
    filter (\n -> not (contains n vs)) (foldl mergeSet (freeTVars t) (map freeTVarsInBound bs))
  TApp _ f a -> mergeSet (freeTVars f) (freeTVars a)

freeTVarsInBound b = case b of
  TCBound _ _ t -> freeTVars t

infer env ctx e = let
  setFinalType ctx t e = case (getType e) of
    TUnknown _ -> Pair ctx (setType t e)
    te -> let
      subs = composeSubs (getSubs ctx) (unify t te)
      in Pair (setSubs subs ctx) e
  inferCase env cps p = case cps of
    Pair ctx (Pair te ps) -> case p of
      Pair pat e -> case (inferPat env ctx te pat) of
        Pair (Pair ctx2 bs) pat -> let
          subs = getSubs ctx2
          te2 = applySubs subs te
          bs2 = mapRecord (applySubs subs) bs
          in case (infer (addBindings bs2 env) ctx2 e) of
            Pair ctx2 e2 -> Pair ctx2 (Pair te2 (push (Pair pat e2) ps))
  inferPat env ctx te pat = case pat of
    PVar _ v -> case (newTVar ctx) of
      Pair ctx2 tv -> let
        usubs = unify te tv
        subs2 = composeSubs (getSubs ctx2) usubs
        tv2 = applySubs subs2 tv
        in Pair (Pair (setSubs subs2 ctx2) (set v tv2 empty)) (PVar (Ann tv2) v)
    PConst _ (CNum n) -> let
      usubs = unify te (TConst emptyAnn 'Number')
      subs2 = composeSubs (getSubs ctx) usubs
      in Pair (Pair (setSubs subs2 ctx) empty) pat
    PConst _ (CStr s) -> let
      usubs = unify te (TConst emptyAnn 'String')
      subs2 = composeSubs (getSubs ctx) usubs
      in Pair (Pair (setSubs subs2 ctx) empty) pat
    PData ann n ps -> case (hasBinding n env) of
      False -> error ('unknown data type ' ++ n)
      True -> case (instantiate ctx (getBinding n env)) of
        Pair ctx2 t -> case (unrollDataConType t) of
          Pair tps dt -> case (length ps == length tps) of
            False -> error 'number of pattern params does not match the number of constructor params'
            True -> case (foldl (inferSubPat env) (Pair (Pair ctx2 empty) emptyArray) (zip ps tps)) of
              Pair (Pair ctx3 bs) ps -> let
                usubs = unify te (applySubs (getSubs ctx3) dt)
                subs = composeSubs (getSubs ctx3) usubs
                in Pair (Pair (setSubs subs ctx3) (mapRecord (applySubs subs) bs)) (PData ann n ps)
  inferSubPat env cbp pt = case cbp of
    Pair (Pair ctx bs) ps -> case pt of
      Pair pat t -> case (inferPat env ctx t pat) of
        Pair (Pair ctx2 bs2) pat -> Pair (Pair ctx2 (merge bs bs2)) (push pat ps)
  in case e of
    Const _ (CNum n) -> setFinalType ctx (TConst emptyAnn 'Number') e
    Const _ (CStr s) -> setFinalType ctx (TConst emptyAnn 'String') e
    Var _ v -> case (hasBinding v env) of
      False -> error ('no var ' ++ v ++ ' in environment')
      True -> case (instantiate ctx (getBinding v env)) of
        Pair ctx2 t -> setFinalType ctx2 t e
    Lam ann p a -> case (newTVar ctx) of
      Pair ctx2 tv -> case (infer (addBinding p tv env) ctx2 a) of
        Pair ctx3 a2 ->
          setFinalType ctx3 (TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') (applySubs (getSubs ctx3) tv)) (getType a2)) (Lam ann p a2)
    App ann f a -> case (newTVar ctx) of
      Pair ctx2 tv -> case (infer env ctx2 f) of
        Pair ctx3 f2 -> case (infer (applySubsEnv (getSubs ctx3) env) ctx3 a) of
          Pair ctx4 a2 -> let
            subs2 = getSubs ctx4
            tf = applySubs subs2 (getType f2)
            synth = f1 (getType a2) tv
            //_ = debug (printType tf)
            //_ = debug (printType synth)
            usubs = unify tf synth
            subs3 = composeSubs subs2 usubs
            t = applySubs subs3 tv
            in setFinalType (setSubs subs3 ctx4) t (App ann f2 a2)
    Case ann e ps -> case (infer env ctx e) of
      Pair ctx2 e2 -> case (foldl (inferCase env) (Pair ctx2 (Pair (getType e2) emptyArray)) ps) of
        Pair ctx3 (Pair te ps2) -> let
          t = getType (snd (head ps2))
          subs = foldl composeSubs (getSubs ctx3) (map (\p -> unify t (getType (snd p))) ps2)
          in setFinalType (setSubs subs ctx3) (applySubs subs t) (Case ann (setType te e2) ps2)
    Let ann ds e -> case (inferDefs env ctx ds) of
      Pair ctx2 ds2 -> let
        env2 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env ds2
        //_ = debug (mapRecord printType env2)
        in case (infer env2 ctx2 e) of
          Pair ctx3 e2 -> setFinalType ctx3 (getType e2) (Let ann ds2 e2)
    _ -> error 'type inference not supported for this AST node'

inferType env ctx e = case (infer env ctx e) of
  Pair ctx e2 -> applySubsE (getSubs ctx) e2

inferSccDefs env ctx ds = let
  generateTVar ce d = case ce of
    Pair ctx env -> case d of
      Pair n _ -> case (newTVar ctx) of
        Pair ctx2 tv -> Pair ctx2 (addBinding n tv env)
  inferDef env cds d = case cds of
    Pair ctx ds -> case d of
      Pair n e ->
        //_ = debug ('inferring for binding ' ++ n)
        //_ = debug (mapRecord printType env)
        //_ = debug (case ctx of ICtx subs _ -> mapRecord printType subs)
        case (infer env ctx e) of
          Pair ctx2 e2 -> Pair ctx2 (push (Pair n e2) ds)
  unifyDef env d = case d of
    Pair n e -> unify (getType e) (getBinding n env)
  generalizeDef env cr d = case cr of
    Pair ctx r -> case d of
      Pair n e -> case (generalize env ctx (getType e)) of
        Pair ctx2 t -> Pair ctx2 (push (Pair n (setType t e)) r)
  in case (foldl generateTVar (Pair ctx env) ds) of
    Pair ctx2 env2 -> case (foldl (inferDef env2) (Pair ctx2 emptyArray) ds) of
      Pair ctx3 ds2 -> let
        subs = getSubs ctx3
        dsSubs = map (unifyDef env2) ds2
        subs2 = foldl composeSubs subs dsSubs
        ds3 = map (applySubsDef subs2) ds2
        subs3 = dropNonEnvSubs env subs2
        //_ = debug (mapRecord printType subs3)
        // NOTE: generalizing with env *without* the bindings being generalized.
        ctx4 = dropSatisfiedBounds env (setSubs subs3 ctx3)
        cds = foldl (generalizeDef env) (Pair ctx4 emptyArray) ds3
        //_ = debug ('inferred ' ++ jsonStringify (map (\d -> case d of Pair n e -> Pair n (printType (getType e))) ds4))
        in cds

dropSatisfiedBounds env ctx = let
  is = getInstances env
  bs = getBounds ctx
  bs2 = filter (\b -> not (exists (\i -> satisfiesBound i b) is)) bs
  in setBounds bs2 ctx

dropNonEnvSubs env subs = let
  ftv = freeTVarsInEnv env
  drop subs v t = case (contains v ftv) of
    False -> subs
    True -> set v t subs
  in foldRecord drop empty subs

inferDefs env ctx ds = let
  ns = map fst ds
  g = foldl (\g d -> case d of Pair n e -> set n (filter (\v -> contains v ns && (v /= n)) (freeVars e)) g) empty ds
  ccs = sccSorted g
  //_ = debug g
  //_ = debug ccs
  infer cr cc = case cr of
    Pair ctx rs -> case (inferSccDefs (foldl (\env r -> addBinding (fst r) (getType (snd r)) env) env rs) ctx (filter (\d -> contains (fst d) cc) ds)) of
      Pair ctx2 ds -> Pair ctx2 (concat rs ds)
  in foldl infer (Pair ctx emptyArray) ccs

checkSubs subs = let
  rhs = foldRecord (\rs _ t -> concat rs (freeTVars t)) emptyArray subs
  check _ v _ = case (contains v rhs) of
    True -> error ('tvar ' ++ v ++ ' appears both at LHS and RHS of subs')
    False -> True
  in foldRecord check True subs

generalize env ctx t = let
  subs = getSubs ctx
  envTVars = freeTVarsInEnv env
  tvarsSubstitutingForEnvTVars = let
    f rs v t = case (contains v envTVars) of
      False -> rs
      True -> concat rs (freeTVars t)
    in foldRecord f emptyArray subs
  //_ = debug freeTVarsInEnv
  //_ = debug tvarsSubstitutingForEnvTVars
  nonFree = concat envTVars tvarsSubstitutingForEnvTVars
  vs = filter (\v -> not (contains v nonFree)) (freeTVars t)
  vbb = foldl processBounds (Pair emptyArray (Pair emptyArray emptyArray)) (getBounds ctx)
  processBounds vbb b = case vbb of
    Pair bvs (Pair rbs obs) -> let
      boundVars = freeTVarsInBound b
      sharedVars = filter (\v -> contains v vs) boundVars
      in case (length sharedVars == 0) of
        True -> Pair bvs (Pair rbs (push b obs))
        False -> case (length sharedVars == length boundVars) of
          True -> Pair bvs (Pair (push b rbs) obs)
          False -> Pair (concat bvs sharedVars) (Pair rbs (push b obs))
  in case vbb of
    Pair bvs (Pair rbs obs) -> let
      finalVars = filter (\v -> not (contains v bvs)) vs
      in case ((length finalVars > 0) || (length rbs > 0)) of
        True -> Pair (setBounds obs ctx) (TForall emptyAnn finalVars rbs t)
        False -> Pair (setBounds obs ctx) t

// a -> (b -> (c -> Foo a b c))
unrollDataConType t = case t of
  TApp _ (TApp _ (TConst _ '->') a) b -> case (unrollDataConType b) of
    Pair ps t -> Pair (enqueue a ps) t
  _ -> Pair emptyArray t

applySubsDef subs d = case d of
  Pair n e -> Pair n (applySubsE subs e)

applySubsE subs e = let
    applySubsCase p = case p of
      Pair pat e -> Pair pat (applySubsE subs e)
  in case e of
    Var (Ann t) v -> Var (Ann (applySubs subs t)) v
    Const (Ann t) c -> Const (Ann (applySubs subs t)) c
    App (Ann t) f a -> App (Ann (applySubs subs t)) (applySubsE subs f) (applySubsE subs a)
    Lam (Ann t) p b -> Lam (Ann (applySubs subs t)) p (applySubsE subs b)
    Case (Ann t) e ps -> Case (Ann (applySubs subs t)) (applySubsE subs e) (map applySubsCase ps)
    Let (Ann t) ds e -> Let (Ann (applySubs subs t)) (map (applySubsDef subs) ds) (applySubsE subs e)

freeVars e = let
  freeVarsInPat p = case p of
    Pair pat e ->
      mergeSet
        (filter (\v -> not (contains v (namesInPat pat))) (freeVars e))
        (freeVarsInPData pat)
  freeVarsInPData p = case p of
    PData _ n ps -> foldl mergeSet (arr1 n) (map freeVarsInPData ps)
    _ -> emptyArray
  namesInPat p = case p of
    PVar _ v -> arr1 v
    PConst _ c -> emptyArray
    PData _ n ps -> foldl mergeSet emptyArray (map namesInPat ps)
  in case e of
    Var _ v -> arr1 v
    Const _ c -> emptyArray
    App _ f x -> mergeSet (freeVars f) (freeVars x)
    Lam _ p b -> filter (\v -> v /= p) (freeVars b)
    Case _ e ps -> foldl mergeSet (freeVars e) (map freeVarsInPat ps)
    Let _ ds e -> filter (\v -> not (contains v (map fst ds))) (foldl mergeSet (freeVars e) (map (\d -> freeVars (snd d)) ds))

inferInstance env cs i = let
  inferE e = case (infer env newCtx e) of
    Pair ctx e2 -> applySubsE (getSubs ctx) e2
  in case i of
    Instance ann n it ds -> case (find (\c -> case c of Class _ m _ _ -> n == m) cs) of
      Nothing -> error ('Cannot find clas ' ++ n)
      Just (Class _ _ v bs) -> let
        bs2 = foldl (\bs b -> case b of Pair n t -> set n (substitute v it t) bs) empty bs
        ds2 = map (\d -> case d of Pair dn e -> Pair dn (inferE (setType (get dn bs2) e))) ds
        in Instance ann n it ds2

instanceToTypeBound i = case i of
  Instance _ n t _ -> TCBound emptyAnn n t

classToBindings c = case c of
  Class _ n tv bs -> let
    process b = case b of
      Pair v t -> let
        ftv = freeTVars t
        in case (contains tv ftv) of
          False -> error ('invalid clas definition ' ++ n ++ ', binding ' ++ v)
          True -> Pair v (TForall emptyAnn ftv (arr1 (TCBound emptyAnn n (TVar emptyAnn tv))) t)
    in map process bs

inferTypeModule ms m = let
  getFile i = case i of
    ImportOpen _ f _ -> f
  addImports env i = case (get (getFile i) ms) of
    ModuleInterface bs cs is -> let
      env2 = case i of
        ImportOpen _ f ns -> foldl (\env n -> case n of Pair n a -> addBinding a (get n bs) env) env ns
      env3 = foldl addClass env2 cs
      env4 = foldl (\env i -> addInstance i env) env3 is
      in env4
  addTypes env dt = foldl (\env c -> case c of Pair n t -> addBinding n t env) env (conTypes dt)
  addClass env c = foldl (\env b -> addBinding (fst b) (snd b) env) env (classToBindings c)
  addIns env i = addInstance (instanceToTypeBound i) env
  checkForUnsatisfiedBounds d = case (getType (snd d)) of
    TForall _ _ _ t -> case t of
      TApp _ (TApp _ (TConst _ '->') _) _ -> d
      _ -> error ('unsatisfied bounds in def of ' ++ (fst d) ++ ' :: ' ++ printType (getType (snd d)))
    _ -> d
  in case m of
    Module ann is ts cs ins ds -> let
      env = emptyEnv
      env2 = foldl addImports env is
      env3 = foldl addTypes env2 ts
      env4 = foldl addClass env3 cs
      env5 = foldl addIns env4 ins
      //_ = debugEnv env5
      ds2 = snd (inferDefs env5 newCtx ds)
      //_2 = debug (map (\d -> printType (getType (snd d))) ds2)
      ds3 = map checkForUnsatisfiedBounds ds2
      env6 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env5 ds3
      ins2 = map (inferInstance env6 cs) ins
      in Module ann is ts cs ins ds3

conTypes d = case d of
  Data _ n vs cs -> map (conType n vs) cs

conType dn tvs c = case c of
  DataCon _ n ts -> Pair n (TForall emptyAnn tvs emptyArray (foldr (\b a -> f1 a b) (foldl (\r v -> TApp emptyAnn r (TVar emptyAnn v)) (TConst emptyAnn dn) tvs) ts))

getTypedExports m = case m of
  Module _ _ ts cs ins ds -> let
    et = concatMap conTypes ts
    ed = map (\d -> Pair (fst d) (getType (snd d))) ds
    bs = foldl (\es e -> set (fst e) (snd e) es) empty (concat et ed)
    in ModuleInterface bs cs (map instanceToTypeBound ins)

satisfies a b = case a of
  TVar _ _ -> True
  TConst _ c -> case b of
    TConst _ c2 -> c == c2
    _ -> False
  TApp _ fa xa -> case b of
    TApp _ fb xb -> satisfies fa fb && satisfies xa xb
    _ -> False
  _ -> error ('unexpected type in satisfies ' ++ printType a)

satisfiesBound a b = case a of
  TCBound _ na ta -> case b of
    TCBound _ nb tb -> na == nb && satisfies ta tb
