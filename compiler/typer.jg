import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType, printTypeBound, reallyPrintExpr, printDef} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'

// --------------- Subs -------------------------------

data Subs = Subs (Map String Type) (Map String Type)

getSub v subs = case subs of
  Subs sat unsat -> lookup v sat <|> lookup v unsat

emptySubs = Subs Empty Empty

composeSubs ef sa sb = case sb of
  Subs sat unsat -> foldTrie (\r v t -> addSub ef v t r) (foldTrie (\r v t -> addSatSub ef v t r) sa sat) unsat

addSub ef v t subs = let
  t2 = applySubs subs t
  in case (getSub v subs) of
    Nothing -> case subs of
      Subs sat unsat -> let
        subUnsat su uv ut = case su of
          Pair sat unsat -> let
            ut2 = substitute v t2 ut
            in case (isEmpty (freeTVars ut2)) of
              True -> Pair (insert uv ut2 sat) unsat
              False -> Pair sat (insert uv ut2 unsat)
        su = foldTrie subUnsat (Pair sat Empty) unsat
        sat2 = fst su
        unsat2 = snd su
        in case (isEmpty (freeTVars t2)) of
          True -> Subs (insert v t2 sat2) unsat2
          False -> Subs sat2 (insert v t2 unsat2)
    Just subT -> composeSubs ef subs (unify ef subT t2)

addSatSub ef v t subs = case (getSub v subs) of
  Nothing -> case subs of
    Subs sat unsat -> let
      subUnsat su uv ut = case su of
        Pair sat unsat -> let
          ut2 = substitute v t ut
          in case (isEmpty (freeTVars ut2)) of
            True -> Pair (insert uv ut2 sat) unsat
            False -> Pair sat (insert uv ut2 unsat)
      su = foldTrie subUnsat (Pair sat Empty) unsat
      sat2 = fst su
      unsat2 = snd su
      in Subs (insert v t sat2) unsat2
  Just subT -> composeSubs ef subs (unify ef subT t)

dropSubs vs subs = case subs of
  Subs sat unsat -> Subs (foldl (\r v -> remove v r) sat vs) (foldl (\r v -> remove v r) unsat vs)

// -------------- Context -----------------------------

data InferenceContext = ICtx Subs (Array TypeBound) Number (String -> String)

newTVar ctx = case ctx of
  ICtx subs bs i e -> let
    n = '$' ++ intToString i
    in Pair (ICtx subs bs (i + 1) e) (TVar emptyAnn n)

newTVarM = gets >>= \ctx -> case ctx of
  ICtx subs bs i e -> let
    n = '$' ++ intToString i
    in sets (ICtx subs bs (i + 1) e) >> ret (TVar emptyAnn n)

newCtx = ICtx emptySubs [] 1 (\s -> 'unknown error context: ' ++ s)

getSubs ctx = case ctx of
  ICtx subs _ _ _ -> subs

setSubs subs ctx = case ctx of
  ICtx _ bs i e -> ICtx subs (map (applySubsBound subs) bs) i e

addBound b ctx = case ctx of
  ICtx subs bs i e -> ICtx subs (push b bs) i e

getBounds ctx = case ctx of
  ICtx _ bs _ _ -> bs

setBounds bs ctx = case ctx of
  ICtx subs _ i e -> ICtx subs bs i e

errorM s = gets >>= \ctx -> case ctx of
  ICtx _ _ _ e -> error (e s)

onError e = gets >>= \ctx -> case ctx of
  ICtx subs bs i _ -> sets (ICtx subs bs i e)

withError e f = getErrorF >>= \old -> onError e >> f >>= \r -> onError old >> ret r

getErrorF = gets >>= \ctx -> case ctx of
  ICtx _ _ _ e -> ret e

// -------------- Environment -------------------------

data InferenceEnvironment = IEnv (Map String Type) (Array TypeBound) (Map String Unit)

emptyEnv = IEnv Empty [] emptySet

getBinding n env = case env of
  IEnv bs _ _ -> lookup n bs

getBindingM n env = gets >>= \ctx -> ret $ fmap (applySubs (getSubs ctx)) (getBinding n env)

getBindings env = case env of
  IEnv bs _ _ -> bs

addBinding n t env = case env of
  IEnv bs ts fvs -> IEnv (insert n t bs) ts (setUnion fvs (freeTVars t))

addBindings nbs env = case env of
  IEnv bs ts fvs -> IEnv (mergeTrie bs nbs) ts (foldTrie (\fvs _ t -> setUnion fvs (freeTVars t)) fvs nbs)

freeTVarsInEnv env = case env of
  IEnv _ _ fvs -> fvs

addInstance b env = case env of
  IEnv bs ts fvs -> IEnv bs (push b ts) fvs

getInstances env = case env of
  IEnv _ ts _ -> ts

// ------------ Inference Engine ----------------------

freeTVars t = case t of
  TVar _ v -> setAdd v emptySet
  TBot -> emptySet
  TUnknown -> emptySet
  TConst _ c -> emptySet
  TSkolem _ _ -> emptySet
  TForall _ vs bs t -> 
    foldl (\s v -> setRemove v s) (foldl setUnion (freeTVars t) (map freeTVarsInBound bs)) vs
  TApp _ f a -> setUnion (freeTVars f) (freeTVars a)
  TRow _ ms r -> foldl setUnion (justOr emptySet $ fmap freeTVars r) (map (\m -> setUnion (freeTVars (fst m)) (freeTVars (snd m))) ms)

f1 a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

mkTForall ann vs bs t = let
  f bs b = case (exists (equivBound b) bs) of
    True -> bs
    False -> push b bs
  in TForall ann vs (foldl f [] bs) t

instantiateM t = gets >>= \ctx -> case (instantiate ctx (\ctx _ -> newTVar ctx) t) of
  Pair (Pair t bs) ctx ->
    sets (foldl (\ctx b -> addBound b ctx) ctx bs) >> ret t

instantiate ctx mkvar t = case t of
  TForall ann vs bs t -> let
    _sc = let
      f sc v = case sc of
        Pair subs ctx -> case (mkvar ctx v) of
          Pair ctx tv -> Pair (insert v tv subs) ctx
      in foldl f (Pair Empty ctx) vs
    subs = fst _sc
    ctx2 = snd _sc
    replace t = case t of
      TConst _ _ -> t
      TVar _ _ -> t
      TBot -> t
      TSkolem _ n -> case (lookup n subs) of
        Nothing -> t
        Just tv -> tv
      TApp ann f a -> TApp ann (replace f) (replace a)
      TRow ann ms r -> TRow
        ann
        (map (\m -> case m of Pair k v -> Pair (replace k) (replace v)) ms)
        (fmap replace r)
      TForall _ _ _ _ -> error 'nested universal quantification'
    replaceBound b = case b of
      TCBound ann n t -> TCBound ann n (replace t)
    in Pair (Pair (replace t) (map replaceBound bs)) ctx2
  _ -> Pair (Pair t []) ctx

substitute n s t = applySubs (addSub (\s -> 'substitute: ' ++ s) n s emptySubs) t

applySubs subs t = case t of
  TForall ann vs bs t -> let
    subs2 = dropSubs vs subs
    in mkTForall ann vs (map (applySubsBound subs2) bs) (applySubs subs2 t)
  TVar _ v -> case (getSub v subs) of
    Nothing -> t
    Just subT -> subT
  TApp ann f a -> TApp ann (applySubs subs f) (applySubs subs a)
  TRow ann ms r -> TRow ann (map (\m -> case m of Pair k v -> Pair (applySubs subs k) (applySubs subs v)) ms) (fmap (applySubs subs) r)
  _ -> t

applySubsBound subs b = case b of
  TCBound ann n t -> TCBound ann n (applySubs subs t)

unifyM a b = gets >>= \ctx -> getErrorF >>= \ef -> let
  ef2 s = ef ('unifying ' ++ printType a ++ ' and ' ++ printType b ++ ': ' ++ s)
  in sets (setSubs (composeSubs ef2 (getSubs ctx) (unify ef2 a b)) ctx)

unify ef a b = let
  bind n t = case t of
    TVar _ m -> case (n == m) of
      True -> emptySubs
      False -> addSub ef n t emptySubs
    _ -> case (setContains n (freeTVars t)) of
      True ->
        //debug (printType a)
        //_ = debug (printType b)
        error (ef 'occurs check failed')
      False -> addSub ef n t emptySubs
  err a b = error
    (ef ('cannot unify ' ++ printType a ++ ' with ' ++ printType b))
  in case a of
    TVar _ v -> case b of
      //TSkolem _ _ -> err a b
      _ -> bind v b
    TSkolem _ va -> case b of
      TSkolem _ vb -> case (va == vb) of
        True -> emptySubs
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TConst _ ca -> case b of
      TConst _ cb -> case (ca == cb) of
        True -> emptySubs
        False -> err a b
      TVar _ v -> bind v a
      _ -> err a b
    TUnknown -> err a b
    TBot -> err a b
    TApp _ fa xa -> case b of
      TVar _ v -> bind v a
      TApp _ fb xb -> let
        fsubs = unify ef fa fb
        xsubs = unify ef (applySubs fsubs xa) (applySubs fsubs xb)
        in composeSubs ef fsubs xsubs
      _ -> err a b
    TRow _ _ (Nothing) -> err a b
    TRow _ ms _ -> case b of
      TVar _ v -> bind v a
      TRow _ ms2 (Nothing) -> err a b
      _ -> err a b
    _ -> err a b

freeTVarsInBound b = case b of
  TCBound _ _ t -> freeTVars t

withLocError e f = case (getAnnCodeLoc (annOf e)) of
  Nothing -> f
  Just loc -> withError (\s -> s ++ ' ' ++ printCodeLoc loc) f

infer env e = let
  setFinalType t e = case (getType e) of
    TUnknown -> ret (setType t e)
    TForall _ _ _ _ ->
      // TODO: check whether the inferred type is broader then the user-provided one
      ret e
    te -> unifyM t te >> ret e
  inferCase env te p = case p of
    Pair pat e -> inferPat env te pat >>= \cb -> case cb of
      Pair bs pat ->
        infer (addBindings bs env) e >>= \e ->
          ret (Pair pat e)
  inferPat env te pat = case pat of
    PVar ann v -> newTVarM >>= \tv ->
      unifyM te tv >>
        ret (Pair (insert v tv Empty) (PVar (setAnnType tv ann) v))
    PConst _ (CNum n) -> unifyM te (TConst emptyAnn 'Number') >> ret (Pair Empty pat)
    PConst _ (CStr s) -> unifyM te (TConst emptyAnn 'String') >> ret (Pair Empty pat)
    PData ann n ps -> getBindingM n env >>= \bt -> case bt of
      Nothing -> error ('unknown data type ' ++ n)
      Just t -> instantiateM t >>= \t ->
        case (unrollDataConType t) of
          Pair tps dt -> case (length ps == length tps) of
            False -> errorM 'number of pattern params does not match the number of constructor params'
            True -> foldM (inferSubPat env) (Pair Empty []) (zip ps tps) >>= \bps -> case bps of
              Pair bs ps ->
                unifyM te dt >>
                  (ret $ Pair bs (PData ann n ps))
  inferSubPat env bp pt = case bp of
    Pair bs ps -> case pt of
      Pair pat t -> inferPat env t pat >>= \bp -> case bp of
        Pair bs2 pat -> (ret $ Pair (mergeTrie bs bs2) (push pat ps))
  in withLocError e $ case e of
    Const _ (CNum n) -> setFinalType (TConst emptyAnn 'Number') e
    Const _ (CStr s) -> setFinalType (TConst emptyAnn 'String') e
    Var _ v -> getBindingM v env >>= \vt -> case vt of
      Nothing -> errorM ('unknown identifier ' ++ v ++ ', env: ' ++ jsonStringify (trieKeys $ getBindings env))
      Just t -> instantiateM t >>= \t -> setFinalType t e
    Lam ann p a -> newTVarM >>= \tv ->
      infer (addBinding p tv env) a >>= \a ->
        setFinalType (TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') tv) (getType a)) (Lam ann p a)
    App ann f a -> newTVarM >>= \tv ->
      infer env f >>= \f ->
        infer env a >>= \a -> let
          synth = f1 (getType a) tv
          in unifyM (getType f) synth >>
            setFinalType tv (App ann f a)
    Case ann e ps -> infer env e >>= \e ->
      mapM (inferCase env (getType e)) ps >>= \ps -> let
        t = getType (snd (head ps))
        in mapM (\p -> unifyM t (getType $ snd p)) (tail ps) >>
          setFinalType t (Case ann e ps)
    Let ann ds e -> inferDefs env ds >>= \ds -> let
      env2 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env ds
      in infer env2 e >>= \e ->
        setFinalType (getType e) (Let ann ds e)
    New ann 'Array' es -> mapM (infer env) es >>= \es ->
      newTVarM >>= \tv ->
        mapM (\e -> unifyM tv (getType e)) es >>
          setFinalType (TApp emptyAnn (TConst emptyAnn 'Array') tv) (New ann 'Array' es)
    New ann tag es -> mapM (infer env) es >>= \es -> getBindingM tag env >>= \t -> case t of
      Nothing -> error ('unknown data constructor ' ++ tag)
      Just t -> instantiateM t >>= \t ->
        case (unrollDataConType t) of
          Pair tps dt -> case (length es == length tps) of
            False -> errorM ('number of New args does not match the number of constructor params ' ++ jsonStringify es ++ ' ' ++ printType t)
            True -> mapM (\p -> case p of Pair t e -> unifyM t (getType e)) (zip tps es) >>
              setFinalType dt (New ann tag es)
    _ -> error 'type inference not supported for this AST node'

inferSccDefs env ds = let
  generateTVar env d = case (getType (snd d)) of
    TUnknown -> newTVarM >>= \tv -> ret (addBinding (fst d) tv env)
    t -> ret (addBinding (fst d) t env)
  inferDef env d = case d of
    Pair n e -> infer env e >>= \e -> ret (Pair n e)
  unifyDef env d = case d of
    Pair n e -> case (getType e) of
      TForall _ _ _ _ -> ret Unit
      t -> unifyM t (fromJust $ getBinding n env)
  generalizeDef env d = case d of
      Pair n e -> case (getType e) of
        TForall _ _ _ _ -> ret d
        t -> generalize env t >>= \t -> let
          e2 = skolemize (setType t e)
          //_ = debug (n ++ ' :: ' ++ reallyPrintExpr True e2)
          //_ = debug (n ++ ' :: ' ++ printType (getType e2))
          in ret (Pair n e2)
  in foldM generateTVar env ds >>= \env2 ->
    mapM (inferDef env2) ds >>= \ds2 ->
      mapM (unifyDef env2) ds2 >>
        mapM applySubsDef ds2 >>= \ds3 ->
          dropSatisfiedBounds env >>
            mapM (generalizeDef env) ds3

skolemizeSubs =
  foldl (\subs v -> addSub (\s -> 'skolemize: ' ++ s) v (TSkolem emptyAnn v) subs) emptySubs

skolemizeType t = case t of
  TForall ann vs bs t -> let
    subs = skolemizeSubs vs
    in TForall ann vs (map (applySubsBound subs) bs) (applySubs subs t)
  _ -> t

skolemize e = case (getType e) of
  TForall ann vs bs t -> let
    subs = skolemizeSubs vs
    t2 = TForall ann vs (map (applySubsBound subs) bs) (applySubs subs t)
    in applySubsE subs (setType t2 e)
  _ -> e

dropSatisfiedBounds env = gets >>= \ctx -> let
  is = getInstances env
  bs = getBounds ctx
  bs2 = filter (\b -> not (exists (\i -> satisfiesBound i b) is)) bs
  in sets (setBounds bs2 ctx)

bindingsScc bs = let
  ns = map fst bs
  g = foldl (\g d -> case d of Pair n e -> insert n (filter (\v -> contains v ns && (v /= n)) (freeVars e)) g) Empty bs
  ccs = sccSorted g
  in map (\cc -> filter (\b -> contains (fst b) cc) bs) ccs

inferDefs env ds = let
  infer rs ds = fmap (concat rs) (inferSccDefs (foldl (\env r -> addBinding (fst r) (getType (snd r)) env) env rs) ds)
  in foldM infer [] (bindingsScc ds)

generalize env t = gets >>= \ctx -> let
  subs = getSubs ctx
  envTVars = freeTVarsInEnv env
  nonFree = case subs of Subs _ unsat ->
    foldTrie (\s v _ -> setUnion s (justOr Empty (fmap freeTVars (lookup v unsat)))) envTVars envTVars
  vs = setDiff (freeTVars t) nonFree
  vbb = foldl processBounds (Pair emptySet (Pair [] [])) (getBounds ctx)
  processBounds vbb b = case vbb of
    Pair bvs (Pair rbs obs) -> let
      boundVars = freeTVarsInBound b
      sharedVars = setIntersection boundVars vs
      in case (isEmpty sharedVars) of
        True -> Pair bvs (Pair rbs (push b obs))
        False -> case (size sharedVars == size boundVars) of
          True -> Pair bvs (Pair (push b rbs) obs)
          False -> Pair (setUnion bvs sharedVars) (Pair rbs (push b obs))
  in case vbb of
    Pair bvs (Pair rbs obs) -> let
      finalVars = setDiff vs bvs
      drop r v t = case (isEmpty $ setIntersection finalVars (freeTVars t)) of
        True -> insert v t r
        False -> r
      subs2 = case subs of
        Subs sat unsat -> Subs sat (foldTrie drop Empty unsat)
      in sets (setBounds obs (setSubs subs2 ctx)) >>
        case ((not $ isEmpty finalVars) || (length rbs > 0)) of
          True -> ret (mkTForall emptyAnn (setToArray finalVars) rbs t)
          False -> ret t

// a -> (b -> (c -> Foo a b c))
unrollDataConType t = case t of
  TApp _ (TApp _ (TConst _ '->') a) b -> case (unrollDataConType b) of
    Pair ps t -> Pair (enqueue a ps) t
  _ -> Pair [] t

applySubsDef d = case d of
  Pair n e -> gets >>= \ctx -> ret $ Pair n (applySubsE (getSubs ctx) e)

applySubsE subs e = let
  f a e = let
    t2 = applySubs subs (getType e)
    in Pair a (setType t2 e)
  in snd (down f True e)

freeVars e = let
  freeVarsInPat p = case p of
    Pair pat e ->
      mergeSet
        (filter (\v -> not (contains v (namesInPat pat))) (freeVars e))
        (freeVarsInPData pat)
  freeVarsInPData p = case p of
    PData _ n ps -> foldl mergeSet [n] (map freeVarsInPData ps)
    _ -> []
  namesInPat p = case p of
    PVar _ v -> [v]
    PConst _ c -> []
    PData _ n ps -> foldl mergeSet [] (map namesInPat ps)
  in case e of
    Var _ v -> [v]
    Const _ c -> []
    App _ f x -> mergeSet (freeVars f) (freeVars x)
    Lam _ p b -> filter (\v -> v /= p) (freeVars b)
    Case _ e ps -> foldl mergeSet (freeVars e) (map freeVarsInPat ps)
    Let _ ds e -> filter (\v -> not (contains v (map fst ds))) (foldl mergeSet (freeVars e) (map (\d -> freeVars (snd d)) ds))
    New _ _ es -> foldl mergeSet [] (map freeVars es)

inferInstance env cs i = let
  inferE e = case (runState newCtx $ infer env e) of
    Pair ctx e2 -> applySubsE (getSubs ctx) e2
  in case i of
    Instance ann n it ds -> case (find (\c -> case c of Class _ m _ _ -> n == m) cs) of
      Nothing -> error ('Cannot find clas ' ++ n)
      Just (Class _ _ v bs) -> let
        bs2 = foldl (\bs b -> case b of Pair n t -> insert n (substitute v it t) bs) Empty bs
        ds2 = map (\d -> case d of Pair dn e -> Pair dn (inferE (setType (fromJust $ lookup dn bs2) e))) ds
        in Instance ann n it ds2

instanceToTypeBound i = case i of
  Instance _ n t _ -> TCBound emptyAnn n t

classToBindings c = case c of
  Class _ n tv bs -> let
    process b = case b of
      Pair v t -> let
        ftv = freeTVars t
        in case (setContains tv ftv) of
          False -> error ('invalid clas definition ' ++ n ++ ', binding ' ++ v)
          True -> Pair v (skolemizeType (mkTForall emptyAnn (setToArray ftv) [TCBound emptyAnn n (TVar emptyAnn tv)] t))
    in map process bs

inferTypeModule ms m = let
  getFile i = case i of
    ImportOpen _ f _ -> f
  addImports env i = case (get (getFile i) ms) of
    ModuleInterface bs cs is -> let
      env2 = case i of
        ImportOpen _ f ns -> foldl (\env n -> case n of Pair n a -> addBinding a (get n bs) env) env ns
      env3 = foldl addClass env2 cs
      env4 = foldTrie (\env _ i -> addInstance i env) env3 is
      in env4
  addClass env c = foldl (\env b -> addBinding (fst b) (snd b) env) env (classToBindings c)
  addIns env i = addInstance (instanceToTypeBound (snd i)) env
  checkForUnsatisfiedBounds d = case (getType (snd d)) of
    TForall _ _ bs t -> case t of
      TApp _ (TApp _ (TConst _ '->') _) _ -> d
      _ -> case (length bs) of
        0 -> d
        _ -> error ('unsatisfied bounds in def of ' ++ (fst d) ++ ' :: ' ++ printType (getType (snd d)))
    _ -> d
  in case m of
    Module ann fn is ts cs ins ds -> let
      env = emptyEnv
      env2 = foldl addImports env is
      env3 = foldl addClass env2 cs
      env4 = foldl addIns env3 ins
      ds2 = evalState newCtx (inferDefs env4 ds)
      ds3 = map checkForUnsatisfiedBounds ds2
      env5 = foldl (\env d -> case d of Pair n e -> addBinding n (getType e) env) env4 ds3
      ins2 = let
        allCls = concat cs (concatMap (\i -> case (get (getFile i) ms) of ModuleInterface _ cs _ -> cs) is)
        in map (mapSnd (inferInstance env5 allCls)) ins
      in Module ann fn is ts cs ins2 ds3

getTypedExports m = case m of
  Module _ _ _ _ cs ins ds -> let
    collectExports es b = let
      e = snd b
      in case (getAnn 'export' (annOf e)) of
        Nothing -> es
        Just (AnnExport n) -> set n (getType e) es
    bs = foldl collectExports empty ds
    in ModuleInterface bs cs (foldl (\m p -> case p of (n, i) -> insert n (instanceToTypeBound i) m) Empty ins)

satisfies a b = case a of
  TVar _ _ -> True
  TSkolem _ va -> case b of
    TSkolem _ vb -> va == vb
    _ -> False
  TConst _ c -> case b of
    TConst _ c2 -> c == c2
    _ -> False
  TApp _ fa xa -> case b of
    TApp _ fb xb -> satisfies fa fb && satisfies xa xb
    _ -> False
  _ -> error ('unexpected type in satisfies ' ++ printType a)

satisfiesBound a b = case a of
  TCBound _ na ta -> case b of
    TCBound _ nb tb -> na == nb && satisfies ta tb
