import * from '//compiler/prelude.jg'

data Ann =
  AnnType Type
emptyAnn = emptyArray

getAnn name ann = fmap snd (find (\p -> fst p == name) ann)
setAnn name val ann = push (Pair name val) (filter (\p -> fst p /= name) ann)

getAnnType ann = case (getAnn 'type' ann) of
  Just (AnnType t) -> t
  Nothing -> TUnknown
setAnnType t ann = setAnn 'type' (AnnType t) ann

data Expr =
  Var (Array (Pair String Ann)) String
  | Const (Array (Pair String Ann)) CVal
  | App (Array (Pair String Ann)) Expr Expr
  | Lam (Array (Pair String Ann)) String Expr
  | Case (Array (Pair String Ann)) Expr (Array (Pair Pat Expr))
  | Let (Array (Pair String Ann)) (Array (Pair String Expr)) Expr

data CVal =
  CNum Number
  | CStr String

data Pat =
  PVar (Array (Pair String Ann)) String
  | PConst (Array (Pair String Ann)) CVal
  | PData (Array (Pair String Ann)) String (Array Pat)

data Module = Module
  (Array (Pair String Ann))                        // annotations
  (Array Import)             // imports
  (Array Data)               // ADT definitions
  (Array Class)              // type clas definitions
  (Array Instance)           // type clas instances
  (Array (Pair String Expr)) // value definitions

data ModuleInterface = ModuleInterface
  (Record Type)      // exported bindings, includes ADT constructors
  (Array Class)      // exported classes
  (Array TypeBound)  // exported clas instances

data Data = Data (Array (Pair String Ann)) String (Array String) (Array DataCon)
data DataCon = DataCon (Array (Pair String Ann)) String (Array Type)

data Class = Class
  (Array (Pair String Ann))
  String     // name
  String     // type var
  (Array (Pair String Type))

data Instance = Instance
  (Array (Pair String Ann))
  String     // name
  Type       // type for which we're defining the instanc
  (Array (Pair String Expr))

data TypeBound =
  TCBound  // type clas bound
    (Array (Pair String Ann))    // annotation
    String // name of the type clas
    Type   // param

data Type =
  TConst (Array (Pair String Ann)) String
  | TVar (Array (Pair String Ann)) String
  | TApp (Array (Pair String Ann)) Type Type
  | TBot
  | TForall (Array (Pair String Ann)) (Array String) (Array TypeBound) Type
  | TUnknown

data Import =
  ImportClosed (Array (Pair String Ann)) String String
  | ImportOpen (Array (Pair String Ann)) String (Array (Pair String String))
  | ImportAll (Array (Pair String Ann)) String

dataConName = \dc -> case dc of DataCon _ n ts -> n
dataConNames = \d -> case d of Data _ n ps cs -> map dataConName cs
getExports = \m -> case m of
  Module _ is ds _ _ vs -> concat (concatMap dataConNames ds) (map fst vs)
  
setType t e = case e of
  Var ann v -> Var (setAnnType t ann) v
  Const ann c -> Const (setAnnType t ann) c
  App ann f a -> App (setAnnType t ann) f a
  Lam ann p b -> Lam (setAnnType t ann) p b
  Case ann e ps -> Case (setAnnType t ann) e ps
  Let ann ds e -> Let (setAnnType t ann) ds e

getType e = case e of
  Var ann v -> getAnnType ann
  Const ann c -> getAnnType ann
  App ann f a -> getAnnType ann
  Lam ann p b -> getAnnType ann
  Case ann e ps -> getAnnType ann
  Let ann ds e -> getAnnType ann

breakableDownAndUp down up a e = let
  go = breakableDownAndUp down up
  gos a = foldl (\ar p -> case (go (fst ar) (snd p)) of Pair a2 e -> Pair a2 (push (Pair (fst p) e) (snd ar))) (Pair a emptyArray)
  in case (down a e) of
    Right ae -> ae
    Left (Pair a2 e2) -> let
      ae = case e2 of
        Lam ann p e -> case (go a2 e) of
          Pair a e -> Pair a (Lam ann p e)
        App ann f x -> case (go a2 f) of
          Pair a f -> case (go a x) of
            Pair a x -> Pair a (App ann f x)
        Case ann e ps -> case (go a2 e) of
          Pair a e -> case (gos a ps) of
            Pair a ps -> Pair a (Case ann e ps)
        Let ann bs e -> case (gos a2 bs) of
          Pair a bs -> case (go a e) of
            Pair a e -> Pair a (Let ann bs e)
        _ -> Pair a2 e2
      in case ae of
        Pair a e -> up a e

downAndUp down up = breakableDownAndUp (\a e -> Left (down a e)) up

up = downAndUp Pair
down f = downAndUp f Pair
breakableDown f = breakableDownAndUp f Pair
