import * from '//compiler/prelude.jg'
import * from '//compiler/ast.jg'
import {printType, printTypeBound, reallyPrintExpr, printDef} from '//compiler/printer.jg'
import {sccSorted} from '//compiler/graph.jg'
import {replaceSkolems} from '//compiler/typeutil.jg'

data TCtx =
  ModuleCtx String
  | BindingCtx String
  | ExprCtx Expr
  | TypeEquivCtx Type Type
  | TypeInstCtx Type
  | PatCtx Pat

data TypingResult = TOk | TErr (Array TCtx) String

isOk r = case r of
  TOk -> True
  _ -> False

checkMany f xs = case (length xs) of
  0 -> TOk
  _ -> case (f (head xs)) of
    TOk -> checkMany f (tail xs)
    e -> e

tnum = TConst emptyAnn 'Number'
tstr = TConst emptyAnn 'String'
tfun a b = TApp emptyAnn (TApp emptyAnn (TConst emptyAnn '->') a) b

data Inst = Inst (Array String) TypeBound
data Scope = Scope (Map String Type) (Array Inst) (Map String Unit)

addBinding v t (Scope bs is sks) = Scope (insert v t bs) is sks
getBinding v (Scope bs _ _) = lookup v bs

addSkolems vs (Scope bs is sks) = Scope bs is (setAddAll vs sks)
allowedSkolem v (Scope _ _ sks) = setContains v sks

instanceMatches ctx (TCBound _ nb tb) (Inst vs (TCBound _ ni ti)) =
  (ni == nb) && isOk (evalState (foldl (\m v -> insert v TUnknown m) Empty vs) (checkEquivM ctx tb ti))
addInstances vs tbs (Scope bs is sks) = Scope bs (concat is (map (Inst vs) tbs)) sks
findInstances ctx b (Scope _ is _) = filter (instanceMatches ctx b) is

checkEquiv ctx a b = evalState Empty (checkEquivM ctx a b)

checkEquivM ctx toType fromType = let
  ctx2 = push (TypeEquivCtx toType fromType) ctx
  err m = ret $ TErr ctx2 m
  ok = ret $ TOk
  checkM = checkEquivM ctx2
  in case fromType of
      TConst _ n -> case toType of
        TConst _ m -> case (n == m) of
          True -> ok
          False -> err 'type name mismatch'
        _ -> err 'type mismatch'

      TSkolem _ v -> gets >>= \bs -> case (lookup v bs) of
        // Case 1: this is not a var we're instantiating.
        Nothing -> case toType of
          TSkolem _ w -> case (v == w) of
            True -> ok
            False -> err 'type name mismatch'
          _ -> err 'type mismatch'
        // Case 2: this is a var we're instantiating and it is
        // the first time we encountered it.
        Just (TUnknown) -> sets (insert v toType bs) >> ok
        // Case 3: this is a var we're instantiating and
        // we've seen it before.
        Just t -> ret $ checkEquiv ctx2 t toType

      TApp _ fb xb -> case toType of
        TApp _ fa xa -> checkM fa fb >>= \fr -> case fr of
          TOk -> checkM xa xb
          e -> ret e
      _ -> err 'type cannot be equivalent'

instantiateBound reps (TCBound ann className t) =
  TCBound ann className (replaceSkolems t reps)

checkBound ctx scope b = let
  matchingInstances = findInstances ctx b scope
  in case (length matchingInstances) of
    0 -> TErr ctx ('no matching instances found (out of ' ++ intToString (length (case scope of (Scope _ ins _) -> ins)) ++ ')')
    1 -> TOk
    n -> TErr ctx ('too many matching instances found (' ++ intToString n ++ ')')

checkCanInstantiate ctx scope toType fromType =
  case fromType of
    TForall _ vs typeBounds t -> let
      bs = foldl (\bs v -> insert v TUnknown bs) Empty vs
      ctx2 = push (TypeInstCtx fromType) ctx
      in case (runState bs (checkEquivM ctx2 toType t)) of
        (reps, TOk) -> checkMany (checkBound ctx scope) (map (instantiateBound reps) typeBounds) 
        (_, e) -> e
    _ -> checkEquiv ctx toType fromType

checkAllowedSkolems ctx scope t = let
  check = checkAllowedSkolems ctx scope
  in case t of
    TSkolem _ n -> case (allowedSkolem n scope) of
      True -> TOk
      False -> TErr ctx ('unknown skolem ' ++ n)
    TApp _ a b -> case (check a) of
      TOk -> check b
      e -> e
    TForall _ vs bs t -> let
      scope2 = addSkolems vs scope
      in checkMany (checkAllowedSkolems ctx scope2) (push t (map (\(TCBound _ _ t) -> t) bs))
    _ -> TOk

checkBindings ctx scope bs = let
  scope2 = foldl (\scope (n, e) -> addBinding n (getType e) scope) scope bs
  check (n, e) = checkExpr (push (BindingCtx n) ctx) scope2 e
  in (scope2, checkMany check bs)

checkTopBindings ctx scope bs = snd (checkBindings ctx scope bs)

// ctx: contexts for error reporting
// scope: bindings, name -> type
// asks: allowed skolems, things that we generalize over
checkExpr ctx scope e = let
  ctx2 = push (ExprCtx e) ctx
  err = TErr ctx2
  et = getType e
  check = checkExpr ctx2

  checkDataRef ctx scope consName dataType argTypes = let
    refType = foldr (\d t -> tfun t d) dataType argTypes
    in case (getBinding consName scope) of
      Just consType -> checkCanInstantiate ctx scope refType consType
      _ -> err 'unrecognized identifier'

  in case (checkAllowedSkolems ctx2 scope et) of
    TOk -> case e of
      Var _ n ->  case (getBinding n scope) of
        Nothing -> err 'unrecognized identifier'
        Just t -> checkCanInstantiate ctx2 scope et t
      Const _ (CNum _) -> checkEquiv ctx2 et tnum
      Const _ (CStr _) -> checkEquiv ctx2 et tstr
      Gen _ e -> case et of
        TForall _ vs bs t -> let
          scope2 = addInstances vs bs $ addSkolems vs scope
          in case (check scope2 e) of
            TOk -> checkEquiv ctx2 t (getType e)
            e -> e
        _ -> err 'Gen expr with non-TForall type'
      App _ f a -> case (check scope f) of
        TOk -> case (check scope a) of
          TOk -> checkEquiv ctx2 (tfun (getType a) et) (getType f)
          e -> e
        e -> e
      Lam _ v e ->
        case et of
          TApp _ (TApp _ (TConst _ '->') ta) tb -> let
            scope2 = addBinding v ta scope
            in case (check scope2 e) of
              TOk -> checkEquiv ctx2 tb (getType e)
              e -> e
          _ -> err 'Lam expr with non-function type'
      New _ 'Array' es ->
        case et of
          TApp _ (TConst _ 'Array') t -> let
            checkElem e = case (checkEquiv ctx2 t (getType e)) of
              TOk -> check scope e
              e -> e
            in checkMany checkElem es
          _ -> err 'New<Array> with non Array type'
      New _ d es ->
        case (checkMany (check scope) es) of
          TOk -> checkDataRef ctx2 scope d et (map getType es)
          e -> e
      Let _ bs e -> case (checkBindings ctx2 scope bs) of
        (scope2, TOk) -> check scope2 e
        (_, err) -> err

      // Checks to do:
      // 1. Check the expr
      // 2. Check top-level patterns against the expr type
      // 3. Check pattern consistency
      // 4. For each branch get bindings from pat and check
      //    branch expr, also against the return type
      Case _ e ps -> let
        caseType = et
        exprType = getType e
        topPats = map fst ps
        topPatTypes = map getPatType topPats

        // Checks type consistency between the pattern, sub-patterns
        // and referenced data type constructors.
        checkPat ctx p = let
          ctx2 = push (PatCtx p) ctx
          patType = getPatType p
          in case p of
            PData _ d ps -> case (checkDataRef ctx2 scope d patType (map getPatType ps)) of
              TOk -> checkMany (checkPat ctx2) ps
              e -> e
            PConst _ (CNum _) -> checkEquiv ctx2 tnum patType
            PConst _ (CStr _) -> checkEquiv ctx2 tstr patType
            PVar _ _ -> TOk

        // Checks specific case branch, in particular the branch expr
        // with pattern bindings and consistency of the branch expr type and
        // the overall case expr type.
        checkBranch (p, e) = let
          getBs scope p = case p of
            PVar _ v -> addBinding v (getPatType p) scope
            PData _ _ ps -> foldl getBs scope ps
            PConst _ _ -> scope
          scope2 = getBs scope p
          branchType = getType e
          in case (check scope2 e) of
            TOk -> checkEquiv ctx2 caseType branchType
            e -> e

        in case (check scope e) of
          TOk -> case (checkMany (checkEquiv ctx2 exprType) topPatTypes) of
            TOk -> case (checkMany (checkPat ctx2) topPats) of
              TOk -> checkMany checkBranch ps
              e -> e
            e -> e
          e -> e
    e -> e
