import * from '//compiler/prelude.jg'
import * from '//compiler/jaguarParser.jg'
import {scc, sccSorted} from '//compiler/graph.jg'

// Simple operator.
addition = 6 + 5

// Pattern match.
match = case (Pair 'foo' 'bar') of
  Pair a b -> a

// Data definitions
data Friend =
  Kitten String
  | Pony String String

getName = \f -> case f of
  Kitten n -> n
  Pony c n -> n

// Pattern matches on ADTs.
kittenName = getName (Kitten 'Fluffbun')
ponyName = getName (Pony 'pink' 'Fluttershy')

// Nested pattern matches.
nestedMatch = case (Pair (Kitten 'Fluffbun') 7) of
  Pair k 8 -> 2
  Pair (Pony c n) 7 -> 3
  Pair (Kitten n) 8 -> 4
  Pair (Kitten 'Buba') 7 -> 5
  Pair (Kitten 'Fluffbun') 7 -> 6

// Simple let.
letExpr =
  let
    x = 7
    y = 8
  in x + y

// Check that shadowing works as expected.
letExpr2 =
  let contains = False in not contains
  
// Syntax-sugar for function definitions.
f x = x + 1
fx = f 41

// Syntax sugar for funs in lets.
letF = let g y z = y + z + 1
       in g 10 2

scc1 = sccSorted (set 'a' (arr1 'b') (set 'b' (arr1 'a') (set 'c' (arr1 'a') empty)))

scc2 =
  sort (scc
    (set '//compiler/e2e/basic_module_test.jg' (arr2 '//compiler/prelude.jg' '//compiler/jaguarParser.jg')
      (set '//compiler/prelude.jg' emptyArray
        (set '//compiler/ast.jg' (arr1 '//compiler/prelude.jg')
          (set '//compiler/parsers.jg'(arr1 '//compiler/prelude.jg')
            (set '//compiler/jaguarLexer.jg' (arr2 '//compiler/prelude.jg' '//compiler/parsers.jg')
              (set '//compiler/jaguarParser.jg' (arr4 '//compiler/prelude.jg' '//compiler/ast.jg' '//compiler/parsers.jg' '//compiler/jaguarLexer.jg')
                empty)))))))