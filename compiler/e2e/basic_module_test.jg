import * from '//compiler/prelude.jg'
import * from '//compiler/jaguarParser.jg'
import {scc, sccSorted as sortedScc} from '//compiler/graph.jg'
import * from '//compiler/ast.jg'

// Simple operator.
addition = 6 + 5

// Pattern match.
match = case (Pair 'foo' 'bar') of
  Pair a b -> a

// Data definitions
data Friend =
  Kitten String
  | Pony String String

getName = \f -> case f of
  Kitten n -> n
  Pony c n -> n

// Pattern matches on ADTs.
kittenName = getName (Kitten 'Fluffbun')
ponyName = getName (Pony 'pink' 'Fluttershy')

// Nested pattern matches.
nestedMatch = case (Pair (Kitten 'Fluffbun') 7) of
  Pair k 8 -> 2
  Pair (Pony c n) 7 -> 3
  Pair (Kitten n) 8 -> 4
  Pair (Kitten 'Buba') 7 -> 5
  Pair (Kitten 'Fluffbun') 7 -> 6

// Simple let.
letExpr =
  let
    x = 7
    y = 8
  in x + y

// Check that shadowing works as expected.
letExpr2 =
  let contains = False in not contains
  
// Syntax-sugar for function definitions.
f x = x + 1
fx = f 41

// Syntax sugar for funs in lets.
letF = let g y z = y + z + 1
       in g 10 2

scc1 = sortedScc (set 'a' ['b'] (set 'b' ['a'] (set 'c' ['a'] empty)))

scc2 =
  sort (scc
    (set '//compiler/e2e/basic_module_test.jg' ['//compiler/prelude.jg', '//compiler/jaguarParser.jg']
      (set '//compiler/prelude.jg' []
        (set '//compiler/ast.jg' ['//compiler/prelude.jg']
          (set '//compiler/parsers.jg' ['//compiler/prelude.jg']
            (set '//compiler/jaguarLexer.jg' ['//compiler/prelude.jg', '//compiler/parsers.jg']
              (set '//compiler/jaguarParser.jg' ['//compiler/prelude.jg', '//compiler/ast.jg', '//compiler/parsers.jg', '//compiler/jaguarLexer.jg']
                empty)))))))

class Foo a where
  yay :: a -> String
  double :: a -> Pair a a

instance Foo Number where
  yay n = intToString n
  double n = Pair n 13

instance Foo String where
  yay n = n
  double n = (n, 'foo')

typeClass = let
  x = yay 'pon'
  in x ++ 'y'

tryitF = yay
tryit2F x = x ++ tryitF 'foo'
tryit3F y = tryitF y

tryit = tryitF 'pony'
tryit2 = tryit2F 'pony'
tryit3 = tryit3F 42

fmapTest = case (fmap (\x -> x +1) (Just 12)) of
  Just n -> n
  Nothing -> 0

applicativeTest = case (pure (+) <*> Just 5 <*> Just 8) of
  Just n -> n
  Nothing -> 0

data TestMaybe a = TNothing | TJust a

instance Functor TestMaybe where
  fmap f m = case m of
    TNothing -> TNothing
    TJust x -> TJust (f x)

instance Applicative TestMaybe where
  pure = TJust
  (<*>) f a = case f of
    TNothing -> TNothing
    TJust f -> fmap f a

// Declasser can't currently handle this stuff.
applicativeTest2 = case (pure (+) <*> TJust 5 <*> TJust 8) of
  TJust n -> n
  TNothing -> 0

hamtTest = case (lookup 'pony' $ insert 'pony' 13 Empty) of
  Just n -> n
  Nothing -> 0

hamtTest2 = case (lookup 'kitten' $ insert 'pony' 13 Empty) of
  Just n -> n
  Nothing -> 42

hamtTestData = insert 'fluttershy' 13 $ insert 'applejack' 42 Empty

hamtTest3 = justOr 0 (pure (+) <*> lookup 'applejack' hamtTestData <*> lookup 'fluttershy' hamtTestData)
hamtTest4 = size hamtTestData
hamtTest5 = justOr 0 $ lookup 'fluttershy' (remove 'applejack' hamtTestData)

arrayTest = contains 'a' (concat ['a', 'b'] [])
arrayTest2 = [1,2,3]
