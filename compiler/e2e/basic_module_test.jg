import * from '//compiler/prelude.jg'
import * from '//compiler/jaguarParser.jg'
import {scc, sccSorted as sortedScc} from '//compiler/graph.jg'
import * from '//compiler/ast.jg'

// Simple operator.
addition = 6 + 5

// Pattern match.
match = case (Pair 'foo' 'bar') of
  Pair a b -> a

// Data definitions
data Friend =
  Kitten String
  | Pony String String

getName = \f -> case f of
  Kitten n -> n
  Pony c n -> n

// Pattern matches on ADTs.
kittenName = getName (Kitten 'Fluffbun')
ponyName = getName (Pony 'pink' 'Fluttershy')

// Nested pattern matches.
nestedMatch = case (Pair (Kitten 'Fluffbun') 7) of
  Pair k 8 -> 2
  Pair (Pony c n) 7 -> 3
  Pair (Kitten n) 8 -> 4
  Pair (Kitten 'Buba') 7 -> 5
  Pair (Kitten 'Fluffbun') 7 -> 6

// Simple let.
letExpr =
  let
    x = 7
    y = 8
  in x + y

// Check that shadowing works as expected.
letExpr2 =
  let contains = False in not contains
  
// Syntax-sugar for function definitions.
f x = x + 1
fx = f 41

// Syntax sugar for funs in lets.
letF = let g y z = y + z + 1
       in g 10 2

scc1 = sortedScc (set 'a' (arr1 'b') (set 'b' (arr1 'a') (set 'c' (arr1 'a') empty)))

scc2 =
  sort (scc
    (set '//compiler/e2e/basic_module_test.jg' (arr2 '//compiler/prelude.jg' '//compiler/jaguarParser.jg')
      (set '//compiler/prelude.jg' emptyArray
        (set '//compiler/ast.jg' (arr1 '//compiler/prelude.jg')
          (set '//compiler/parsers.jg'(arr1 '//compiler/prelude.jg')
            (set '//compiler/jaguarLexer.jg' (arr2 '//compiler/prelude.jg' '//compiler/parsers.jg')
              (set '//compiler/jaguarParser.jg' (arr4 '//compiler/prelude.jg' '//compiler/ast.jg' '//compiler/parsers.jg' '//compiler/jaguarLexer.jg')
                empty)))))))

class Foo a where
  yay :: a -> String
  double :: a -> Pair a a

instance Foo Number where
  yay n = intToString n
  double n = Pair n 13

instance Foo String where
  yay n = n
  double n = Pair n 'foo'

typeClass = let
  x = yay 'pon'
  in x ++ 'y'

tryitF = yay
tryit2F x = x ++ tryitF 'foo'
tryit3F y = tryitF y

tryit = tryitF 'pony'
tryit2 = tryit2F 'pony'
tryit3 = tryit3F 42

fmapTest = case (fmap (\x -> x +1) (Just 12)) of
  Just n -> n
  Nothing -> 0

applicativeTest = case (pure (+) <*> Just 5 <*> Just 8) of
  Just n -> n
  Nothing -> 0

data TestMaybe a = TNothing | TJust a

instance Functor TestMaybe where
  fmap f m = case m of
    TNothing -> TNothing
    TJust x -> TJust (f x)

instance Applicative TestMaybe where
  pure = TJust
  (<*>) f a = case f of
    TNothing -> TNothing
    TJust f -> fmap f a

// Declasser can't currently handle this stuff.
applicativeTest2 = case (pure (+) <*> TJust 5 <*> TJust 8) of
  TJust n -> n
  TNothing -> 0

// forall m. (Expr -> m (Either Expr Expr)) -> (Expr -> m Expr) -> Expr -> m Expr
mtest down up e = let
  go = mtest down up
  gos = mapM (\d -> case d of Pair n e -> go e >>= \e -> ret (Pair n e))
  in down e >>= \e -> case e of
    Right e -> ret e
    Left e -> case e of
      Lam ann p e -> go e >>= \e -> up (Lam ann p e)
      App ann f x -> go f >>= \f -> go x >>= \x -> up (App ann f x)
      Case ann e ps -> go e >>= \e -> gos ps >>= \ps -> up (Case ann e ps)
      Let ann bs e -> gos bs >>= \bs -> go e >>= \e -> up (Let ann bs e)
      _ -> up e

mtest2 env e = let
  newIdent n = gets >>= \i -> sets (i + 1) >> ret (n ++ '_$u$' ++ intToString i)
  rename n = case (has n env) of
    False -> ret n
    True -> newIdent n
  renamePat p = case p of
    PConst _ _ -> ret (Pair p empty)
    PVar ann v -> rename v >>= \n -> ret (Pair (PVar ann n) (set v n empty))
    PData ann n ps -> mapM renamePat ps >>= \ps -> ret (Pair (PData ann n (map fst ps)) (foldl merge empty (map snd ps)))
  rewritePat p = case p of Pair pat e -> renamePat pat >>= \pe -> case pe of Pair pat penv -> mtest2 (merge env penv) e >>= \e -> ret (Pair pat e)
  f e = case e of
    Lam ann p e -> rename p >>= \n -> mtest2 (set p n env) e >>= \e -> ret (Right (Lam ann n e))
    Let ann bs e -> let
      ns = map fst bs
      ns2 = mapM rename ns
      in ns2 >>= \ns -> let
        env2 = merge env (toRecord (zip (map fst bs) ns))
        bs2 = mapM (mtest2 env2) (map snd bs)
        e2 = mtest2 env2 e
        in bs2 >>= \bs -> e2 >>= \e -> ret (Right (Let ann (zip ns bs) e))
    Case ann e ps -> mtest2 env e >>= \e -> mapM rewritePat ps >>= \ps -> ret (Right (Case ann e ps))
    Var ann v -> ret (Left (Var ann (get v env)))
    _ -> ret (Left e)
  in mtest f ret e
