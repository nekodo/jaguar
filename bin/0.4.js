var $import$0 = require('builtins.js');
var $add = $import$0.$add;
var $del = $import$0.$del;
var $mul = $import$0.$mul;
var $lt = $import$0.$lt;
var $gt = $import$0.$gt;
var $eq = $import$0.$eq;
var $neq = $import$0.$neq;
var $and = $import$0.$and;
var $or = $import$0.$or;
var $concat = $import$0.$concat;
var empty = $import$0.empty;
var get = $import$0.get;
var del = $import$0.del;
var set = $import$0.set;
var unsafeStringToInt = $import$0.unsafeStringToInt;
var match = $import$0.match;
var drop = $import$0.drop;
var length = $import$0.length;
var emptyArray = $import$0.emptyArray;
var push = $import$0.push;
var enqueue = $import$0.enqueue;
var intToString = $import$0.intToString;
var intercalate = $import$0.intercalate;
var slice = $import$0.slice;
var concat = $import$0.concat;
var map = $import$0.map;
var filter = $import$0.filter;
var foldr = $import$0.foldr;
var foldr1 = $import$0.foldr1;
var foldl = $import$0.foldl;
var foldl1 = $import$0.foldl1;
var error = $import$0.error;
var jsonStringify = $import$0.jsonStringify;
var iterate = $import$0.iterate;
var True = $import$0.True;
var False = $import$0.False;
var $Just = function($0){this.$0 = $0};
var Just = $0 => new $Just($0);
var $Nothing = function(){};
var Nothing = new $Nothing();
var $Pair = function($0,$1){this.$0 = $0;this.$1 = $1};
var Pair = $0 => $1 => new $Pair($0,$1);
var $Left = function($0){this.$0 = $0};
var Left = $0 => new $Left($0);
var $Right = function($0){this.$0 = $0};
var Right = $0 => new $Right($0);
var $Success = function($0,$1){this.$0 = $0;this.$1 = $1};
var Success = $0 => $1 => new $Success($0,$1);
var $Error = function($0){this.$0 = $0};
var Error = $0 => new $Error($0);
var $LexerState = function($0,$1,$2,$3){this.$0 = $0;this.$1 = $1;this.$2 = $2;this.$3 = $3};
var LexerState = $0 => $1 => $2 => $3 => new $LexerState($0,$1,$2,$3);
var $WsTok = function(){};
var WsTok = new $WsTok();
var $SymTok = function(){};
var SymTok = new $SymTok();
var $NumTok = function(){};
var NumTok = new $NumTok();
var $StrTok = function(){};
var StrTok = new $StrTok();
var $OpTok = function(){};
var OpTok = new $OpTok();
var $IdTok = function(){};
var IdTok = new $IdTok();
var $ComTok = function(){};
var ComTok = new $ComTok();
var $Token = function($0,$1,$2,$3){this.$0 = $0;this.$1 = $1;this.$2 = $2;this.$3 = $3};
var Token = $0 => $1 => $2 => $3 => new $Token($0,$1,$2,$3);
var $Var = function($0){this.$0 = $0};
var Var = $0 => new $Var($0);
var $Const = function($0){this.$0 = $0};
var Const = $0 => new $Const($0);
var $App = function($0,$1){this.$0 = $0;this.$1 = $1};
var App = $0 => $1 => new $App($0,$1);
var $Lam = function($0,$1){this.$0 = $0;this.$1 = $1};
var Lam = $0 => $1 => new $Lam($0,$1);
var $Case = function($0,$1){this.$0 = $0;this.$1 = $1};
var Case = $0 => $1 => new $Case($0,$1);
var $CNum = function($0){this.$0 = $0};
var CNum = $0 => new $CNum($0);
var $CStr = function($0){this.$0 = $0};
var CStr = $0 => new $CStr($0);
var $PVar = function($0){this.$0 = $0};
var PVar = $0 => new $PVar($0);
var $PConst = function($0){this.$0 = $0};
var PConst = $0 => new $PConst($0);
var $PData = function($0,$1){this.$0 = $0;this.$1 = $1};
var PData = $0 => $1 => new $PData($0,$1);
var $Module = function($0,$1,$2){this.$0 = $0;this.$1 = $1;this.$2 = $2};
var Module = $0 => $1 => $2 => new $Module($0,$1,$2);
var $Data = function($0,$1,$2){this.$0 = $0;this.$1 = $1;this.$2 = $2};
var Data = $0 => $1 => $2 => new $Data($0,$1,$2);
var $DataCon = function($0,$1){this.$0 = $0;this.$1 = $1};
var DataCon = $0 => $1 => new $DataCon($0,$1);
var $TConst = function($0){this.$0 = $0};
var TConst = $0 => new $TConst($0);
var $TVar = function($0){this.$0 = $0};
var TVar = $0 => new $TVar($0);
var $TApp = function($0,$1){this.$0 = $0;this.$1 = $1};
var TApp = $0 => $1 => new $TApp($0,$1);
var $TFun = function($0,$1){this.$0 = $0;this.$1 = $1};
var TFun = $0 => $1 => new $TFun($0,$1);
var $ImportClosed = function($0,$1){this.$0 = $0;this.$1 = $1};
var ImportClosed = $0 => $1 => new $ImportClosed($0,$1);
var $ImportOpen = function($0,$1){this.$0 = $0;this.$1 = $1};
var ImportOpen = $0 => $1 => new $ImportOpen($0,$1);
var $ImportAll = function($0){this.$0 = $0};
var ImportAll = $0 => new $ImportAll($0);
var $ParserState = function($0,$1,$2,$3){this.$0 = $0;this.$1 = $1;this.$2 = $2;this.$3 = $3};
var ParserState = $0 => $1 => $2 => $3 => new $ParserState($0,$1,$2,$3);
var maybe = a => b => m => ($pm => {if(($pm instanceof $Just) && (true)){ return ((x) => (a)(x))($pm.$0)} else if(($pm instanceof $Nothing)){ return (() => b)()} else { throw 'pattern match fail' }})(m);
var fst = p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((a,b) => a)($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p);
var snd = p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((a,b) => b)($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p);
var either = f => g => e => ($pm => {if(($pm instanceof $Left) && (true)){ return ((a) => (f)(a))($pm.$0)} else if(($pm instanceof $Right) && (true)){ return ((b) => (g)(b))($pm.$0)} else { throw 'pattern match fail' }})(e);
var splitEither = a => ((Pair)(((map)(e => ($pm => {if(($pm instanceof $Left) && (true)){ return ((a) => a)($pm.$0)} else { throw 'pattern match fail' }})(e)))(((filter)(((either)(_ => True))(_ => False)))(a))))(((map)(e => ($pm => {if(($pm instanceof $Right) && (true)){ return ((b) => b)($pm.$0)} else { throw 'pattern match fail' }})(e)))(((filter)(((either)(_ => False))(_ => True)))(a)));
var not = b => ($pm => {if(($pm)){ return (() => False)()} else if((!$pm)){ return (() => True)()} else { throw 'pattern match fail' }})(b);
var contains2 = x => xs => i => ($pm => {if(($pm)){ return (() => ($pm => {if(($pm)){ return (() => True)()} else if((!$pm)){ return (() => (((contains2)(x))(xs))((($add)(i))(1)))()} else { throw 'pattern match fail' }})((($eq)(((get)(i))(xs)))(x)))()} else if((!$pm)){ return (() => False)()} else { throw 'pattern match fail' }})((($lt)(i))((length)(xs)));
var contains = x => xs => (((contains2)(x))(xs))(0);
var join = xs => s => ($pm => {if(($pm == 0)){ return (() => "")()} else if((true)){ return ((n) => ((foldl1)(a => b => (($concat)((($concat)(a))(s)))(b)))(xs))($pm)} else { throw 'pattern match fail' }})((length)(xs));
var zipWithIndex2 = n => xs => ($pm => {if(($pm == 0)){ return (() => emptyArray)()} else if((true)){ return ((x) => ((enqueue)(((Pair)(n))(((get)(0))(xs))))(((zipWithIndex2)((($add)(n))(1)))(((slice)(1))(xs))))($pm)} else { throw 'pattern match fail' }})((length)(xs));
var zipWithIndex = (zipWithIndex2)(0);
var concatMap = f => a => (((foldl)(concat))(emptyArray))(((map)(f))(a));
var and = a => b => s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((a,s) => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((b,s) => ((Success)(((Pair)(a))(b)))(s))($pm.$0,$pm.$1)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})((b)(s)))($pm.$0,$pm.$1)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})((a)(s));
var apply = f => p => s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((r,s) => ((Success)((f)(r)))(s))($pm.$0,$pm.$1)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})((p)(s));
var precedes = a => b => ((apply)(snd))(((and)(a))(b));
var succeeds = a => b => ((apply)(fst))(((and)(a))(b));
var between = a => b => c => ((precedes)(a))(((succeeds)(b))(c));
var or = a => b => s => ($pm => {if(($pm instanceof $Error) && (true)){ return ((e) => (b)(s))($pm.$0)} else if((true)){ return ((s) => s)($pm)} else { throw 'pattern match fail' }})((a)(s));
var manyIterate = p => s => (((iterate)((Left)(((Success)(emptyArray))(s))))(r => ($pm => {if(($pm instanceof $Left) && (true)){ return ((s) => False)($pm.$0)} else if(($pm instanceof $Right) && (true)){ return ((s) => True)($pm.$0)} else { throw 'pattern match fail' }})(r)))(rs => ($pm => {if(($pm instanceof $Left) && ($pm.$0 instanceof $Success) && (true) && (true)){ return ((rs,s) => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((r,s) => (Left)(((Success)(((push)(r))(rs)))(s)))($pm.$0,$pm.$1)} else if(($pm instanceof $Error) && (true)){ return ((e) => (Right)(((Success)(rs))(s)))($pm.$0)} else { throw 'pattern match fail' }})((p)(s)))($pm.$0.$0,$pm.$0.$1)} else { throw 'pattern match fail' }})(rs));
var many = p => s => ($pm => {if(($pm instanceof $Right) && (true)){ return ((a) => a)($pm.$0)} else if(($pm instanceof $Left) && (true)){ return ((b) => (error)("manyIterate should never return a Left"))($pm.$0)} else { throw 'pattern match fail' }})(((manyIterate)(p))(s));
var many1 = a => s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((r,s) => (((apply)((enqueue)(r)))((many)(a)))(s))($pm.$0,$pm.$1)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})((a)(s));
var sepBy1 = p => s => ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((r,rs) => ((enqueue)(r))(rs))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)(p))((many)(((precedes)(s))(p))));
var opt = a => s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((r,s) => ((Success)((Just)(r)))(s))($pm.$0,$pm.$1)} else if((true)){ return ((e) => ((Success)(Nothing))(s))($pm)} else { throw 'pattern match fail' }})((a)(s));
var mkTok = t => p => i => ($pm => {if(($pm instanceof $LexerState) && (true) && (true) && (true) && (true)){ return ((_1,_2,l,c) => (((apply)(r => ((((Token)(t))(r))(l))(c)))(p))(i))($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(i);
var concatStr = (apply)(((foldl)(cs => c => (($concat)(cs))(c)))(""));
var runLexer = p => s => (p)(((((LexerState)(s))(0))(0))(0));
var parseChar = p => s => ($pm => {if(($pm instanceof $LexerState) && (true) && (true) && (true) && (true)){ return ((s,i,l,c) => ($pm => {if((!$pm)){ return (() => (Error)("parser failed"))()} else if(($pm)){ return (() => ($pm => {if(($pm == "\n")){ return (() => ((Success)(((get)(i))(s)))(((((LexerState)(s))((($add)(i))(1)))((($add)(l))(1)))(0)))()} else if((true)){ return ((x) => ((Success)(((get)(i))(s)))(((((LexerState)(s))((($add)(i))(1)))(l))((($add)(c))(1))))($pm)} else { throw 'pattern match fail' }})(((get)(i))(s)))()} else { throw 'pattern match fail' }})((p)(((get)(i))(s))))($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(s);
var anyCharP = (parseChar)(c => True);
var charP = cs => (parseChar)(c => ((contains)(c))(cs));
var notCharP = cs => (parseChar)(c => (not)(((contains)(c))(cs)));
var stringCharP = ((or)(((apply)(c => "\n"))(((and)((charP)("\\")))((charP)("n")))))(((or)(((precedes)((charP)("\\")))(anyCharP)))((notCharP)("'")));
var stringP = ((mkTok)(StrTok))((concatStr)((((between)((charP)("'")))((many)(stringCharP)))((charP)("'"))));
var whitespaceP = ((mkTok)(WsTok))((concatStr)((many1)((charP)(" \n"))));
var digits = "0123456789";
var intP = (concatStr)((many1)((charP)(digits)));
var numP = ((mkTok)(NumTok))(((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((a,b) => (($concat)(a))(b))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)(intP))(((apply)(((maybe)(n => (($concat)("."))(n)))("")))((opt)(((precedes)((charP)(".")))(intP))))));
var lineCommentP = ((mkTok)(ComTok))((concatStr)(((precedes)(((and)((charP)("/")))((charP)("/"))))((many)((notCharP)("\n")))));
var symbolP = ((mkTok)(SymTok))((charP)("()[]{},\\"));
var upperCaseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var letters = (($concat)("abcdefghijklmnopqrstuvwxyz"))(upperCaseLetters);
var identP = ((mkTok)(IdTok))(((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((a,b) => (($concat)(a))(b))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)((charP)((($concat)(letters))("_"))))((concatStr)((many)((charP)((($concat)((($concat)(letters))(digits)))("_")))))));
var opP = ((mkTok)(OpTok))((concatStr)((many1)((charP)("-+*/=:&|<>^"))));
var jaguarTokenP = (many)(((or)(stringP))(((or)(whitespaceP))(((or)(numP))(((or)(lineCommentP))(((or)(identP))(((or)(opP))(symbolP)))))));
var mkParserState = ts => ((((ParserState)(ts))(0))(($pm => {if(($pm instanceof $Token) && (true) && (true) && (true) && (true)){ return ((t,v,l,c) => c)($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(((get)(0))(ts))))(((push)(0))(emptyArray));
var filterWhitespaceAndComments = (filter)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $WsTok) && (true) && (true) && (true)){ return ((v,l,c) => False)($pm.$1,$pm.$2,$pm.$3)} else if(($pm instanceof $Token) && ($pm.$0 instanceof $ComTok) && (true) && (true) && (true)){ return ((v,l,c) => False)($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((t) => True)($pm)} else { throw 'pattern match fail' }})(t));
var runParser = p => s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((ts,s) => (p)((mkParserState)((filterWhitespaceAndComments)(ts))))($pm.$0,$pm.$1)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})(((runLexer)(jaguarTokenP))(s));
var parseToken = f => s => ($pm => {if(($pm instanceof $ParserState) && (true) && (true) && (true) && (true)){ return ((ts,p,li,ri) => ($pm => {if((!$pm)){ return (() => (Error)("run out of tokens"))()} else if(($pm)){ return (() => ($pm => {if(($pm instanceof $Token) && (true) && (true) && (true) && (true)){ return ((t,v,l,c) => ($pm => {if(($pm)){ return (() => (Error)("token not indented sufficiently"))()} else if((!$pm)){ return (() => ($pm => {if(($pm instanceof $Nothing)){ return (() => (Error)("parser fun failed"))()} else if(($pm instanceof $Just) && (true)){ return ((r) => ($pm => {if((!$pm)){ return (() => ((Success)(r))(((((ParserState)(ts))((($add)(p))(1)))(li))(ri)))()} else if(($pm)){ return (() => ($pm => {if(($pm instanceof $Token) && (true) && (true) && (true) && (true)){ return ((t,v,l2,c) => ($pm => {if((!$pm)){ return (() => ((Success)(r))(((((ParserState)(ts))((($add)(p))(1)))(li))(ri)))()} else if(($pm)){ return (() => ((Success)(r))(((((ParserState)(ts))((($add)(p))(1)))(c))(ri)))()} else { throw 'pattern match fail' }})((($gt)(l2))(l)))($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(((get)((($add)(p))(1)))(ts)))()} else { throw 'pattern match fail' }})((($lt)((($add)(p))(1)))((length)(ts))))($pm.$0)} else { throw 'pattern match fail' }})((f)(((get)(p))(ts))))()} else { throw 'pattern match fail' }})((($lt)(c))(ri)))($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(((get)(p))(ts)))()} else { throw 'pattern match fail' }})((($lt)(p))((length)(ts))))($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(s);
var andIndent = a => b => s => ($pm => {if(($pm instanceof $ParserState) && (true) && (true) && (true) && (true)){ return ((ts,p,li,ri) => ($pm => {if(($pm instanceof $Success) && (true) && ($pm.$1 instanceof $ParserState) && (true) && (true) && (true) && (true)){ return ((a,ts,p2,li2,ri2) => ($pm => {if(($pm instanceof $Success) && (true) && ($pm.$1 instanceof $ParserState) && (true) && (true) && (true) && (true)){ return ((b,ts,p3,li3,ri3) => ((Success)(((Pair)(a))(b)))(((((ParserState)(ts))(p3))(li3))(ri)))($pm.$0,$pm.$1.$0,$pm.$1.$1,$pm.$1.$2,$pm.$1.$3)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})((b)(((((ParserState)(ts))(p2))(li2))((($add)(li))(1)))))($pm.$0,$pm.$1.$0,$pm.$1.$1,$pm.$1.$2,$pm.$1.$3)} else if((true)){ return ((e) => e)($pm)} else { throw 'pattern match fail' }})((a)(s)))($pm.$0,$pm.$1,$pm.$2,$pm.$3)} else { throw 'pattern match fail' }})(s);
var reserved = ((push)("from"))(((push)("import"))(((push)("case"))(((push)("of"))(((push)("data"))(emptyArray)))));
var symP = s => (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $SymTok) && (true) && (true) && (true)){ return ((v,i,c) => ($pm => {if(($pm)){ return (() => (Just)(s))()} else if((!$pm)){ return (() => Nothing)()} else { throw 'pattern match fail' }})((($eq)(v))(s)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var operatorP = s => (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $OpTok) && (true) && (true) && (true)){ return ((v,i,c) => ($pm => {if(($pm)){ return (() => (Just)(s))()} else if((!$pm)){ return (() => Nothing)()} else { throw 'pattern match fail' }})((($eq)(v))(s)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var anyOpP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $OpTok) && (true) && (true) && (true)){ return ((v,i,c) => (Just)(v))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var reservedP = s => (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $IdTok) && (true) && (true) && (true)){ return ((v,i,c) => ($pm => {if(($pm)){ return (() => (Just)(s))()} else if((!$pm)){ return (() => Nothing)()} else { throw 'pattern match fail' }})((($eq)(v))(s)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var nonReservedP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $IdTok) && (true) && (true) && (true)){ return ((v,l,c) => ($pm => {if(($pm)){ return (() => Nothing)()} else if((!$pm)){ return (() => (Just)(v))()} else { throw 'pattern match fail' }})(((contains)(v))(reserved)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var upperCaseId = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $IdTok) && (true) && (true) && (true)){ return ((v,i,c) => ($pm => {if(($pm)){ return (() => (Just)(v))()} else if((!$pm)){ return (() => Nothing)()} else { throw 'pattern match fail' }})(((contains)(((get)(0))(v)))(upperCaseLetters)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((t) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var notUpperCaseId = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $IdTok) && (true) && (true) && (true)){ return ((v,i,c) => ($pm => {if((!$pm)){ return (() => ($pm => {if((!$pm)){ return (() => (Just)(v))()} else if(($pm)){ return (() => Nothing)()} else { throw 'pattern match fail' }})(((contains)(v))(reserved)))()} else if(($pm)){ return (() => Nothing)()} else { throw 'pattern match fail' }})(((contains)(((get)(0))(v)))(upperCaseLetters)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((t) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var parenP = p => (((between)((symP)("(")))(p))((symP)(")"));
var varP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $IdTok) && (true) && (true) && (true)){ return ((v,l,c) => ($pm => {if(($pm)){ return (() => Nothing)()} else if((!$pm)){ return (() => (Just)((Var)(v)))()} else { throw 'pattern match fail' }})(((contains)(v))(reserved)))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var cnumP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $NumTok) && (true) && (true) && (true)){ return ((v,l,c) => (Just)((Const)((CNum)((unsafeStringToInt)(v)))))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var cstrP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $StrTok) && (true) && (true) && (true)){ return ((v,l,c) => (Just)((Const)((CStr)(v))))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var constP = ((or)(cstrP))(cnumP);
var simpleExprP = s => (((or)(varP))(((or)(constP))((parenP)(exprP))))(s);
var appP = s => (((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((f,as) => (((foldl)(f => a => ((App)(f))(a)))(f))(as))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)(((or)(varP))((parenP)(exprP))))((many)(simpleExprP))))(s);
var lamP = s => (((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && (true)){ return ((_,ps,a) => (((foldr)(a => p => ((Lam)(p))(a)))(a))(ps))($pm.$0,$pm.$1.$0,$pm.$1.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)((symP)("\\")))(((and)((many1)(notUpperCaseId)))(((precedes)((operatorP)("->")))(exprP)))))(s);
var pvarP = ((apply)(PVar))(notUpperCaseId);
var pcnumP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $NumTok) && (true) && (true) && (true)){ return ((v,l,c) => (Just)((PConst)((CNum)((unsafeStringToInt)(v)))))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var pcstrP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $StrTok) && (true) && (true) && (true)){ return ((v,l,c) => (Just)((PConst)((CStr)(v))))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var strP = (parseToken)(t => ($pm => {if(($pm instanceof $Token) && ($pm.$0 instanceof $StrTok) && (true) && (true) && (true)){ return ((v,l,c) => (Just)(v))($pm.$1,$pm.$2,$pm.$3)} else if((true)){ return ((x) => Nothing)($pm)} else { throw 'pattern match fail' }})(t));
var pconstP = ((or)(pcnumP))(pcstrP);
var pdataP = s => (((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((n,ps) => ((PData)(n))(ps))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)(upperCaseId))((many)(((or)(pvarP))(((or)(pconstP))((parenP)(patP)))))))(s);
var patP = ((or)(pvarP))(((or)(pconstP))(pdataP));
var ofP = s => (((andIndent)(patP))(((precedes)((operatorP)("->")))(exprP)))(s);
var caseP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && (true)){ return ((_,e,ps) => ((Case)(e))(ps))($pm.$0,$pm.$1.$0,$pm.$1.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)((reservedP)("case")))(((and)(simpleExprP))(((precedes)((reservedP)("of")))((many1)(ofP)))));
var primaryExprP = s => (((or)(appP))(((or)(constP))(((or)(lamP))(caseP))))(s);
var exprP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((e,oes) => (((foldl)(a => ob => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((op,b) => ((App)(((App)((Var)(op)))(a)))(b))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(ob)))(e))(oes))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)(primaryExprP))((many)(((and)(anyOpP))(primaryExprP))));
var tconstP = ((apply)(TConst))(upperCaseId);
var tvarP = ((apply)(TVar))(notUpperCaseId);
var simpleTypeP = s => (((or)(tconstP))(((or)(tvarP))((parenP)(typeP))))(s);
var tappP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((t,ts) => (((foldl)(a => b => ((TApp)(a))(b)))(t))(ts))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)(simpleTypeP))((many)(simpleTypeP)));
var tfunP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((t,ts) => ((foldr1)(b => a => ((TFun)(a))(b)))(((enqueue)(t))(ts)))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)(tappP))((many)(((precedes)((operatorP)("->")))(tappP))));
var typeP = tfunP;
var dataConP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((n,ts) => ((DataCon)(n))(ts))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((andIndent)(upperCaseId))((many)(simpleTypeP)));
var dataP = ((apply)(r => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && ($pm.$1.$1 instanceof $Pair) && (true) && (true)){ return ((_,n,ps,cs) => (((Data)(n))(ps))(cs))($pm.$0,$pm.$1.$0,$pm.$1.$1.$0,$pm.$1.$1.$1)} else { throw 'pattern match fail' }})(r)))(((andIndent)((reservedP)("data")))(((and)(upperCaseId))(((and)((many)(notUpperCaseId)))(((precedes)((operatorP)("=")))(((sepBy1)(dataConP))((operatorP)("|")))))));
var defP = ((andIndent)(notUpperCaseId))(((precedes)((operatorP)("=")))(exprP));
var importClosedP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((n,f) => ((ImportClosed)(f))(n))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)(nonReservedP))(((precedes)((reservedP)("from")))(strP)));
var importOpenP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((ns,f) => ((ImportOpen)(f))(ns))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)((((between)((symP)("{")))(((sepBy1)(nonReservedP))((symP)(","))))((symP)("}"))))(((precedes)((reservedP)("from")))(strP)));
var importAllP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((n,f) => (ImportAll)(f))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)((operatorP)("*")))(((precedes)((reservedP)("from")))(strP)));
var importP = ((apply)(snd))(((andIndent)((reservedP)("import")))(((or)(importClosedP))(((or)(importOpenP))(importAllP))));
var moduleP = ((apply)(p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((is,es) => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((dts,dfs) => (((Module)(is))(dts))(dfs))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})((splitEither)(es)))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p)))(((and)((many)(importP)))((many1)(((or)(((apply)(Left))(dataP)))(((apply)(Right))(defP)))));
var opName = op => ($pm => {if(($pm == "+")){ return (() => "$add")()} else if(($pm == "-")){ return (() => "$del")()} else if(($pm == "*")){ return (() => "$mul")()} else if(($pm == "<")){ return (() => "$lt")()} else if(($pm == ">")){ return (() => "$gt")()} else if(($pm == "++")){ return (() => "$concat")()} else if(($pm == "==")){ return (() => "$eq")()} else if(($pm == "/=")){ return (() => "$neq")()} else if(($pm == "&&")){ return (() => "$and")()} else if(($pm == "||")){ return (() => "$or")()} else if((true)){ return ((x) => x)($pm)} else { throw 'pattern match fail' }})(op);
var exprToJS = e => ($pm => {if(($pm instanceof $Var) && (true)){ return ((n) => (opName)(n))($pm.$0)} else if(($pm instanceof $Const) && ($pm.$0 instanceof $CNum) && (true)){ return ((n) => (jsonStringify)(n))($pm.$0.$0)} else if(($pm instanceof $Const) && ($pm.$0 instanceof $CStr) && (true)){ return ((s) => (jsonStringify)(s))($pm.$0.$0)} else if(($pm instanceof $App) && (true) && (true)){ return ((f,a) => (($concat)((($concat)((($concat)((($concat)("("))((exprToJS)(f))))(")(")))((exprToJS)(a))))(")"))($pm.$0,$pm.$1)} else if(($pm instanceof $Lam) && (true) && (true)){ return ((n,b) => (($concat)((($concat)(n))(" => ")))((exprToJS)(b)))($pm.$0,$pm.$1)} else if(($pm instanceof $Case) && (true) && (true)){ return ((e,ps) => (($concat)((($concat)((($concat)((($concat)("($pm => {"))(((join)(((map)(ofToJS))(ps)))(" else "))))(" else { throw 'pattern match fail' }})(")))((exprToJS)(e))))(")"))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(e);
var ofToJS = p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((pat,e) => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && (true)){ return ((cs,ps,vs) => (($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)("if("))(((join)(((map)(c => (($concat)((($concat)("("))(c)))(")")))(cs)))(" && "))))("){ return ((")))(((join)(ps))(","))))(") => ")))((exprToJS)(e))))(")(")))(((join)(vs))(","))))(")}"))($pm.$0,$pm.$1.$0,$pm.$1.$1)} else { throw 'pattern match fail' }})(((patToJS)(pat))("$pm")))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p);
var arr1 = a => ((push)(a))(emptyArray);
var arr2 = a => b => ((push)(b))((arr1)(a));
var patToJS = p => v => ($pm => {if(($pm instanceof $PVar) && (true)){ return ((n) => ((Pair)((arr1)("true")))(((Pair)((arr1)(n)))((arr1)(v))))($pm.$0)} else if(($pm instanceof $PConst) && ($pm.$0 instanceof $CNum) && (true)){ return ((n) => ((Pair)((arr1)((($concat)((($concat)(v))(" == ")))((jsonStringify)(n)))))(((Pair)(emptyArray))(emptyArray)))($pm.$0.$0)} else if(($pm instanceof $PConst) && ($pm.$0 instanceof $CStr) && (true)){ return ((s) => ((Pair)((arr1)((($concat)((($concat)(v))(" == ")))((jsonStringify)(s)))))(((Pair)(emptyArray))(emptyArray)))($pm.$0.$0)} else if(($pm instanceof $PData) && ($pm.$0 == "True") && (true)){ return ((ps) => ((Pair)((arr1)(v)))(((Pair)(emptyArray))(emptyArray)))($pm.$1)} else if(($pm instanceof $PData) && ($pm.$0 == "False") && (true)){ return ((ps) => ((Pair)((arr1)((($concat)("!"))(v))))(((Pair)(emptyArray))(emptyArray)))($pm.$1)} else if(($pm instanceof $PData) && (true) && (true)){ return ((n,ps) => (((foldl)(r => p => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && (true)){ return ((cs,ps,vs) => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((i,p) => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && (true)){ return ((cs2,ps2,vs2) => ((Pair)(((concat)(cs))(cs2)))(((Pair)(((concat)(ps))(ps2)))(((concat)(vs))(vs2))))($pm.$0,$pm.$1.$0,$pm.$1.$1)} else { throw 'pattern match fail' }})(((patToJS)(p))((($concat)((($concat)(v))(".$")))(i))))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p))($pm.$0,$pm.$1.$0,$pm.$1.$1)} else { throw 'pattern match fail' }})(r)))(((Pair)((arr1)((($concat)((($concat)(v))(" instanceof $")))(n))))(((Pair)(emptyArray))(emptyArray))))((zipWithIndex)(ps)))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p);
var dataToJS = d => ($pm => {if(($pm instanceof $Data) && (true) && (true) && (true)){ return ((n,ps,cs) => ((join)(((map)(dataConToJS))(cs)))("\n"))($pm.$0,$pm.$1,$pm.$2)} else { throw 'pattern match fail' }})(d);
var dlr = ts => ((map)(p => (($concat)("$"))((fst)(p))))((zipWithIndex)(ts));
var dataConToJS = c => ($pm => {if(($pm instanceof $DataCon) && (true) && (true)){ return ((n,ts) => (($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)((($concat)("var $"))(n)))(" = function(")))(((join)((dlr)(ts)))(","))))("){")))(((join)(((map)(p => (($concat)((($concat)((($concat)("this."))(p)))(" = ")))(p)))((dlr)(ts))))(";"))))("};\n")))("var ")))(n)))(" = ")))(((join)(((map)(p => (($concat)(p))(" => ")))((dlr)(ts))))(""))))("new $")))(n)))("(")))(((join)((dlr)(ts)))(","))))(");"))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(c);
var defToJS = p => ($pm => {if(($pm instanceof $Pair) && (true) && (true)){ return ((n,e) => (($concat)((($concat)((($concat)((($concat)("var "))(n)))(" = ")))((exprToJS)(e))))(";"))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(p);
var getImportFile = i => ($pm => {if(($pm instanceof $ImportClosed) && (true) && (true)){ return ((f,n) => f)($pm.$0,$pm.$1)} else if(($pm instanceof $ImportOpen) && (true) && (true)){ return ((f,ns) => f)($pm.$0,$pm.$1)} else if(($pm instanceof $ImportAll) && (true)){ return ((f) => f)($pm.$0)} else { throw 'pattern match fail' }})(i);
var importToJS = ixssi => ($pm => {if(($pm instanceof $Pair) && (true) && ($pm.$1 instanceof $Pair) && (true) && (true)){ return ((ix,ss,i) => ($pm => {if(($pm instanceof $ImportClosed) && (true) && (true)){ return ((f,n) => (($concat)((($concat)((($concat)((($concat)("var "))(n)))(" = require('")))(f)))("');"))($pm.$0,$pm.$1)} else if(($pm instanceof $ImportOpen) && (true) && (true)){ return ((f,ns) => (($concat)((($concat)((($concat)((($concat)((($concat)("var $import$"))(ix)))(" = require('")))(f)))("');\n")))(((join)(((map)(n => (($concat)((($concat)((($concat)((($concat)((($concat)((($concat)("var "))(n)))(" = $import$")))(ix)))(".")))(n)))(";")))(ns)))("\n")))($pm.$0,$pm.$1)} else if(($pm instanceof $ImportAll) && (true)){ return ((f) => (($concat)((($concat)((($concat)((($concat)((($concat)("var $import$"))(ix)))(" = require('")))(f)))("');\n")))(((join)(((map)(n => (($concat)((($concat)((($concat)((($concat)((($concat)((($concat)("var "))(n)))(" = $import$")))(ix)))(".")))(n)))(";")))(ss)))("\n")))($pm.$0)} else { throw 'pattern match fail' }})(i))($pm.$0,$pm.$1.$0,$pm.$1.$1)} else { throw 'pattern match fail' }})(ixssi);
var builtinsImport = (ImportAll)("projects/jaguar/builtins.js");
var moduleToJS = importSymbols => m => ($pm => {if(($pm instanceof $Module) && (true) && (true) && (true)){ return ((is,dts,dfs) => (($concat)((($concat)((($concat)((($concat)((($concat)(((join)(((map)(importToJS))((zipWithIndex)(((map)(i => ((Pair)(((get)((getImportFile)(i)))(importSymbols)))(i)))(((push)(builtinsImport))(is))))))("\n")))("\n")))(((join)(((concat)(((map)(dataToJS))(dts)))(((map)(defToJS))(dfs))))("\n"))))("\nexports = {")))(((join)(((map)(n => (($concat)((($concat)(n))(":")))(n)))(((concat)(((concatMap)(d => ($pm => {if(($pm instanceof $Data) && (true) && (true) && (true)){ return ((n,ps,cs) => ((concatMap)(c => ($pm => {if(($pm instanceof $DataCon) && (true) && (true)){ return ((n,ts) => ((arr2)(n))((($concat)("$"))(n)))($pm.$0,$pm.$1)} else { throw 'pattern match fail' }})(c)))(cs))($pm.$0,$pm.$1,$pm.$2)} else { throw 'pattern match fail' }})(d)))(dts)))(((map)(fst))(dfs)))))(","))))("};"))($pm.$0,$pm.$1,$pm.$2)} else { throw 'pattern match fail' }})(m);
var transpileModule = importSymbols => s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((m,ts) => ((moduleToJS)(importSymbols))(m))($pm.$0,$pm.$1)} else if(($pm instanceof $Error) && (true)){ return ((e) => (error)(e))($pm.$0)} else { throw 'pattern match fail' }})(((runParser)(moduleP))(s));
var findImports = s => ($pm => {if(($pm instanceof $Success) && (true) && (true)){ return ((is,ts) => ((push)("projects/jaguar/builtins.js"))(((map)(getImportFile))(is)))($pm.$0,$pm.$1)} else if(($pm instanceof $Error) && (true)){ return ((e) => (error)(e))($pm.$0)} else { throw 'pattern match fail' }})(((runParser)((many)(importP)))(s));
exports = {Just:Just,$Just:$Just,Nothing:Nothing,$Nothing:$Nothing,Pair:Pair,$Pair:$Pair,Left:Left,$Left:$Left,Right:Right,$Right:$Right,Success:Success,$Success:$Success,Error:Error,$Error:$Error,LexerState:LexerState,$LexerState:$LexerState,WsTok:WsTok,$WsTok:$WsTok,SymTok:SymTok,$SymTok:$SymTok,NumTok:NumTok,$NumTok:$NumTok,StrTok:StrTok,$StrTok:$StrTok,OpTok:OpTok,$OpTok:$OpTok,IdTok:IdTok,$IdTok:$IdTok,ComTok:ComTok,$ComTok:$ComTok,Token:Token,$Token:$Token,Var:Var,$Var:$Var,Const:Const,$Const:$Const,App:App,$App:$App,Lam:Lam,$Lam:$Lam,Case:Case,$Case:$Case,CNum:CNum,$CNum:$CNum,CStr:CStr,$CStr:$CStr,PVar:PVar,$PVar:$PVar,PConst:PConst,$PConst:$PConst,PData:PData,$PData:$PData,Module:Module,$Module:$Module,Data:Data,$Data:$Data,DataCon:DataCon,$DataCon:$DataCon,TConst:TConst,$TConst:$TConst,TVar:TVar,$TVar:$TVar,TApp:TApp,$TApp:$TApp,TFun:TFun,$TFun:$TFun,ImportClosed:ImportClosed,$ImportClosed:$ImportClosed,ImportOpen:ImportOpen,$ImportOpen:$ImportOpen,ImportAll:ImportAll,$ImportAll:$ImportAll,ParserState:ParserState,$ParserState:$ParserState,maybe:maybe,fst:fst,snd:snd,either:either,splitEither:splitEither,not:not,contains2:contains2,contains:contains,join:join,zipWithIndex2:zipWithIndex2,zipWithIndex:zipWithIndex,concatMap:concatMap,and:and,apply:apply,precedes:precedes,succeeds:succeeds,between:between,or:or,manyIterate:manyIterate,many:many,many1:many1,sepBy1:sepBy1,opt:opt,mkTok:mkTok,concatStr:concatStr,runLexer:runLexer,parseChar:parseChar,anyCharP:anyCharP,charP:charP,notCharP:notCharP,stringCharP:stringCharP,stringP:stringP,whitespaceP:whitespaceP,digits:digits,intP:intP,numP:numP,lineCommentP:lineCommentP,symbolP:symbolP,upperCaseLetters:upperCaseLetters,letters:letters,identP:identP,opP:opP,jaguarTokenP:jaguarTokenP,mkParserState:mkParserState,filterWhitespaceAndComments:filterWhitespaceAndComments,runParser:runParser,parseToken:parseToken,andIndent:andIndent,reserved:reserved,symP:symP,operatorP:operatorP,anyOpP:anyOpP,reservedP:reservedP,nonReservedP:nonReservedP,upperCaseId:upperCaseId,notUpperCaseId:notUpperCaseId,parenP:parenP,varP:varP,cnumP:cnumP,cstrP:cstrP,constP:constP,simpleExprP:simpleExprP,appP:appP,lamP:lamP,pvarP:pvarP,pcnumP:pcnumP,pcstrP:pcstrP,strP:strP,pconstP:pconstP,pdataP:pdataP,patP:patP,ofP:ofP,caseP:caseP,primaryExprP:primaryExprP,exprP:exprP,tconstP:tconstP,tvarP:tvarP,simpleTypeP:simpleTypeP,tappP:tappP,tfunP:tfunP,typeP:typeP,dataConP:dataConP,dataP:dataP,defP:defP,importClosedP:importClosedP,importOpenP:importOpenP,importAllP:importAllP,importP:importP,moduleP:moduleP,opName:opName,exprToJS:exprToJS,ofToJS:ofToJS,arr1:arr1,arr2:arr2,patToJS:patToJS,dataToJS:dataToJS,dlr:dlr,dataConToJS:dataConToJS,defToJS:defToJS,getImportFile:getImportFile,importToJS:importToJS,builtinsImport:builtinsImport,moduleToJS:moduleToJS,transpileModule:transpileModule,findImports:findImports};